import {
  init_tslib_es6,
  tslib_es6_exports
} from "/build/_shared/chunk-J7KSIMTT.js";
import {
  require_crypto
} from "/build/_shared/chunk-MTSWSNGB.js";
import {
  require_inherits_browser
} from "/build/_shared/chunk-LFIEXLVA.js";
import {
  EventEmitter,
  init_events,
  y
} from "/build/_shared/chunk-3KZTRC5K.js";
import {
  require_dijkstra
} from "/build/_shared/chunk-3I2KYFG3.js";
import {
  require_bs58
} from "/build/_shared/chunk-F45K7DGY.js";
import {
  PublicKey,
  Transaction,
  buffer_exports,
  init_buffer2 as init_buffer,
  init_index_browser_esm,
  require_bn,
  require_buffer
} from "/build/_shared/chunk-224XRCKB.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-DPSM2F2X.js";

// node_modules/.pnpm/@walletconnect+window-getters@1.0.0/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/@walletconnect+window-getters@1.0.0/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name2) {
      const res = getFromWindow3(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/.pnpm/@walletconnect+window-metadata@1.0.0/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/.pnpm/@walletconnect+window-metadata@1.0.0/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e4) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i5 = 0; i5 < links.length; i5++) {
          const link = links[i5];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i5 = 0; i5 < metaTags.length; i5++) {
          const tag = metaTags[i5];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/.pnpm/detect-browser@5.2.0/node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version9 = versionParts.join(".");
  var os2 = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version9, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version9, os2);
}
function detectOS(ua) {
  for (var ii3 = 0, count = operatingSystemRules.length; ii3 < count; ii3++) {
    var _a = operatingSystemRules[ii3], os2 = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii3 = 0; ii3 < count; ii3++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/.pnpm/detect-browser@5.2.0/node_modules/detect-browser/es/index.js"() {
    __spreadArrays = function() {
      for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
        s5 += arguments[i5].length;
      for (var r5 = Array(s5), k7 = 0, i5 = 0; i5 < il; i5++)
        for (var a4 = arguments[i5], j6 = 0, jl = a4.length; j6 < jl; j6++, k7++)
          r5[k7] = a4[j6];
      return r5;
    };
    BrowserInfo = /** @class */
    function() {
      function BrowserInfo3(name2, version9, os2) {
        this.name = name2;
        this.version = version9;
        this.os = os2;
        this.type = "browser";
      }
      return BrowserInfo3;
    }();
    NodeInfo = /** @class */
    function() {
      function NodeInfo3(version9) {
        this.version = version9;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo3;
    }();
    SearchBotDeviceInfo = /** @class */
    function() {
      function SearchBotDeviceInfo3(name2, version9, os2, bot) {
        this.name = name2;
        this.version = version9;
        this.os = os2;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo3;
    }();
    BotInfo = /** @class */
    function() {
      function BotInfo3() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo3;
    }();
    ReactNativeInfo = /** @class */
    function() {
      function ReactNativeInfo3() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo3;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env = detectEnv();
  return env && env.os ? env.os : void 0;
}
function isAndroid() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os2 = detectOS2();
  return os2 ? os2.toLowerCase().includes("ios") || os2.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os2 = detectOS2();
  return os2 ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env = detectEnv();
  const result = env && env.name ? env.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    windowMetadata = __toESM(require_cjs2());
    windowGetters = __toESM(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/.pnpm/@walletconnect+safe-json@1.0.0/node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/.pnpm/@walletconnect+safe-json@1.0.0/node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key2, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key2);
  }
}
var init_local = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_json();
    init_browser();
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/.pnpm/@walletconnect+browser-utils@1.8.0/node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js"(exports, module) {
    var toString3 = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString3.call(arr) == "[object Array]";
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports, module) {
    "use strict";
    var isArray = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e4) {
        return false;
      }
    }
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer2(arg, offset, length2) {
      if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
        return new Buffer2(arg, offset, length2);
      }
      if (typeof arg === "number") {
        return allocUnsafe2(this, arg);
      }
      return from3(this, arg, offset, length2);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
        Object.defineProperty(Buffer2, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function isnan(val) {
      return val !== val;
    }
    function createBuffer(that, length2) {
      var buf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length2);
        buf.__proto__ = Buffer2.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer2(length2);
        }
        buf.length = length2;
      }
      return buf;
    }
    function allocUnsafe2(that, size) {
      var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT) {
        for (var i5 = 0; i5 < size; ++i5) {
          buf[i5] = 0;
        }
      }
      return buf;
    }
    function fromString3(that, string2) {
      var length2 = byteLength(string2) | 0;
      var buf = createBuffer(that, length2);
      var actual = buf.write(string2);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(that, array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(that, length2);
      for (var i5 = 0; i5 < length2; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(that, array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer2.prototype;
      } else {
        buf = fromArrayLike(that, buf);
      }
      return buf;
    }
    function fromObject(that, obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string2.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length2; ++i5) {
        codePoint = string2.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength(string2) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        string2 = "" + string2;
      }
      var len = string2.length;
      if (len === 0)
        return 0;
      return utf8ToBytes(string2).length;
    }
    function blitBuffer(src2, dst, offset, length2) {
      for (var i5 = 0; i5 < length2; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src2.length)
          break;
        dst[i5 + offset] = src2[i5];
      }
      return i5;
    }
    function utf8Write(buf, string2, offset, length2) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
    }
    function from3(that, value, offset, length2) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, offset, length2);
      }
      if (typeof value === "string") {
        return fromString3(that, value, offset);
      }
      return fromObject(that, value);
    }
    Buffer2.prototype.write = function write(string2, offset, length2) {
      if (offset === void 0) {
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length2)) {
          length2 = length2 | 0;
        } else {
          length2 = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write(this, string2, offset, length2);
    };
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i5 = 0; i5 < sliceLen; ++i5) {
          newBuf[i5] = this[i5 + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i5;
      if (this === target && start < targetStart && targetStart < end) {
        for (i5 = len - 1; i5 >= 0; --i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i5 = 0; i5 < len; ++i5) {
          target[i5 + targetStart] = this[i5 + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (code2 < 256) {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : new Buffer2(val);
        var len = bytes.length;
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    Buffer2.concat = function concat3(list, length2) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer(null, 0);
      }
      var i5;
      if (length2 === void 0) {
        length2 = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length2 += list[i5].length;
        }
      }
      var buffer = allocUnsafe2(null, length2);
      var pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        var buf = list[i5];
        if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.isBuffer = function isBuffer(b4) {
      return !!(b4 != null && b4._isBuffer);
    };
    module.exports.alloc = function(size) {
      var buffer = new Buffer2(size);
      buffer.fill(0);
      return buffer;
    };
    module.exports.from = function(data) {
      return new Buffer2(data);
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version9) {
      if (!version9)
        throw new Error('"version" cannot be null or undefined');
      if (version9 < 1 || version9 > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version9 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version9) {
      return CODEWORDS_COUNT[version9];
    };
    exports.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f5) {
      if (typeof f5 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f5;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e4) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length2) {
        for (var i5 = 0; i5 < length2; i5++) {
          this.putBit((num >>> length2 - i5 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version9) {
      if (version9 === 1)
        return [];
      var posCount = Math.floor(version9 / 7) + 2;
      var size = getSymbolSize(version9);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i5 = 1; i5 < posCount - 1; i5++) {
        positions[i5] = positions[i5 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version9) {
      var coords = [];
      var pos = exports.getRowColCoords(version9);
      var posLength = pos.length;
      for (var i5 = 0; i5 < posLength; i5++) {
        for (var j6 = 0; j6 < posLength; j6++) {
          if (i5 === 0 && j6 === 0 || // top-left
          i5 === 0 && j6 === posLength - 1 || // bottom-left
          i5 === posLength - 1 && j6 === 0) {
            continue;
          }
          coords.push([pos[i5], pos[j6]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version9) {
      var size = getSymbolSize(version9);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from3(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i5 = 0; i5 < modulesCount; i5++)
        darkCount += data.data[i5];
      var k7 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k7 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i5, j6) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i5 + j6) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i5 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j6 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i5 + j6) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i5 / 2) + Math.floor(j6 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i5 * j6 % 2 + i5 * j6 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i5 * j6 % 2 + i5 * j6 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i5 * j6 % 3 + (i5 + j6) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p5 = 0; p5 < numPatterns; p5++) {
        setupFormatFunc(p5);
        exports.applyMask(p5, data);
        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p5, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p5;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version9, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version9 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version9 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version9 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version9 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version9, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version9 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version9 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version9 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version9 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x9 = 1;
      for (var i5 = 0; i5 < 255; i5++) {
        EXP_TABLE[i5] = x9;
        LOG_TABLE[x9] = i5;
        x9 <<= 1;
        if (x9 & 256) {
          x9 ^= 285;
        }
      }
      for (i5 = 255; i5 < 512; i5++) {
        EXP_TABLE[i5] = EXP_TABLE[i5 - 255];
      }
    })();
    exports.log = function log(n6) {
      if (n6 < 1)
        throw new Error("log(" + n6 + ")");
      return LOG_TABLE[n6];
    };
    exports.exp = function exp(n6) {
      return EXP_TABLE[n6];
    };
    exports.mul = function mul3(x9, y7) {
      if (x9 === 0 || y7 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x9] + LOG_TABLE[y7]];
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports.mul = function mul3(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i5 = 0; i5 < p1.length; i5++) {
        for (var j6 = 0; j6 < p22.length; j6++) {
          coeff[i5 + j6] ^= GF.mul(p1[i5], p22[j6]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i5 = 0; i5 < divisor.length; i5++) {
          result[i5] ^= GF.mul(divisor[i5], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i5 = 0; i5 < degree; i5++) {
        poly = exports.mul(poly, [1, GF.exp(i5)]);
      }
      return poly;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer2 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode6(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad = BufferUtil.alloc(this.degree);
      var paddedData = Buffer2.concat([data, pad], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version9) {
      return !isNaN(version9) && version9 >= 1 && version9 <= 40;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version9) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version9)) {
        throw new Error("Invalid version: " + version9);
      }
      if (version9 >= 1 && version9 < 10)
        return mode.ccBits[0];
      else if (version9 < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e4) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version9) {
      return Mode.getCharCountIndicator(mode, version9) + 4;
    }
    function getTotalBitsFromDataArray(segments, version9) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version9);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from3(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version9, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version9)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version9);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version9, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version9);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version9) {
      if (!VersionCheck.isValid(version9) || version9 < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d6 = version9 << 12;
      while (Utils.getBCHDigit(d6) - G18_BCH >= 0) {
        d6 ^= G18 << Utils.getBCHDigit(d6) - G18_BCH;
      }
      return version9 << 12 | d6;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d6 = data << 10;
      while (Utils.getBCHDigit(d6) - G15_BCH >= 0) {
        d6 ^= G15 << Utils.getBCHDigit(d6) - G15_BCH;
      }
      return (data << 10 | d6) ^ G15_MASK;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i5, group, value;
      for (i5 = 0; i5 + 3 <= this.data.length; i5 += 3) {
        group = this.data.substr(i5, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i5;
      if (remainingNum > 0) {
        group = this.data.substr(i5);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i5;
      for (i5 = 0; i5 + 2 <= this.data.length; i5 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i5]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i5 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i5]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i5 = 0, l6 = this.data.length; i5 < l6; i5++) {
        bitBuffer.put(this.data[i5], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength2() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i5;
      for (i5 = 0; i5 < this.data.length; i5++) {
        var value = Utils.toSJIS(this.data[i5]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i5] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i5 = 0; i5 < segs.length; i5++) {
        var seg = segs[i5];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version9) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i5 = 0; i5 < nodes.length; i5++) {
        var nodeGroup = nodes[i5];
        var currentNodeIds = [];
        for (var j6 = 0; j6 < nodeGroup.length; j6++) {
          var node = nodeGroup[j6];
          var key2 = "" + i5 + j6;
          currentNodeIds.push(key2);
          table[key2] = { node, lastCount: 0 };
          graph[key2] = {};
          for (var n6 = 0; n6 < prevNodeIds.length; n6++) {
            var prevNodeId = prevNodeIds[n6];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version9);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n6 = 0; n6 < prevNodeIds.length; n6++) {
        graph[prevNodeIds[n6]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString3(data, version9) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version9);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i5 = 1; i5 < path.length - 1; i5++) {
        optimizedSegs.push(graph.table[path[i5]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray = require_isarray();
    function setupFinderPattern(matrix, version9) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version9);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r5 = -1; r5 <= 7; r5++) {
          if (row + r5 <= -1 || size <= row + r5)
            continue;
          for (var c5 = -1; c5 <= 7; c5++) {
            if (col + c5 <= -1 || size <= col + c5)
              continue;
            if (r5 >= 0 && r5 <= 6 && (c5 === 0 || c5 === 6) || c5 >= 0 && c5 <= 6 && (r5 === 0 || r5 === 6) || r5 >= 2 && r5 <= 4 && c5 >= 2 && c5 <= 4) {
              matrix.set(row + r5, col + c5, true, true);
            } else {
              matrix.set(row + r5, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r5 = 8; r5 < size - 8; r5++) {
        var value = r5 % 2 === 0;
        matrix.set(r5, 6, value, true);
        matrix.set(6, r5, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version9) {
      var pos = AlignmentPattern.getPositions(version9);
      for (var i5 = 0; i5 < pos.length; i5++) {
        var row = pos[i5][0];
        var col = pos[i5][1];
        for (var r5 = -2; r5 <= 2; r5++) {
          for (var c5 = -2; c5 <= 2; c5++) {
            if (r5 === -2 || r5 === 2 || c5 === -2 || c5 === 2 || r5 === 0 && c5 === 0) {
              matrix.set(row + r5, col + c5, true, true);
            } else {
              matrix.set(row + r5, col + c5, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version9) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version9);
      var row, col, mod;
      for (var i5 = 0; i5 < 18; i5++) {
        row = Math.floor(i5 / 3);
        col = i5 % 3 + size - 8 - 3;
        mod = (bits >> i5 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i5, mod;
      for (i5 = 0; i5 < 15; i5++) {
        mod = (bits >> i5 & 1) === 1;
        if (i5 < 6) {
          matrix.set(i5, 8, mod, true);
        } else if (i5 < 8) {
          matrix.set(i5 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i5, 8, mod, true);
        }
        if (i5 < 8) {
          matrix.set(8, size - i5 - 1, mod, true);
        } else if (i5 < 9) {
          matrix.set(8, 15 - i5 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i5 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (!matrix.isReserved(row, col - c5)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c5, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version9, errorCorrectionLevel, segments) {
      var buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version9));
        data.write(buffer);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version9);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version9, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (var i5 = 0; i5 < remainingByte; i5++) {
        buffer.put(i5 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version9, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version9, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version9);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version9, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version9, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs2 = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer = BufferUtil.from(bitBuffer.buffer);
      for (var b4 = 0; b4 < ecTotalBlocks; b4++) {
        var dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer.slice(offset, offset + dataSize);
        ecData[b4] = rs2.encode(dcData[b4]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i5, r5;
      for (i5 = 0; i5 < maxDataSize; i5++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          if (i5 < dcData[r5].length) {
            data[index++] = dcData[r5][i5];
          }
        }
      }
      for (i5 = 0; i5 < ecCount; i5++) {
        for (r5 = 0; r5 < ecTotalBlocks; r5++) {
          data[index++] = ecData[r5][i5];
        }
      }
      return data;
    }
    function createSymbol(data, version9, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version9;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(
            rawSegments,
            errorCorrectionLevel
          );
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(
        segments,
        errorCorrectionLevel
      );
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version9) {
        version9 = bestVersion;
      } else if (version9 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      var dataBits = createData(version9, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version9);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version9);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version9);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version9 >= 7) {
        setupVersionInfo(modules, version9);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version9,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create2(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version9;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version9 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version9, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c5) {
          return [c5, c5];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr3, opts) {
      var size = qr3.modules.size;
      var data = qr3.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i5 = 0; i5 < symbolSize; i5++) {
        for (var j6 = 0; j6 < symbolSize; j6++) {
          var posDst = (i5 * symbolSize + j6) * 4;
          var pxColor = opts.color.light;
          if (i5 >= scaledMargin && j6 >= scaledMargin && i5 < symbolSize - scaledMargin && j6 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i5 - scaledMargin) / scale);
            var jSrc = Math.floor((j6 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e4) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x9, y7) {
      var str = cmd + x9;
      if (typeof y7 !== "undefined")
        str += " " + y7;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i5 = 0; i5 < data.length; i5++) {
        var col = Math.floor(i5 % size);
        var row = Math.floor(i5 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i5]) {
          lineLength++;
          if (!(i5 > 0 && col > 0 && data[i5 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i5 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/qrcode@1.4.4/node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e4) {
            reject(e4);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e4) {
        cb(e4);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _7, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/.pnpm/toggle-selection@1.0.6/node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i5 = 0; i5 < selection.rangeCount; i5++) {
        ranges.push(selection.getRangeAt(i5));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/.pnpm/copy-to-clipboard@3.3.3/node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e4) {
          e4.stopPropagation();
          if (options.format) {
            e4.preventDefault();
            if (typeof e4.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e4.clipboardData.clearData();
              e4.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e4.preventDefault();
            options.onCopy(e4.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/.pnpm/preact@10.4.1/node_modules/preact/dist/preact.module.js
function a(n6, l6) {
  for (var u4 in l6)
    n6[u4] = l6[u4];
  return n6;
}
function v(n6) {
  var l6 = n6.parentNode;
  l6 && l6.removeChild(n6);
}
function h(n6, l6, u4) {
  var i5, t3 = arguments, r5 = {};
  for (i5 in l6)
    "key" !== i5 && "ref" !== i5 && (r5[i5] = l6[i5]);
  if (arguments.length > 3)
    for (u4 = [u4], i5 = 3; i5 < arguments.length; i5++)
      u4.push(t3[i5]);
  if (null != u4 && (r5.children = u4), "function" == typeof n6 && null != n6.defaultProps)
    for (i5 in n6.defaultProps)
      void 0 === r5[i5] && (r5[i5] = n6.defaultProps[i5]);
  return p(n6, r5, l6 && l6.key, l6 && l6.ref, null);
}
function p(l6, u4, i5, t3, r5) {
  var o6 = { type: l6, props: u4, key: i5, ref: t3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r5 };
  return null == r5 && (o6.__v = o6), n.vnode && n.vnode(o6), o6;
}
function y2() {
  return {};
}
function d(n6) {
  return n6.children;
}
function m(n6, l6) {
  this.props = n6, this.context = l6;
}
function w(n6, l6) {
  if (null == l6)
    return n6.__ ? w(n6.__, n6.__.__k.indexOf(n6) + 1) : null;
  for (var u4; l6 < n6.__k.length; l6++)
    if (null != (u4 = n6.__k[l6]) && null != u4.__e)
      return u4.__e;
  return "function" == typeof n6.type ? w(n6) : null;
}
function k(n6) {
  var l6, u4;
  if (null != (n6 = n6.__) && null != n6.__c) {
    for (n6.__e = n6.__c.base = null, l6 = 0; l6 < n6.__k.length; l6++)
      if (null != (u4 = n6.__k[l6]) && null != u4.__e) {
        n6.__e = n6.__c.base = u4.__e;
        break;
      }
    return k(n6);
  }
}
function g(l6) {
  (!l6.__d && (l6.__d = true) && u.push(l6) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);
}
function _() {
  for (var n6; i = u.length; )
    n6 = u.sort(function(n7, l6) {
      return n7.__v.__b - l6.__v.__b;
    }), u = [], n6.some(function(n7) {
      var l6, u4, i5, t3, r5, o6, f5;
      n7.__d && (o6 = (r5 = (l6 = n7).__v).__e, (f5 = l6.__P) && (u4 = [], (i5 = a({}, r5)).__v = i5, t3 = A(f5, r5, i5, l6.__n, void 0 !== f5.ownerSVGElement, null, u4, null == o6 ? w(r5) : o6), T(u4, r5), t3 != o6 && k(r5)));
    });
}
function b(n6, l6, u4, i5, t3, r5, o6, f5, s5) {
  var a4, h7, p5, y7, d6, m4, k7, g6 = u4 && u4.__k || c, _7 = g6.length;
  if (f5 == e && (f5 = null != r5 ? r5[0] : _7 ? w(u4, 0) : null), a4 = 0, l6.__k = x(l6.__k, function(u5) {
    if (null != u5) {
      if (u5.__ = l6, u5.__b = l6.__b + 1, null === (p5 = g6[a4]) || p5 && u5.key == p5.key && u5.type === p5.type)
        g6[a4] = void 0;
      else
        for (h7 = 0; h7 < _7; h7++) {
          if ((p5 = g6[h7]) && u5.key == p5.key && u5.type === p5.type) {
            g6[h7] = void 0;
            break;
          }
          p5 = null;
        }
      if (y7 = A(n6, u5, p5 = p5 || e, i5, t3, r5, o6, f5, s5), (h7 = u5.ref) && p5.ref != h7 && (k7 || (k7 = []), p5.ref && k7.push(p5.ref, null, u5), k7.push(h7, u5.__c || y7, u5)), null != y7) {
        var c5;
        if (null == m4 && (m4 = y7), void 0 !== u5.__d)
          c5 = u5.__d, u5.__d = void 0;
        else if (r5 == p5 || y7 != f5 || null == y7.parentNode) {
          n:
            if (null == f5 || f5.parentNode !== n6)
              n6.appendChild(y7), c5 = null;
            else {
              for (d6 = f5, h7 = 0; (d6 = d6.nextSibling) && h7 < _7; h7 += 2)
                if (d6 == y7)
                  break n;
              n6.insertBefore(y7, f5), c5 = f5;
            }
          "option" == l6.type && (n6.value = "");
        }
        f5 = void 0 !== c5 ? c5 : y7.nextSibling, "function" == typeof l6.type && (l6.__d = f5);
      } else
        f5 && p5.__e == f5 && f5.parentNode != n6 && (f5 = w(p5));
    }
    return a4++, u5;
  }), l6.__e = m4, null != r5 && "function" != typeof l6.type)
    for (a4 = r5.length; a4--; )
      null != r5[a4] && v(r5[a4]);
  for (a4 = _7; a4--; )
    null != g6[a4] && D(g6[a4], g6[a4]);
  if (k7)
    for (a4 = 0; a4 < k7.length; a4++)
      j(k7[a4], k7[++a4], k7[++a4]);
}
function x(n6, l6, u4) {
  if (null == u4 && (u4 = []), null == n6 || "boolean" == typeof n6)
    l6 && u4.push(l6(null));
  else if (Array.isArray(n6))
    for (var i5 = 0; i5 < n6.length; i5++)
      x(n6[i5], l6, u4);
  else
    u4.push(l6 ? l6("string" == typeof n6 || "number" == typeof n6 ? p(null, n6, null, null, n6) : null != n6.__e || null != n6.__c ? p(n6.type, n6.props, n6.key, null, n6.__v) : n6) : n6);
  return u4;
}
function P(n6, l6, u4, i5, t3) {
  var r5;
  for (r5 in u4)
    "children" === r5 || "key" === r5 || r5 in l6 || N(n6, r5, null, u4[r5], i5);
  for (r5 in l6)
    t3 && "function" != typeof l6[r5] || "children" === r5 || "key" === r5 || "value" === r5 || "checked" === r5 || u4[r5] === l6[r5] || N(n6, r5, l6[r5], u4[r5], i5);
}
function C(n6, l6, u4) {
  "-" === l6[0] ? n6.setProperty(l6, u4) : n6[l6] = "number" == typeof u4 && false === s.test(l6) ? u4 + "px" : null == u4 ? "" : u4;
}
function N(n6, l6, u4, i5, t3) {
  var r5, o6, f5, e4, c5;
  if (t3 ? "className" === l6 && (l6 = "class") : "class" === l6 && (l6 = "className"), "style" === l6) {
    if (r5 = n6.style, "string" == typeof u4)
      r5.cssText = u4;
    else {
      if ("string" == typeof i5 && (r5.cssText = "", i5 = null), i5)
        for (e4 in i5)
          u4 && e4 in u4 || C(r5, e4, "");
      if (u4)
        for (c5 in u4)
          i5 && u4[c5] === i5[c5] || C(r5, c5, u4[c5]);
    }
  } else
    "o" === l6[0] && "n" === l6[1] ? (o6 = l6 !== (l6 = l6.replace(/Capture$/, "")), f5 = l6.toLowerCase(), l6 = (f5 in n6 ? f5 : l6).slice(2), u4 ? (i5 || n6.addEventListener(l6, z, o6), (n6.l || (n6.l = {}))[l6] = u4) : n6.removeEventListener(l6, z, o6)) : "list" !== l6 && "tagName" !== l6 && "form" !== l6 && "type" !== l6 && "size" !== l6 && !t3 && l6 in n6 ? n6[l6] = null == u4 ? "" : u4 : "function" != typeof u4 && "dangerouslySetInnerHTML" !== l6 && (l6 !== (l6 = l6.replace(/^xlink:?/, "")) ? null == u4 || false === u4 ? n6.removeAttributeNS("http://www.w3.org/1999/xlink", l6.toLowerCase()) : n6.setAttributeNS("http://www.w3.org/1999/xlink", l6.toLowerCase(), u4) : null == u4 || false === u4 && !/^ar/.test(l6) ? n6.removeAttribute(l6) : n6.setAttribute(l6, u4));
}
function z(l6) {
  this.l[l6.type](n.event ? n.event(l6) : l6);
}
function A(l6, u4, i5, t3, r5, o6, f5, e4, c5) {
  var s5, v8, h7, p5, y7, w6, k7, g6, _7, x9, P4 = u4.type;
  if (void 0 !== u4.constructor)
    return null;
  (s5 = n.__b) && s5(u4);
  try {
    n:
      if ("function" == typeof P4) {
        if (g6 = u4.props, _7 = (s5 = P4.contextType) && t3[s5.__c], x9 = s5 ? _7 ? _7.props.value : s5.__ : t3, i5.__c ? k7 = (v8 = u4.__c = i5.__c).__ = v8.__E : ("prototype" in P4 && P4.prototype.render ? u4.__c = v8 = new P4(g6, x9) : (u4.__c = v8 = new m(g6, x9), v8.constructor = P4, v8.render = E), _7 && _7.sub(v8), v8.props = g6, v8.state || (v8.state = {}), v8.context = x9, v8.__n = t3, h7 = v8.__d = true, v8.__h = []), null == v8.__s && (v8.__s = v8.state), null != P4.getDerivedStateFromProps && (v8.__s == v8.state && (v8.__s = a({}, v8.__s)), a(v8.__s, P4.getDerivedStateFromProps(g6, v8.__s))), p5 = v8.props, y7 = v8.state, h7)
          null == P4.getDerivedStateFromProps && null != v8.componentWillMount && v8.componentWillMount(), null != v8.componentDidMount && v8.__h.push(v8.componentDidMount);
        else {
          if (null == P4.getDerivedStateFromProps && g6 !== p5 && null != v8.componentWillReceiveProps && v8.componentWillReceiveProps(g6, x9), !v8.__e && null != v8.shouldComponentUpdate && false === v8.shouldComponentUpdate(g6, v8.__s, x9) || u4.__v === i5.__v && !v8.__) {
            for (v8.props = g6, v8.state = v8.__s, u4.__v !== i5.__v && (v8.__d = false), v8.__v = u4, u4.__e = i5.__e, u4.__k = i5.__k, v8.__h.length && f5.push(v8), s5 = 0; s5 < u4.__k.length; s5++)
              u4.__k[s5] && (u4.__k[s5].__ = u4);
            break n;
          }
          null != v8.componentWillUpdate && v8.componentWillUpdate(g6, v8.__s, x9), null != v8.componentDidUpdate && v8.__h.push(function() {
            v8.componentDidUpdate(p5, y7, w6);
          });
        }
        v8.context = x9, v8.props = g6, v8.state = v8.__s, (s5 = n.__r) && s5(u4), v8.__d = false, v8.__v = u4, v8.__P = l6, s5 = v8.render(v8.props, v8.state, v8.context), u4.__k = null != s5 && s5.type == d && null == s5.key ? s5.props.children : Array.isArray(s5) ? s5 : [s5], null != v8.getChildContext && (t3 = a(a({}, t3), v8.getChildContext())), h7 || null == v8.getSnapshotBeforeUpdate || (w6 = v8.getSnapshotBeforeUpdate(p5, y7)), b(l6, u4, i5, t3, r5, o6, f5, e4, c5), v8.base = u4.__e, v8.__h.length && f5.push(v8), k7 && (v8.__E = v8.__ = null), v8.__e = false;
      } else
        null == o6 && u4.__v === i5.__v ? (u4.__k = i5.__k, u4.__e = i5.__e) : u4.__e = $(i5.__e, u4, i5, t3, r5, o6, f5, c5);
    (s5 = n.diffed) && s5(u4);
  } catch (l7) {
    u4.__v = null, n.__e(l7, u4, i5);
  }
  return u4.__e;
}
function T(l6, u4) {
  n.__c && n.__c(u4, l6), l6.some(function(u5) {
    try {
      l6 = u5.__h, u5.__h = [], l6.some(function(n6) {
        n6.call(u5);
      });
    } catch (l7) {
      n.__e(l7, u5.__v);
    }
  });
}
function $(n6, l6, u4, i5, t3, r5, o6, f5) {
  var s5, a4, v8, h7, p5, y7 = u4.props, d6 = l6.props;
  if (t3 = "svg" === l6.type || t3, null != r5) {
    for (s5 = 0; s5 < r5.length; s5++)
      if (null != (a4 = r5[s5]) && ((null === l6.type ? 3 === a4.nodeType : a4.localName === l6.type) || n6 == a4)) {
        n6 = a4, r5[s5] = null;
        break;
      }
  }
  if (null == n6) {
    if (null === l6.type)
      return document.createTextNode(d6);
    n6 = t3 ? document.createElementNS("http://www.w3.org/2000/svg", l6.type) : document.createElement(l6.type, d6.is && { is: d6.is }), r5 = null, f5 = false;
  }
  if (null === l6.type)
    y7 !== d6 && n6.data != d6 && (n6.data = d6);
  else {
    if (null != r5 && (r5 = c.slice.call(n6.childNodes)), v8 = (y7 = u4.props || e).dangerouslySetInnerHTML, h7 = d6.dangerouslySetInnerHTML, !f5) {
      if (y7 === e)
        for (y7 = {}, p5 = 0; p5 < n6.attributes.length; p5++)
          y7[n6.attributes[p5].name] = n6.attributes[p5].value;
      (h7 || v8) && (h7 && v8 && h7.__html == v8.__html || (n6.innerHTML = h7 && h7.__html || ""));
    }
    P(n6, d6, y7, t3, f5), h7 ? l6.__k = [] : (l6.__k = l6.props.children, b(n6, l6, u4, i5, "foreignObject" !== l6.type && t3, r5, o6, e, f5)), f5 || ("value" in d6 && void 0 !== (s5 = d6.value) && s5 !== n6.value && N(n6, "value", s5, y7.value, false), "checked" in d6 && void 0 !== (s5 = d6.checked) && s5 !== n6.checked && N(n6, "checked", s5, y7.checked, false));
  }
  return n6;
}
function j(l6, u4, i5) {
  try {
    "function" == typeof l6 ? l6(u4) : l6.current = u4;
  } catch (l7) {
    n.__e(l7, i5);
  }
}
function D(l6, u4, i5) {
  var t3, r5, o6;
  if (n.unmount && n.unmount(l6), (t3 = l6.ref) && (t3.current && t3.current !== l6.__e || j(t3, null, u4)), i5 || "function" == typeof l6.type || (i5 = null != (r5 = l6.__e)), l6.__e = l6.__d = void 0, null != (t3 = l6.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (l7) {
        n.__e(l7, u4);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = l6.__k)
    for (o6 = 0; o6 < t3.length; o6++)
      t3[o6] && D(t3[o6], u4, i5);
  null != r5 && v(r5);
}
function E(n6, l6, u4) {
  return this.constructor(n6, u4);
}
function H(l6, u4, i5) {
  var t3, r5, f5;
  n.__ && n.__(l6, u4), r5 = (t3 = i5 === o) ? null : i5 && i5.__k || u4.__k, l6 = h(d, null, [l6]), f5 = [], A(u4, (t3 ? u4 : i5 || u4).__k = l6, r5 || e, e, void 0 !== u4.ownerSVGElement, i5 && !t3 ? [i5] : r5 ? null : c.slice.call(u4.childNodes), f5, i5 || e, t3), T(f5, l6);
}
function I(n6, l6) {
  H(n6, l6, o);
}
function L(n6, l6) {
  var u4, i5;
  for (i5 in l6 = a(a({}, n6.props), l6), arguments.length > 2 && (l6.children = c.slice.call(arguments, 2)), u4 = {}, l6)
    "key" !== i5 && "ref" !== i5 && (u4[i5] = l6[i5]);
  return p(n6.type, u4, l6.key || n6.key, l6.ref || n6.ref, null);
}
function M(n6) {
  var l6 = {}, u4 = { __c: "__cC" + f++, __: n6, Consumer: function(n7, l7) {
    return n7.children(l7);
  }, Provider: function(n7) {
    var i5, t3 = this;
    return this.getChildContext || (i5 = [], this.getChildContext = function() {
      return l6[u4.__c] = t3, l6;
    }, this.shouldComponentUpdate = function(n8) {
      t3.props.value !== n8.value && i5.some(function(l7) {
        l7.context = n8.value, g(l7);
      });
    }, this.sub = function(n8) {
      i5.push(n8);
      var l7 = n8.componentWillUnmount;
      n8.componentWillUnmount = function() {
        i5.splice(i5.indexOf(n8), 1), l7 && l7.call(n8);
      };
    }), n7.children;
  } };
  return u4.Consumer.contextType = u4, u4.Provider.__ = u4, u4;
}
var n, l, u, i, t, r, o, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/.pnpm/preact@10.4.1/node_modules/preact/dist/preact.module.js"() {
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    n = { __e: function(n6, l6) {
      for (var u4, i5; l6 = l6.__; )
        if ((u4 = l6.__c) && !u4.__)
          try {
            if (u4.constructor && null != u4.constructor.getDerivedStateFromError && (i5 = true, u4.setState(u4.constructor.getDerivedStateFromError(n6))), null != u4.componentDidCatch && (i5 = true, u4.componentDidCatch(n6)), i5)
              return g(u4.__E = u4);
          } catch (l7) {
            n6 = l7;
          }
      throw n6;
    } }, l = function(n6) {
      return null != n6 && void 0 === n6.constructor;
    }, m.prototype.setState = function(n6, l6) {
      var u4;
      u4 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n6 && (n6 = n6(u4, this.props)), n6 && a(u4, n6), null != n6 && this.__v && (l6 && this.__h.push(l6), g(this));
    }, m.prototype.forceUpdate = function(n6) {
      this.__v && (this.__e = true, n6 && this.__h.push(n6), g(this));
    }, m.prototype.render = d, u = [], i = 0, t = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;
  }
});

// node_modules/.pnpm/preact@10.4.1/node_modules/preact/hooks/dist/hooks.module.js
function v2(t3, r5) {
  n.__h && n.__h(u2, t3, i2 || r5), i2 = 0;
  var o6 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t3 >= o6.__.length && o6.__.push({}), o6.__[t3];
}
function m2(n6) {
  return i2 = 1, p2(E2, n6);
}
function p2(n6, r5, i5) {
  var o6 = v2(t2++, 2);
  return o6.__c || (o6.__c = u2, o6.__ = [i5 ? i5(r5) : E2(void 0, r5), function(t3) {
    var u4 = n6(o6.__[0], t3);
    o6.__[0] !== u4 && (o6.__[0] = u4, o6.__c.setState({}));
  }]), o6.__;
}
function l2(r5, i5) {
  var o6 = v2(t2++, 3);
  !n.__s && x2(o6.__H, i5) && (o6.__ = r5, o6.__H = i5, u2.__H.__h.push(o6));
}
function y3(r5, i5) {
  var o6 = v2(t2++, 4);
  !n.__s && x2(o6.__H, i5) && (o6.__ = r5, o6.__H = i5, u2.__h.push(o6));
}
function d2(n6) {
  return i2 = 5, h2(function() {
    return { current: n6 };
  }, []);
}
function s2(n6, t3, u4) {
  i2 = 6, y3(function() {
    "function" == typeof n6 ? n6(t3()) : n6 && (n6.current = t3());
  }, null == u4 ? u4 : u4.concat(n6));
}
function h2(n6, u4) {
  var r5 = v2(t2++, 7);
  return x2(r5.__H, u4) ? (r5.__H = u4, r5.__h = n6, r5.__ = n6()) : r5.__;
}
function T2(n6, t3) {
  return i2 = 8, h2(function() {
    return n6;
  }, t3);
}
function w2(n6) {
  var r5 = u2.context[n6.__c], i5 = v2(t2++, 9);
  return i5.__c = n6, r5 ? (null == i5.__ && (i5.__ = true, r5.sub(u2)), r5.props.value) : n6.__;
}
function A2(t3, u4) {
  n.useDebugValue && n.useDebugValue(u4 ? u4(t3) : t3);
}
function F(n6) {
  var r5 = v2(t2++, 10), i5 = m2();
  return r5.__ = n6, u2.componentDidCatch || (u2.componentDidCatch = function(n7) {
    r5.__ && r5.__(n7), i5[1](n7);
  }), [i5[0], function() {
    i5[1](void 0);
  }];
}
function _2() {
  o2.some(function(t3) {
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(q), t3.__H.__h = [];
      } catch (u4) {
        return t3.__H.__h = [], n.__e(u4, t3.__v), true;
      }
  }), o2 = [];
}
function g2(n6) {
  n6.t && n6.t();
}
function q(n6) {
  var t3 = n6.__();
  "function" == typeof t3 && (n6.t = t3);
}
function x2(n6, t3) {
  return !n6 || t3.some(function(t4, u4) {
    return t4 !== n6[u4];
  });
}
function E2(n6, t3) {
  return "function" == typeof t3 ? t3(n6) : t3;
}
var t2, u2, r2, i2, o2, c2, f2, e2, a2;
var init_hooks_module = __esm({
  "node_modules/.pnpm/preact@10.4.1/node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    i2 = 0;
    o2 = [];
    c2 = n.__r;
    f2 = n.diffed;
    e2 = n.__c;
    a2 = n.unmount;
    n.__r = function(n6) {
      c2 && c2(n6), t2 = 0, (u2 = n6.__c).__H && (u2.__H.__h.forEach(g2), u2.__H.__h.forEach(q), u2.__H.__h = []);
    }, n.diffed = function(t3) {
      f2 && f2(t3);
      var u4 = t3.__c;
      if (u4) {
        var i5 = u4.__H;
        i5 && i5.__h.length && (1 !== o2.push(u4) && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n6) {
          var t4, u5 = function() {
            clearTimeout(r5), cancelAnimationFrame(t4), setTimeout(n6);
          }, r5 = setTimeout(u5, 100);
          "undefined" != typeof window && (t4 = requestAnimationFrame(u5));
        })(_2));
      }
    }, n.__c = function(t3, u4) {
      u4.some(function(t4) {
        try {
          t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n6) {
            return !n6.__ || q(n6);
          });
        } catch (r5) {
          u4.some(function(n6) {
            n6.__h && (n6.__h = []);
          }), u4 = [], n.__e(r5, t4.__v);
        }
      }), e2 && e2(t3, u4);
    }, n.unmount = function(t3) {
      a2 && a2(t3);
      var u4 = t3.__c;
      if (u4) {
        var r5 = u4.__H;
        if (r5)
          try {
            r5.__.forEach(function(n6) {
              return n6.t && n6.t();
            });
          } catch (t4) {
            n.__e(t4, u4.__v);
          }
      }
    };
  }
});

// node_modules/.pnpm/preact@10.4.1/node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => R,
  Component: () => m,
  Fragment: () => d,
  PureComponent: () => C2,
  Suspense: () => U,
  SuspenseList: () => O,
  cloneElement: () => K,
  createContext: () => M,
  createElement: () => h,
  createFactory: () => G,
  createPortal: () => z2,
  createRef: () => y2,
  default: () => compat_module_default,
  findDOMNode: () => X,
  forwardRef: () => S,
  hydrate: () => V,
  isValidElement: () => J,
  lazy: () => L2,
  memo: () => _3,
  render: () => T3,
  unmountComponentAtNode: () => Q,
  unstable_batchedUpdates: () => Y,
  useCallback: () => T2,
  useContext: () => w2,
  useDebugValue: () => A2,
  useEffect: () => l2,
  useErrorBoundary: () => F,
  useImperativeHandle: () => s2,
  useLayoutEffect: () => y3,
  useMemo: () => h2,
  useReducer: () => p2,
  useRef: () => d2,
  useState: () => m2,
  version: () => B
});
function E3(n6, t3) {
  for (var e4 in t3)
    n6[e4] = t3[e4];
  return n6;
}
function w3(n6, t3) {
  for (var e4 in n6)
    if ("__source" !== e4 && !(e4 in t3))
      return true;
  for (var r5 in t3)
    if ("__source" !== r5 && n6[r5] !== t3[r5])
      return true;
  return false;
}
function _3(n6, t3) {
  function e4(n7) {
    var e5 = this.props.ref, r6 = e5 == n7.ref;
    return !r6 && e5 && (e5.call ? e5(null) : e5.current = null), t3 ? !t3(this.props, n7) || !r6 : w3(this.props, n7);
  }
  function r5(t4) {
    return this.shouldComponentUpdate = e4, h(n6, E3({}, t4));
  }
  return r5.prototype.isReactComponent = true, r5.displayName = "Memo(" + (n6.displayName || n6.name) + ")", r5.t = true, r5;
}
function S(n6) {
  function t3(t4) {
    var e4 = E3({}, t4);
    return delete e4.ref, n6(e4, t4.ref);
  }
  return t3.prototype.isReactComponent = t3.t = true, t3.displayName = "ForwardRef(" + (n6.displayName || n6.name) + ")", t3;
}
function N2(n6) {
  return n6 && ((n6 = E3({}, n6)).__c = null, n6.__k = n6.__k && n6.__k.map(N2)), n6;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M2(n6) {
  var t3 = n6.__.__c;
  return t3 && t3.u && t3.u(n6);
}
function L2(n6) {
  var t3, e4, r5;
  function o6(o7) {
    if (t3 || (t3 = n6()).then(function(n7) {
      e4 = n7.default || n7;
    }, function(n7) {
      r5 = n7;
    }), r5)
      throw r5;
    if (!e4)
      throw t3;
    return h(e4, o7);
  }
  return o6.displayName = "Lazy", o6.t = true, o6;
}
function O() {
  this.i = null, this.l = null;
}
function j2(n6) {
  var t3 = this, e4 = n6.container, r5 = h(W, { context: t3.context }, n6.vnode);
  return t3.s && t3.s !== e4 && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h), t3.p = false), n6.vnode ? t3.p ? (e4.__k = t3.__k, H(r5, e4), t3.__k = e4.__k) : (t3.v = document.createTextNode(""), I("", e4), e4.appendChild(t3.v), t3.p = true, t3.s = e4, H(r5, e4, t3.v), t3.__k = t3.v.__k) : t3.p && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h)), t3.h = r5, t3.componentWillUnmount = function() {
    t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h);
  }, null;
}
function z2(n6, t3) {
  return h(j2, { vnode: n6, container: t3 });
}
function T3(n6, t3, e4) {
  if (null == t3.__k)
    for (; t3.firstChild; )
      t3.removeChild(t3.firstChild);
  return H(n6, t3), "function" == typeof e4 && e4(), n6 ? n6.__c : null;
}
function V(n6, t3, e4) {
  return I(n6, t3), "function" == typeof e4 && e4(), n6 ? n6.__c : null;
}
function I2(n6, t3) {
  n6["UNSAFE_" + t3] && !n6[t3] && Object.defineProperty(n6, t3, { configurable: false, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n7) {
    this["UNSAFE_" + t3] = n7;
  } });
}
function G(n6) {
  return h.bind(null, n6);
}
function J(n6) {
  return !!n6 && n6.$$typeof === H2;
}
function K(n6) {
  return J(n6) ? L.apply(null, arguments) : n6;
}
function Q(n6) {
  return !!n6.__k && (H(null, n6), true);
}
function X(n6) {
  return n6 && (n6.base || 1 === n6.nodeType && n6) || null;
}
var C2, A3, k2, R, F2, P2, W, D2, H2, Z, $2, q2, B, Y, compat_module_default;
var init_compat_module = __esm({
  "node_modules/.pnpm/preact@10.4.1/node_modules/preact/compat/dist/compat.module.js"() {
    init_hooks_module();
    init_hooks_module();
    init_preact_module();
    init_preact_module();
    C2 = function(n6) {
      var t3, e4;
      function r5(t4) {
        var e5;
        return (e5 = n6.call(this, t4) || this).isPureReactComponent = true, e5;
      }
      return e4 = n6, (t3 = r5).prototype = Object.create(e4.prototype), t3.prototype.constructor = t3, t3.__proto__ = e4, r5.prototype.shouldComponentUpdate = function(n7, t4) {
        return w3(this.props, n7) || w3(this.state, t4);
      }, r5;
    }(m);
    A3 = n.__b;
    n.__b = function(n6) {
      n6.type && n6.type.t && n6.ref && (n6.props.ref = n6.ref, n6.ref = null), A3 && A3(n6);
    };
    k2 = function(n6, t3) {
      return n6 ? x(n6).reduce(function(n7, e4, r5) {
        return n7.concat(t3(e4, r5));
      }, []) : null;
    };
    R = { map: k2, forEach: k2, count: function(n6) {
      return n6 ? x(n6).length : 0;
    }, only: function(n6) {
      if (1 !== (n6 = x(n6)).length)
        throw new Error("Children.only() expects only one child.");
      return n6[0];
    }, toArray: x };
    F2 = n.__e;
    n.__e = function(n6, t3, e4) {
      if (n6.then) {
        for (var r5, o6 = t3; o6 = o6.__; )
          if ((r5 = o6.__c) && r5.__c)
            return r5.__c(n6, t3.__c);
      }
      F2(n6, t3, e4);
    }, (U.prototype = new m()).__c = function(n6, t3) {
      var e4 = this;
      null == e4.o && (e4.o = []), e4.o.push(t3);
      var r5 = M2(e4.__v), o6 = false, u4 = function() {
        o6 || (o6 = true, r5 ? r5(i5) : i5());
      };
      t3.__c = t3.componentWillUnmount, t3.componentWillUnmount = function() {
        u4(), t3.__c && t3.__c();
      };
      var i5 = function() {
        var n7;
        if (!--e4.__u)
          for (e4.__v.__k[0] = e4.state.u, e4.setState({ u: e4.__b = null }); n7 = e4.o.pop(); )
            n7.forceUpdate();
      };
      e4.__u++ || e4.setState({ u: e4.__b = e4.__v.__k[0] }), n6.then(u4, u4);
    }, U.prototype.render = function(n6, t3) {
      return this.__b && (this.__v.__k[0] = N2(this.__b), this.__b = null), [h(m, null, t3.u ? null : n6.children), t3.u && n6.fallback];
    };
    P2 = function(n6, t3, e4) {
      if (++e4[1] === e4[0] && n6.l.delete(t3), n6.props.revealOrder && ("t" !== n6.props.revealOrder[0] || !n6.l.size))
        for (e4 = n6.i; e4; ) {
          for (; e4.length > 3; )
            e4.pop()();
          if (e4[1] < e4[0])
            break;
          n6.i = e4 = e4[2];
        }
    };
    (O.prototype = new m()).u = function(n6) {
      var t3 = this, e4 = M2(t3.__v), r5 = t3.l.get(n6);
      return r5[0]++, function(o6) {
        var u4 = function() {
          t3.props.revealOrder ? (r5.push(o6), P2(t3, n6, r5)) : o6();
        };
        e4 ? e4(u4) : u4();
      };
    }, O.prototype.render = function(n6) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var t3 = x(n6.children);
      n6.revealOrder && "b" === n6.revealOrder[0] && t3.reverse();
      for (var e4 = t3.length; e4--; )
        this.l.set(t3[e4], this.i = [1, 0, this.i]);
      return n6.children;
    }, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
      var n6 = this;
      n6.l.forEach(function(t3, e4) {
        P2(n6, e4, t3);
      });
    };
    W = function() {
      function n6() {
      }
      var t3 = n6.prototype;
      return t3.getChildContext = function() {
        return this.props.context;
      }, t3.render = function(n7) {
        return n7.children;
      }, n6;
    }();
    D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    m.prototype.isReactComponent = {};
    H2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
    Z = n.event;
    n.event = function(n6) {
      Z && (n6 = Z(n6)), n6.persist = function() {
      };
      var t3 = false, e4 = false, r5 = n6.stopPropagation;
      n6.stopPropagation = function() {
        r5.call(n6), t3 = true;
      };
      var o6 = n6.preventDefault;
      return n6.preventDefault = function() {
        o6.call(n6), e4 = true;
      }, n6.isPropagationStopped = function() {
        return t3;
      }, n6.isDefaultPrevented = function() {
        return e4;
      }, n6.nativeEvent = n6;
    };
    $2 = { configurable: true, get: function() {
      return this.class;
    } };
    q2 = n.vnode;
    n.vnode = function(n6) {
      n6.$$typeof = H2;
      var t3 = n6.type, e4 = n6.props;
      if (t3) {
        if (e4.class != e4.className && ($2.enumerable = "className" in e4, null != e4.className && (e4.class = e4.className), Object.defineProperty(e4, "className", $2)), "function" != typeof t3) {
          var r5, o6, u4;
          for (u4 in e4.defaultValue && void 0 !== e4.value && (e4.value || 0 === e4.value || (e4.value = e4.defaultValue), delete e4.defaultValue), Array.isArray(e4.value) && e4.multiple && "select" === t3 && (x(e4.children).forEach(function(n7) {
            -1 != e4.value.indexOf(n7.props.value) && (n7.props.selected = true);
          }), delete e4.value), e4)
            if (r5 = D2.test(u4))
              break;
          if (r5)
            for (u4 in o6 = n6.props = {}, e4)
              o6[D2.test(u4) ? u4.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u4] = e4[u4];
        }
        !function(t4) {
          var e5 = n6.type, r6 = n6.props;
          if (r6 && "string" == typeof e5) {
            var o7 = {};
            for (var u5 in r6)
              /^on(Ani|Tra|Tou)/.test(u5) && (r6[u5.toLowerCase()] = r6[u5], delete r6[u5]), o7[u5.toLowerCase()] = u5;
            if (o7.ondoubleclick && (r6.ondblclick = r6[o7.ondoubleclick], delete r6[o7.ondoubleclick]), o7.onbeforeinput && (r6.onbeforeinput = r6[o7.onbeforeinput], delete r6[o7.onbeforeinput]), o7.onchange && ("textarea" === e5 || "input" === e5.toLowerCase() && !/^fil|che|ra/i.test(r6.type))) {
              var i5 = o7.oninput || "oninput";
              r6[i5] || (r6[i5] = r6[o7.onchange], delete r6[o7.onchange]);
            }
          }
        }(), "function" == typeof t3 && !t3.m && t3.prototype && (I2(t3.prototype, "componentWillMount"), I2(t3.prototype, "componentWillReceiveProps"), I2(t3.prototype, "componentWillUpdate"), t3.m = true);
      }
      q2 && q2(n6);
    };
    B = "16.8.0";
    Y = function(n6, t3) {
      return n6(t3);
    };
    compat_module_default = { useState: m2, useReducer: p2, useEffect: l2, useLayoutEffect: y3, useRef: d2, useImperativeHandle: s2, useMemo: h2, useCallback: T2, useContext: w2, useDebugValue: A2, version: "16.8.0", Children: R, render: T3, hydrate: T3, unmountComponentAtNode: Q, createPortal: z2, createElement: h, createContext: M, createFactory: G, cloneElement: K, createRef: y2, Fragment: d, isValidElement: J, findDOMNode: X, Component: m, PureComponent: C2, memo: _3, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L2 };
  }
});

// node_modules/.pnpm/@walletconnect+qrcode-modal@1.8.0/node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/.pnpm/@walletconnect+qrcode-modal@1.8.0/node_modules/@walletconnect/qrcode-modal/dist/cjs/index.js"(exports, module) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = (init_esm2(), __toCommonJS(esm_exports2));
    var QRCode = _interopDefault(require_browser());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React = (init_compat_module(), __toCommonJS(compat_module_exports));
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
    function _catch(body, recover) {
      try {
        var result = body();
      } catch (e4) {
        return recover(e4);
      }
      if (result && result.then) {
        return result.then(void 0, recover);
      }
      return result;
    }
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name2), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name2 = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name2));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_7, index2) {
        return index2 + 1 >= range[0] && index2 + 1 <= range[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e4) {
        setInput(e4.target.value);
        clearTimeout(filterTimeout);
        if (e4.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e4.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name2 = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: name2,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name: name2,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name2,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_7, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e4) {
        return Promise.reject(e4);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e4) {
          Promise.reject(e4);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification, {
        message: notification
      }));
    }
    function Modal(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              var _temp = _catch(function() {
                var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
                return Promise.resolve(fetch(url)).then(function(registryResponse) {
                  return Promise.resolve(registryResponse.json()).then(function(_registryResponse$jso) {
                    var registry = _registryResponse$jso.listings;
                    var platform = mobile ? "mobile" : "desktop";
                    var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                    setLoading(false);
                    setFetched(true);
                    setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                    setLinks(_links);
                    var hasSingleLink2 = _links.length === 1;
                    if (hasSingleLink2) {
                      setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                      setDisplayQRCode(true);
                    }
                    setHasSingleLink(hasSingleLink2);
                  });
                });
              }, function(e4) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e4);
              });
              return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
              }) : void 0);
            } catch (e4) {
              return Promise.reject(e4);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign(
        {},
        displayProps,
        {
          links,
          errorMessage
        }
      )))));
    }
    var de3 = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en4 = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr3 = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko3 = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt4 = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de: de3,
      en: en4,
      es,
      fr: fr3,
      ko: ko3,
      pt: pt4,
      zh,
      fa
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode3 = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode3()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode3())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module.exports = index;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports.delay = delay;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/.pnpm/@walletconnect+time@1.0.2/node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils3(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o6) {
      try {
        return JSON.stringify(o6);
      } catch (e4) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f5, args, opts) {
      var ss2 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f5 === "object" && f5 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f5;
        var objects = new Array(len);
        objects[0] = ss2(f5);
        for (var index = 1; index < len; index++) {
          objects[index] = ss2(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f5 !== "string") {
        return f5;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f5;
      var str = "";
      var a4 = 1 - offset;
      var lastPos = -1;
      var flen = f5 && f5.length || 0;
      for (var i5 = 0; i5 < flen; ) {
        if (f5.charCodeAt(i5) === 37 && i5 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f5.charCodeAt(i5 + 1)) {
            case 100:
            case 102:
              if (a4 >= argLen)
                break;
              if (args[a4] == null)
                break;
              if (lastPos < i5)
                str += f5.slice(lastPos, i5);
              str += Number(args[a4]);
              lastPos = i5 + 2;
              i5++;
              break;
            case 105:
              if (a4 >= argLen)
                break;
              if (args[a4] == null)
                break;
              if (lastPos < i5)
                str += f5.slice(lastPos, i5);
              str += Math.floor(Number(args[a4]));
              lastPos = i5 + 2;
              i5++;
              break;
            case 79:
            case 111:
            case 106:
              if (a4 >= argLen)
                break;
              if (args[a4] === void 0)
                break;
              if (lastPos < i5)
                str += f5.slice(lastPos, i5);
              var type = typeof args[a4];
              if (type === "string") {
                str += "'" + args[a4] + "'";
                lastPos = i5 + 2;
                i5++;
                break;
              }
              if (type === "function") {
                str += args[a4].name || "<anonymous>";
                lastPos = i5 + 2;
                i5++;
                break;
              }
              str += ss2(args[a4]);
              lastPos = i5 + 2;
              i5++;
              break;
            case 115:
              if (a4 >= argLen)
                break;
              if (lastPos < i5)
                str += f5.slice(lastPos, i5);
              str += String(args[a4]);
              lastPos = i5 + 2;
              i5++;
              break;
            case 37:
              if (lastPos < i5)
                str += f5.slice(lastPos, i5);
              str += "%";
              lastPos = i5 + 2;
              i5++;
              a4--;
              break;
          }
          ++a4;
        }
        ++i5;
      }
      if (lastPos === -1)
        return f5;
      else if (lastPos < flen) {
        str += f5.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/pino@7.11.0/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k7) {
          return k7 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger7 = Object.create(proto);
      if (!logger7.log)
        logger7.log = noop;
      Object.defineProperty(logger7, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger7, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger7.levels = pino.levels;
      logger7.level = level;
      logger7.setMaxListeners = logger7.getMaxListeners = logger7.emit = logger7.addListener = logger7.on = logger7.prependListener = logger7.once = logger7.prependOnceListener = logger7.removeListener = logger7.removeAllListeners = logger7.listeners = logger7.listenerCount = logger7.eventNames = logger7.write = logger7.flush = noop;
      logger7.serializers = serializers;
      logger7._serialize = serialize;
      logger7._stdErrSerialize = stdErrSerialize;
      logger7.child = child;
      if (transmit2)
        logger7._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger7, "error", "log");
        set2(setOpts, logger7, "fatal", "error");
        set2(setOpts, logger7, "warn", "error");
        set2(setOpts, logger7, "info", "log");
        set2(setOpts, logger7, "debug", "log");
        set2(setOpts, logger7, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger7;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger7, level, fallback) {
      const proto = Object.getPrototypeOf(logger7);
      logger7[level] = logger7.levelVal > logger7.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger7, level);
    }
    function wrap(opts, logger7, level) {
      if (!opts.transmit && logger7[level] === noop)
        return;
      logger7[level] = function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i5 = 0; i5 < args.length; i5++)
            args[i5] = arguments[i5];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts2));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger7.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger7.level],
              send: opts.transmit.send,
              val: logger7.levelVal
            }, args);
          }
        };
      }(logger7[level]);
    }
    function asObject(logger7, level, args, ts2) {
      if (logger7._serialize)
        applySerializers(args, logger7._serialize, logger7.serializers, logger7._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o6 = {};
      if (ts2) {
        o6.time = ts2;
      }
      o6.level = pino.levels.values[level];
      let lvl = (logger7._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o6, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o6.msg = msg;
      return o6;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i5 in args) {
        if (stdErrSerialize && args[i5] instanceof Error) {
          args[i5] = pino.stdSerializers.err(args[i5]);
        } else if (typeof args[i5] === "object" && !Array.isArray(args[i5])) {
          for (const k7 in args[i5]) {
            if (serialize && serialize.indexOf(k7) > -1 && k7 in serializers) {
              args[i5][k7] = serializers[k7](args[i5][k7]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i5 = 1; i5 < args.length; i5++) {
          args[i5] = arguments[i5 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger7, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger7._logEvent.bindings;
      applySerializers(
        args,
        logger7._serialize || Object.keys(logger7.serializers),
        logger7.serializers,
        logger7._stdErrSerialize === void 0 ? true : logger7._stdErrSerialize
      );
      logger7._logEvent.ts = ts2;
      logger7._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger7._logEvent.level.label = methodLevel;
      logger7._logEvent.level.value = methodValue;
      send(methodLevel, logger7._logEvent, val);
      logger7._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key2 in err) {
        if (obj[key2] === void 0) {
          obj[key2] = err[key2];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a4) {
      return a4;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o6) {
        return typeof o6 !== "undefined" && o6;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e4) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/.pnpm/@walletconnect+window-getters@1.0.1/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/.pnpm/@walletconnect+window-getters@1.0.1/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name2) {
      const res = getFromWindow3(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/.pnpm/@walletconnect+window-metadata@1.0.1/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/.pnpm/@walletconnect+window-metadata@1.0.1/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs5();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e4) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i5 = 0; i5 < links.length; i5++) {
          const link = links[i5];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i5 = 0; i5 < metaTags.length; i5++) {
          const tag = metaTags[i5];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/js-sha3@0.8.0/node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n6, s5) {
          return methods["cshake" + bits2].update(message, outputBits, n6, s5)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key2, message, outputBits, s5) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s5)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i6 = 0; i6 < OUTPUT_TYPES.length; ++i6) {
          var type = OUTPUT_TYPES[i6];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n6, s5) {
          if (!n6 && !s5) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n6, s5], w6);
          }
        };
        method.update = function(message, outputBits, n6, s5) {
          return method.create(outputBits, n6, s5).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w6 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key2, outputBits, s5) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s5], w6).bytepad([key2], w6);
        };
        method.update = function(key2, message, outputBits, s5) {
          return method.create(key2, outputBits, s5).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i5 = 0; i5 < algorithms.length; ++i5) {
        var algorithm = algorithms[i5];
        var bits = algorithm.bits;
        for (var j6 = 0; j6 < bits.length; ++j6) {
          var methodName = algorithm.name + "_" + bits[j6];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j6], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j6];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i6 = 0; i6 < 50; ++i6) {
          this.s[i6] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s5 = this.s, i6, code2;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i6 = 1; i6 < blockCount + 1; ++i6) {
              blocks[i6] = 0;
            }
          }
          if (notString) {
            for (i6 = this.start; index < length2 && i6 < byteCount; ++index) {
              blocks[i6 >> 2] |= message[index] << SHIFT[i6++ & 3];
            }
          } else {
            for (i6 = this.start; index < length2 && i6 < byteCount; ++index) {
              code2 = message.charCodeAt(index);
              if (code2 < 128) {
                blocks[i6 >> 2] |= code2 << SHIFT[i6++ & 3];
              } else if (code2 < 2048) {
                blocks[i6 >> 2] |= (192 | code2 >> 6) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 & 63) << SHIFT[i6++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i6 >> 2] |= (224 | code2 >> 12) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 & 63) << SHIFT[i6++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i6 >> 2] |= (240 | code2 >> 18) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i6++ & 3];
                blocks[i6 >> 2] |= (128 | code2 & 63) << SHIFT[i6++ & 3];
              }
            }
          }
          this.lastByteIndex = i6;
          if (i6 >= byteCount) {
            this.start = i6 - byteCount;
            this.block = blocks[blockCount];
            for (i6 = 0; i6 < blockCount; ++i6) {
              s5[i6] ^= blocks[i6];
            }
            f5(s5);
            this.reset = true;
          } else {
            this.start = i6;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x9, right) {
        var o6 = x9 & 255, n6 = 1;
        var bytes = [o6];
        x9 = x9 >> 8;
        o6 = x9 & 255;
        while (o6 > 0) {
          bytes.unshift(o6);
          x9 = x9 >> 8;
          o6 = x9 & 255;
          ++n6;
        }
        if (right) {
          bytes.push(n6);
        } else {
          bytes.unshift(n6);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i6 = 0; i6 < str.length; ++i6) {
            var code2 = str.charCodeAt(i6);
            if (code2 < 128) {
              bytes += 1;
            } else if (code2 < 2048) {
              bytes += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i6) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w6) {
        var bytes = this.encode(w6);
        for (var i6 = 0; i6 < strs.length; ++i6) {
          bytes += this.encodeString(strs[i6]);
        }
        var paddingBytes = w6 - bytes % w6;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i6 = this.lastByteIndex, blockCount = this.blockCount, s5 = this.s;
        blocks[i6 >> 2] |= this.padding[i6 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i6 = 1; i6 < blockCount + 1; ++i6) {
            blocks[i6] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i6 = 0; i6 < blockCount; ++i6) {
          s5[i6] ^= blocks[i6];
        }
        f5(s5);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j7 = 0;
        var hex = "", block;
        while (j7 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j7 < outputBlocks; ++i6, ++j7) {
            block = s5[i6];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j7 % blockCount === 0) {
            f5(s5);
            i6 = 0;
          }
        }
        if (extraBytes) {
          block = s5[i6];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j7 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j7 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j7 < outputBlocks; ++i6, ++j7) {
            array[j7] = s5[i6];
          }
          if (j7 % blockCount === 0) {
            f5(s5);
          }
        }
        if (extraBytes) {
          array[i6] = s5[i6];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s5 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i6 = 0, j7 = 0;
        var array = [], offset, block;
        while (j7 < outputBlocks) {
          for (i6 = 0; i6 < blockCount && j7 < outputBlocks; ++i6, ++j7) {
            offset = j7 << 2;
            block = s5[i6];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j7 % blockCount === 0) {
            f5(s5);
          }
        }
        if (extraBytes) {
          offset = j7 << 2;
          block = s5[i6];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f5 = function(s5) {
        var h7, l6, n6, c0, c1, c22, c32, c42, c5, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n6 = 0; n6 < 48; n6 += 2) {
          c0 = s5[0] ^ s5[10] ^ s5[20] ^ s5[30] ^ s5[40];
          c1 = s5[1] ^ s5[11] ^ s5[21] ^ s5[31] ^ s5[41];
          c22 = s5[2] ^ s5[12] ^ s5[22] ^ s5[32] ^ s5[42];
          c32 = s5[3] ^ s5[13] ^ s5[23] ^ s5[33] ^ s5[43];
          c42 = s5[4] ^ s5[14] ^ s5[24] ^ s5[34] ^ s5[44];
          c5 = s5[5] ^ s5[15] ^ s5[25] ^ s5[35] ^ s5[45];
          c6 = s5[6] ^ s5[16] ^ s5[26] ^ s5[36] ^ s5[46];
          c7 = s5[7] ^ s5[17] ^ s5[27] ^ s5[37] ^ s5[47];
          c8 = s5[8] ^ s5[18] ^ s5[28] ^ s5[38] ^ s5[48];
          c9 = s5[9] ^ s5[19] ^ s5[29] ^ s5[39] ^ s5[49];
          h7 = c8 ^ (c22 << 1 | c32 >>> 31);
          l6 = c9 ^ (c32 << 1 | c22 >>> 31);
          s5[0] ^= h7;
          s5[1] ^= l6;
          s5[10] ^= h7;
          s5[11] ^= l6;
          s5[20] ^= h7;
          s5[21] ^= l6;
          s5[30] ^= h7;
          s5[31] ^= l6;
          s5[40] ^= h7;
          s5[41] ^= l6;
          h7 = c0 ^ (c42 << 1 | c5 >>> 31);
          l6 = c1 ^ (c5 << 1 | c42 >>> 31);
          s5[2] ^= h7;
          s5[3] ^= l6;
          s5[12] ^= h7;
          s5[13] ^= l6;
          s5[22] ^= h7;
          s5[23] ^= l6;
          s5[32] ^= h7;
          s5[33] ^= l6;
          s5[42] ^= h7;
          s5[43] ^= l6;
          h7 = c22 ^ (c6 << 1 | c7 >>> 31);
          l6 = c32 ^ (c7 << 1 | c6 >>> 31);
          s5[4] ^= h7;
          s5[5] ^= l6;
          s5[14] ^= h7;
          s5[15] ^= l6;
          s5[24] ^= h7;
          s5[25] ^= l6;
          s5[34] ^= h7;
          s5[35] ^= l6;
          s5[44] ^= h7;
          s5[45] ^= l6;
          h7 = c42 ^ (c8 << 1 | c9 >>> 31);
          l6 = c5 ^ (c9 << 1 | c8 >>> 31);
          s5[6] ^= h7;
          s5[7] ^= l6;
          s5[16] ^= h7;
          s5[17] ^= l6;
          s5[26] ^= h7;
          s5[27] ^= l6;
          s5[36] ^= h7;
          s5[37] ^= l6;
          s5[46] ^= h7;
          s5[47] ^= l6;
          h7 = c6 ^ (c0 << 1 | c1 >>> 31);
          l6 = c7 ^ (c1 << 1 | c0 >>> 31);
          s5[8] ^= h7;
          s5[9] ^= l6;
          s5[18] ^= h7;
          s5[19] ^= l6;
          s5[28] ^= h7;
          s5[29] ^= l6;
          s5[38] ^= h7;
          s5[39] ^= l6;
          s5[48] ^= h7;
          s5[49] ^= l6;
          b0 = s5[0];
          b1 = s5[1];
          b322 = s5[11] << 4 | s5[10] >>> 28;
          b33 = s5[10] << 4 | s5[11] >>> 28;
          b14 = s5[20] << 3 | s5[21] >>> 29;
          b15 = s5[21] << 3 | s5[20] >>> 29;
          b46 = s5[31] << 9 | s5[30] >>> 23;
          b47 = s5[30] << 9 | s5[31] >>> 23;
          b28 = s5[40] << 18 | s5[41] >>> 14;
          b29 = s5[41] << 18 | s5[40] >>> 14;
          b20 = s5[2] << 1 | s5[3] >>> 31;
          b21 = s5[3] << 1 | s5[2] >>> 31;
          b22 = s5[13] << 12 | s5[12] >>> 20;
          b32 = s5[12] << 12 | s5[13] >>> 20;
          b34 = s5[22] << 10 | s5[23] >>> 22;
          b35 = s5[23] << 10 | s5[22] >>> 22;
          b16 = s5[33] << 13 | s5[32] >>> 19;
          b17 = s5[32] << 13 | s5[33] >>> 19;
          b48 = s5[42] << 2 | s5[43] >>> 30;
          b49 = s5[43] << 2 | s5[42] >>> 30;
          b40 = s5[5] << 30 | s5[4] >>> 2;
          b41 = s5[4] << 30 | s5[5] >>> 2;
          b222 = s5[14] << 6 | s5[15] >>> 26;
          b23 = s5[15] << 6 | s5[14] >>> 26;
          b4 = s5[25] << 11 | s5[24] >>> 21;
          b5 = s5[24] << 11 | s5[25] >>> 21;
          b36 = s5[34] << 15 | s5[35] >>> 17;
          b37 = s5[35] << 15 | s5[34] >>> 17;
          b18 = s5[45] << 29 | s5[44] >>> 3;
          b19 = s5[44] << 29 | s5[45] >>> 3;
          b10 = s5[6] << 28 | s5[7] >>> 4;
          b11 = s5[7] << 28 | s5[6] >>> 4;
          b42 = s5[17] << 23 | s5[16] >>> 9;
          b43 = s5[16] << 23 | s5[17] >>> 9;
          b24 = s5[26] << 25 | s5[27] >>> 7;
          b25 = s5[27] << 25 | s5[26] >>> 7;
          b6 = s5[36] << 21 | s5[37] >>> 11;
          b7 = s5[37] << 21 | s5[36] >>> 11;
          b38 = s5[47] << 24 | s5[46] >>> 8;
          b39 = s5[46] << 24 | s5[47] >>> 8;
          b30 = s5[8] << 27 | s5[9] >>> 5;
          b31 = s5[9] << 27 | s5[8] >>> 5;
          b12 = s5[18] << 20 | s5[19] >>> 12;
          b13 = s5[19] << 20 | s5[18] >>> 12;
          b44 = s5[29] << 7 | s5[28] >>> 25;
          b45 = s5[28] << 7 | s5[29] >>> 25;
          b26 = s5[38] << 8 | s5[39] >>> 24;
          b27 = s5[39] << 8 | s5[38] >>> 24;
          b8 = s5[48] << 14 | s5[49] >>> 18;
          b9 = s5[49] << 14 | s5[48] >>> 18;
          s5[0] = b0 ^ ~b22 & b4;
          s5[1] = b1 ^ ~b32 & b5;
          s5[10] = b10 ^ ~b12 & b14;
          s5[11] = b11 ^ ~b13 & b15;
          s5[20] = b20 ^ ~b222 & b24;
          s5[21] = b21 ^ ~b23 & b25;
          s5[30] = b30 ^ ~b322 & b34;
          s5[31] = b31 ^ ~b33 & b35;
          s5[40] = b40 ^ ~b42 & b44;
          s5[41] = b41 ^ ~b43 & b45;
          s5[2] = b22 ^ ~b4 & b6;
          s5[3] = b32 ^ ~b5 & b7;
          s5[12] = b12 ^ ~b14 & b16;
          s5[13] = b13 ^ ~b15 & b17;
          s5[22] = b222 ^ ~b24 & b26;
          s5[23] = b23 ^ ~b25 & b27;
          s5[32] = b322 ^ ~b34 & b36;
          s5[33] = b33 ^ ~b35 & b37;
          s5[42] = b42 ^ ~b44 & b46;
          s5[43] = b43 ^ ~b45 & b47;
          s5[4] = b4 ^ ~b6 & b8;
          s5[5] = b5 ^ ~b7 & b9;
          s5[14] = b14 ^ ~b16 & b18;
          s5[15] = b15 ^ ~b17 & b19;
          s5[24] = b24 ^ ~b26 & b28;
          s5[25] = b25 ^ ~b27 & b29;
          s5[34] = b34 ^ ~b36 & b38;
          s5[35] = b35 ^ ~b37 & b39;
          s5[44] = b44 ^ ~b46 & b48;
          s5[45] = b45 ^ ~b47 & b49;
          s5[6] = b6 ^ ~b8 & b0;
          s5[7] = b7 ^ ~b9 & b1;
          s5[16] = b16 ^ ~b18 & b10;
          s5[17] = b17 ^ ~b19 & b11;
          s5[26] = b26 ^ ~b28 & b20;
          s5[27] = b27 ^ ~b29 & b21;
          s5[36] = b36 ^ ~b38 & b30;
          s5[37] = b37 ^ ~b39 & b31;
          s5[46] = b46 ^ ~b48 & b40;
          s5[47] = b47 ^ ~b49 & b41;
          s5[8] = b8 ^ ~b0 & b22;
          s5[9] = b9 ^ ~b1 & b32;
          s5[18] = b18 ^ ~b10 & b12;
          s5[19] = b19 ^ ~b11 & b13;
          s5[28] = b28 ^ ~b20 & b222;
          s5[29] = b29 ^ ~b21 & b23;
          s5[38] = b38 ^ ~b30 & b322;
          s5[39] = b39 ^ ~b31 & b33;
          s5[48] = b48 ^ ~b40 & b42;
          s5[49] = b49 ^ ~b41 & b43;
          s5[0] ^= RC[n6];
          s5[1] ^= RC[n6 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i5 = 0; i5 < methodNames.length; ++i5) {
          root[methodNames[i5]] = methods[methodNames[i5]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual2(l6, r5, msg) {
      if (l6 != r5)
        throw new Error(msg || "Assertion failed: " + l6 + " != " + r5);
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert2 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i5) {
      if ((msg.charCodeAt(i5) & 64512) !== 55296) {
        return false;
      }
      if (i5 < 0 || i5 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i5 + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p5 = 0;
          for (var i5 = 0; i5 < msg.length; i5++) {
            var c5 = msg.charCodeAt(i5);
            if (c5 < 128) {
              res[p5++] = c5;
            } else if (c5 < 2048) {
              res[p5++] = c5 >> 6 | 192;
              res[p5++] = c5 & 63 | 128;
            } else if (isSurrogatePair(msg, i5)) {
              c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i5) & 1023);
              res[p5++] = c5 >> 18 | 240;
              res[p5++] = c5 >> 12 & 63 | 128;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            } else {
              res[p5++] = c5 >> 12 | 224;
              res[p5++] = c5 >> 6 & 63 | 128;
              res[p5++] = c5 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i5 = 0; i5 < msg.length; i5 += 2)
            res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
        }
      } else {
        for (i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero2(msg[i5].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w6) {
      var res = w6 >>> 24 | w6 >>> 8 & 65280 | w6 << 8 & 16711680 | (w6 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++) {
        var w6 = msg[i5];
        if (endian === "little")
          w6 = htonl(w6);
        res += zero8(w6.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i5 = 0, k7 = start; i5 < res.length; i5++, k7 += 4) {
        var w6;
        if (endian === "big")
          w6 = msg[k7] << 24 | msg[k7 + 1] << 16 | msg[k7 + 2] << 8 | msg[k7 + 3];
        else
          w6 = msg[k7 + 3] << 24 | msg[k7 + 2] << 16 | msg[k7 + 1] << 8 | msg[k7];
        res[i5] = w6 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i5 = 0, k7 = 0; i5 < msg.length; i5++, k7 += 4) {
        var m4 = msg[i5];
        if (endian === "big") {
          res[k7] = m4 >>> 24;
          res[k7 + 1] = m4 >>> 16 & 255;
          res[k7 + 2] = m4 >>> 8 & 255;
          res[k7 + 3] = m4 & 255;
        } else {
          res[k7 + 3] = m4 >>> 24;
          res[k7 + 2] = m4 >>> 16 & 255;
          res[k7 + 1] = m4 >>> 8 & 255;
          res[k7] = m4 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w6, b4) {
      return w6 >>> b4 | w6 << 32 - b4;
    }
    exports.rotr32 = rotr32;
    function rotl32(w6, b4) {
      return w6 << b4 | w6 >>> 32 - b4;
    }
    exports.rotl32 = rotl32;
    function sum32(a4, b4) {
      return a4 + b4 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a4, b4, c5) {
      return a4 + b4 + c5 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a4, b4, c5, d6) {
      return a4 + b4 + c5 + d6 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a4, b4, c5, d6, e4) {
      return a4 + b4 + c5 + d6 + e4 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo3 = al + bl >>> 0;
      var hi3 = (lo3 < al ? 1 : 0) + ah + bh;
      buf[pos] = hi3 >>> 0;
      buf[pos + 1] = lo3;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo3 = al + bl >>> 0;
      var hi3 = (lo3 < al ? 1 : 0) + ah + bh;
      return hi3 >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo3 = al + bl;
      return lo3 >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo3 = al;
      lo3 = lo3 + bl >>> 0;
      carry += lo3 < al ? 1 : 0;
      lo3 = lo3 + cl >>> 0;
      carry += lo3 < cl ? 1 : 0;
      lo3 = lo3 + dl >>> 0;
      carry += lo3 < dl ? 1 : 0;
      var hi3 = ah + bh + ch + dh + carry;
      return hi3 >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo3 = al + bl + cl + dl;
      return lo3 >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo3 = al;
      lo3 = lo3 + bl >>> 0;
      carry += lo3 < al ? 1 : 0;
      lo3 = lo3 + cl >>> 0;
      carry += lo3 < cl ? 1 : 0;
      lo3 = lo3 + dl >>> 0;
      carry += lo3 < dl ? 1 : 0;
      lo3 = lo3 + el >>> 0;
      carry += lo3 < el ? 1 : 0;
      var hi3 = ah + bh + ch + dh + eh + carry;
      return hi3 >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo3 = al + bl + cl + dl + el;
      return lo3 >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r5 = al << 32 - num | ah >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r5 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r5, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r5, this.endian);
        for (var i5 = 0; i5 < msg.length; i5 += this._delta32)
          this._update(msg, i5, i5 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest2(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k7 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k7 + this.padLength);
      res[0] = 128;
      for (var i5 = 1; i5 < k7; i5++)
        res[i5] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t3 = 8; t3 < this.padLength; t3++)
          res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len & 255;
      } else {
        res[i5++] = len & 255;
        res[i5++] = len >>> 8 & 255;
        res[i5++] = len >>> 16 & 255;
        res[i5++] = len >>> 24 & 255;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        res[i5++] = 0;
        for (t3 = 8; t3 < this.padLength; t3++)
          res[i5++] = 0;
      }
      return res;
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var rotr32 = utils.rotr32;
    function ft_1(s5, x9, y7, z7) {
      if (s5 === 0)
        return ch32(x9, y7, z7);
      if (s5 === 1 || s5 === 3)
        return p32(x9, y7, z7);
      if (s5 === 2)
        return maj32(x9, y7, z7);
    }
    exports.ft_1 = ft_1;
    function ch32(x9, y7, z7) {
      return x9 & y7 ^ ~x9 & z7;
    }
    exports.ch32 = ch32;
    function maj32(x9, y7, z7) {
      return x9 & y7 ^ x9 & z7 ^ y7 & z7;
    }
    exports.maj32 = maj32;
    function p32(x9, y7, z7) {
      return x9 ^ y7 ^ z7;
    }
    exports.p32 = p32;
    function s0_256(x9) {
      return rotr32(x9, 2) ^ rotr32(x9, 13) ^ rotr32(x9, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x9) {
      return rotr32(x9, 6) ^ rotr32(x9, 11) ^ rotr32(x9, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x9) {
      return rotr32(x9, 7) ^ rotr32(x9, 18) ^ x9 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x9) {
      return rotr32(x9, 17) ^ rotr32(x9, 19) ^ x9 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W4[i5] = msg[start + i5];
      for (; i5 < W4.length; i5++)
        W4[i5] = rotl32(W4[i5 - 3] ^ W4[i5 - 8] ^ W4[i5 - 14] ^ W4[i5 - 16], 1);
      var a4 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d6 = this.h[3];
      var e4 = this.h[4];
      for (i5 = 0; i5 < W4.length; i5++) {
        var s5 = ~~(i5 / 20);
        var t3 = sum32_5(rotl32(a4, 5), ft_1(s5, b4, c5, d6), e4, W4[i5], sha1_K[s5]);
        e4 = d6;
        d6 = c5;
        c5 = rotl32(b4, 30);
        b4 = a4;
        a4 = t3;
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d6);
      this.h[4] = sum32(this.h[4], e4);
    };
    SHA1.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i5 = 0; i5 < 16; i5++)
        W4[i5] = msg[start + i5];
      for (; i5 < W4.length; i5++)
        W4[i5] = sum32_4(g1_256(W4[i5 - 2]), W4[i5 - 7], g0_256(W4[i5 - 15]), W4[i5 - 16]);
      var a4 = this.h[0];
      var b4 = this.h[1];
      var c5 = this.h[2];
      var d6 = this.h[3];
      var e4 = this.h[4];
      var f5 = this.h[5];
      var g6 = this.h[6];
      var h7 = this.h[7];
      assert2(this.k.length === W4.length);
      for (i5 = 0; i5 < W4.length; i5++) {
        var T1 = sum32_5(h7, s1_256(e4), ch32(e4, f5, g6), this.k[i5], W4[i5]);
        var T22 = sum32(s0_256(a4), maj32(a4, b4, c5));
        h7 = g6;
        g6 = f5;
        f5 = e4;
        e4 = sum32(d6, T1);
        d6 = c5;
        c5 = b4;
        b4 = a4;
        a4 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b4);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d6);
      this.h[4] = sum32(this.h[4], e4);
      this.h[5] = sum32(this.h[5], f5);
      this.h[6] = sum32(this.h[6], g6);
      this.h[7] = sum32(this.h[7], h7);
    };
    SHA256.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W4 = this.W;
      for (var i5 = 0; i5 < 32; i5++)
        W4[i5] = msg[start + i5];
      for (; i5 < W4.length; i5 += 2) {
        var c0_hi = g1_512_hi(W4[i5 - 4], W4[i5 - 3]);
        var c0_lo = g1_512_lo(W4[i5 - 4], W4[i5 - 3]);
        var c1_hi = W4[i5 - 14];
        var c1_lo = W4[i5 - 13];
        var c2_hi = g0_512_hi(W4[i5 - 30], W4[i5 - 29]);
        var c2_lo = g0_512_lo(W4[i5 - 30], W4[i5 - 29]);
        var c3_hi = W4[i5 - 32];
        var c3_lo = W4[i5 - 31];
        W4[i5] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W4[i5 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W4 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W4.length);
      for (var i5 = 0; i5 < W4.length; i5 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i5];
        var c3_lo = this.k[i5 + 1];
        var c4_hi = W4[i5];
        var c4_lo = W4[i5 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ ~xh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ ~xl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ xh & zh ^ yh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ xl & zl ^ yl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils4();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update2(msg, start) {
      var A7 = this.h[0];
      var B4 = this.h[1];
      var C7 = this.h[2];
      var D5 = this.h[3];
      var E7 = this.h[4];
      var Ah = A7;
      var Bh = B4;
      var Ch = C7;
      var Dh = D5;
      var Eh = E7;
      for (var j6 = 0; j6 < 80; j6++) {
        var T6 = sum32(
          rotl32(
            sum32_4(A7, f5(j6, B4, C7, D5), msg[r5[j6] + start], K4(j6)),
            s5[j6]
          ),
          E7
        );
        A7 = E7;
        E7 = D5;
        D5 = rotl32(C7, 10);
        C7 = B4;
        B4 = T6;
        T6 = sum32(
          rotl32(
            sum32_4(Ah, f5(79 - j6, Bh, Ch, Dh), msg[rh[j6] + start], Kh(j6)),
            sh[j6]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T6;
      }
      T6 = sum32_3(this.h[1], C7, Dh);
      this.h[1] = sum32_3(this.h[2], D5, Eh);
      this.h[2] = sum32_3(this.h[3], E7, Ah);
      this.h[3] = sum32_3(this.h[4], A7, Bh);
      this.h[4] = sum32_3(this.h[0], B4, Ch);
      this.h[0] = T6;
    };
    RIPEMD160.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f5(j6, x9, y7, z7) {
      if (j6 <= 15)
        return x9 ^ y7 ^ z7;
      else if (j6 <= 31)
        return x9 & y7 | ~x9 & z7;
      else if (j6 <= 47)
        return (x9 | ~y7) ^ z7;
      else if (j6 <= 63)
        return x9 & z7 | y7 & ~z7;
      else
        return x9 ^ (y7 | ~z7);
    }
    function K4(j6) {
      if (j6 <= 15)
        return 0;
      else if (j6 <= 31)
        return 1518500249;
      else if (j6 <= 47)
        return 1859775393;
      else if (j6 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j6) {
      if (j6 <= 15)
        return 1352829926;
      else if (j6 <= 31)
        return 1548603684;
      else if (j6 <= 47)
        return 1836072691;
      else if (j6 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r5 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s5 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash2, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key2, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init2(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert2(key2.length <= this.blockSize);
      for (var i5 = key2.length; i5 < this.blockSize; i5++)
        key2.push(0);
      for (i5 = 0; i5 < key2.length; i5++)
        key2[i5] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i5 = 0; i5 < key2.length; i5++)
        key2[i5] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports) {
    var hash2 = exports;
    hash2.utils = require_utils4();
    hash2.common = require_common();
    hash2.sha = require_sha();
    hash2.ripemd = require_ripemd();
    hash2.hmac = require_hmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.6.1",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/.pnpm/bn.js@4.12.1/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/.pnpm/bn.js@4.12.1/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number, base3, endian) {
        if (BN3.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e4) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init2(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN3.prototype._initArray = function _initArray(number, base3, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var j6, w6;
        var off = 0;
        if (endian === "be") {
          for (i5 = number.length - 1, j6 = 0; i5 >= 0; i5 -= 3) {
            w6 = number[i5] | number[i5 - 1] << 8 | number[i5 - 2] << 16;
            this.words[j6] |= w6 << off & 67108863;
            this.words[j6 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        } else if (endian === "le") {
          for (i5 = 0, j6 = 0; i5 < number.length; i5 += 3) {
            w6 = number[i5] | number[i5 + 1] << 8 | number[i5 + 2] << 16;
            this.words[j6] |= w6 << off & 67108863;
            this.words[j6 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j6++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string2, index) {
        var c5 = string2.charCodeAt(index);
        if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          return c5 - 48 & 15;
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r5 = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r5 |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r5;
      }
      BN3.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          this.words[i5] = 0;
        }
        var off = 0;
        var j6 = 0;
        var w6;
        if (endian === "be") {
          for (i5 = number.length - 1; i5 >= start; i5 -= 2) {
            w6 = parseHexByte(number, start, i5) << off;
            this.words[j6] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i5 = parseLength % 2 === 0 ? start + 1 : start; i5 < number.length; i5 += 2) {
            w6 = parseHexByte(number, start, i5) << off;
            this.words[j6] |= w6 & 67108863;
            if (off >= 18) {
              off -= 18;
              j6 += 1;
              this.words[j6] |= w6 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul3) {
        var r5 = 0;
        var len = Math.min(str.length, end);
        for (var i5 = start; i5 < len; i5++) {
          var c5 = str.charCodeAt(i5) - 48;
          r5 *= mul3;
          if (c5 >= 49) {
            r5 += c5 - 49 + 10;
          } else if (c5 >= 17) {
            r5 += c5 - 17 + 10;
          } else {
            r5 += c5;
          }
        }
        return r5;
      }
      BN3.prototype._parseBase = function _parseBase(number, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i5 = start; i5 < end; i5 += limbLen) {
          word = parseBase(number, i5, i5 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i5, number.length, base3);
          for (i5 = 0; i5 < mod; i5++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i5 = 0; i5 < this.length; i5++) {
          dest.words[i5] = this.words[i5];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN3.prototype.clone = function clone() {
        var r5 = new BN3(null);
        this.copy(r5);
        return r5;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN3.prototype.inspect = function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString3(base3, padding) {
        base3 = base3 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i5 = 0; i5 < this.length; i5++) {
            var w6 = this.words[i5];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i5--;
            }
            if (carry !== 0 || i5 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r5 = c5.modn(groupBase).toString(base3);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN3.prototype.toBuffer = function toBuffer(endian, length2) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length2);
      };
      BN3.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i5;
        var q4 = this.clone();
        if (!littleEndian) {
          for (i5 = 0; i5 < reqLength - byteLength; i5++) {
            res[i5] = 0;
          }
          for (i5 = 0; !q4.isZero(); i5++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[reqLength - i5 - 1] = b4;
          }
        } else {
          for (i5 = 0; !q4.isZero(); i5++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[i5] = b4;
          }
          for (; i5 < reqLength; i5++) {
            res[i5] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w6) {
          var t3 = w6;
          var r5 = 0;
          if (t3 >= 4096) {
            r5 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r5 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r5 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r5 += 2;
            t3 >>>= 2;
          }
          return r5 + t3;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t3 = w6;
        var r5 = 0;
        if ((t3 & 8191) === 0) {
          r5 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r5 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r5 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r5 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi3 = this._countBits(w6);
        return (this.length - 1) * 26 + hi3;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var b4 = this._zeroBits(this.words[i5]);
          r5 += b4;
          if (b4 !== 26)
            break;
        }
        return r5;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i5 = 0; i5 < num.length; i5++) {
          this.words[i5] = this.words[i5] | num.words[i5];
        }
        return this.strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or5(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = this.words[i5] & num.words[i5];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a4;
        var b4;
        if (this.length > num.length) {
          a4 = this;
          b4 = num;
        } else {
          a4 = num;
          b4 = this;
        }
        for (var i5 = 0; i5 < b4.length; i5++) {
          this.words[i5] = a4.words[i5] ^ b4.words[i5];
        }
        if (this !== a4) {
          for (; i5 < a4.length; i5++) {
            this.words[i5] = a4.words[i5];
          }
        }
        this.length = a4.length;
        return this.strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i5 = 0; i5 < bytesNeeded; i5++) {
          this.words[i5] = ~this.words[i5] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i5] = ~this.words[i5] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b4;
        if (this.length > num.length) {
          a4 = this;
          b4 = num;
        } else {
          a4 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r5 = (a4.words[i5] | 0) + (b4.words[i5] | 0) + carry;
          this.words[i5] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i5 < a4.length; i5++) {
          r5 = (a4.words[i5] | 0) + carry;
          this.words[i5] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i5 < a4.length; i5++) {
            this.words[i5] = a4.words[i5];
          }
        }
        return this;
      };
      BN3.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b4;
        if (cmp > 0) {
          a4 = this;
          b4 = num;
        } else {
          a4 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i5 = 0; i5 < b4.length; i5++) {
          r5 = (a4.words[i5] | 0) - (b4.words[i5] | 0) + carry;
          carry = r5 >> 26;
          this.words[i5] = r5 & 67108863;
        }
        for (; carry !== 0 && i5 < a4.length; i5++) {
          r5 = (a4.words[i5] | 0) + carry;
          carry = r5 >> 26;
          this.words[i5] = r5 & 67108863;
        }
        if (carry === 0 && i5 < a4.length && a4 !== this) {
          for (; i5 < a4.length; i5++) {
            this.words[i5] = a4.words[i5];
          }
        }
        this.length = Math.max(this.length, i5);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r5 = a4 * b4;
        var lo3 = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo3;
        for (var k7 = 1; k7 < len; k7++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k7, num.length - 1);
          for (var j6 = Math.max(0, k7 - self2.length + 1); j6 <= maxJ; j6++) {
            var i5 = k7 - j6 | 0;
            a4 = self2.words[i5] | 0;
            b4 = num.words[j6] | 0;
            r5 = a4 * b4 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k7] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k7] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b4 = num.words;
        var o6 = out.words;
        var c5 = 0;
        var lo3;
        var mid;
        var hi3;
        var a0 = a4[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a4[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo3 = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi3 = Math.imul(ah0, bh0);
        var w0 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo3 = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi3 = Math.imul(ah1, bh0);
        lo3 = lo3 + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi3 = hi3 + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo3 = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi3 = Math.imul(ah2, bh0);
        lo3 = lo3 + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi3 = hi3 + Math.imul(ah1, bh1) | 0;
        lo3 = lo3 + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi3 = hi3 + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo3 = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi3 = Math.imul(ah3, bh0);
        lo3 = lo3 + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi3 = hi3 + Math.imul(ah2, bh1) | 0;
        lo3 = lo3 + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi3 = hi3 + Math.imul(ah1, bh2) | 0;
        lo3 = lo3 + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi3 = hi3 + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo3 = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi3 = Math.imul(ah4, bh0);
        lo3 = lo3 + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi3 = hi3 + Math.imul(ah3, bh1) | 0;
        lo3 = lo3 + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi3 = hi3 + Math.imul(ah2, bh2) | 0;
        lo3 = lo3 + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi3 = hi3 + Math.imul(ah1, bh3) | 0;
        lo3 = lo3 + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi3 = hi3 + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo3 = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi3 = Math.imul(ah5, bh0);
        lo3 = lo3 + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi3 = hi3 + Math.imul(ah4, bh1) | 0;
        lo3 = lo3 + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi3 = hi3 + Math.imul(ah3, bh2) | 0;
        lo3 = lo3 + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi3 = hi3 + Math.imul(ah2, bh3) | 0;
        lo3 = lo3 + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi3 = hi3 + Math.imul(ah1, bh4) | 0;
        lo3 = lo3 + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi3 = hi3 + Math.imul(ah0, bh5) | 0;
        var w52 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo3 = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi3 = Math.imul(ah6, bh0);
        lo3 = lo3 + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi3 = hi3 + Math.imul(ah5, bh1) | 0;
        lo3 = lo3 + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi3 = hi3 + Math.imul(ah4, bh2) | 0;
        lo3 = lo3 + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi3 = hi3 + Math.imul(ah3, bh3) | 0;
        lo3 = lo3 + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi3 = hi3 + Math.imul(ah2, bh4) | 0;
        lo3 = lo3 + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi3 = hi3 + Math.imul(ah1, bh5) | 0;
        lo3 = lo3 + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi3 = hi3 + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo3 = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi3 = Math.imul(ah7, bh0);
        lo3 = lo3 + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi3 = hi3 + Math.imul(ah6, bh1) | 0;
        lo3 = lo3 + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi3 = hi3 + Math.imul(ah5, bh2) | 0;
        lo3 = lo3 + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi3 = hi3 + Math.imul(ah4, bh3) | 0;
        lo3 = lo3 + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi3 = hi3 + Math.imul(ah3, bh4) | 0;
        lo3 = lo3 + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi3 = hi3 + Math.imul(ah2, bh5) | 0;
        lo3 = lo3 + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi3 = hi3 + Math.imul(ah1, bh6) | 0;
        lo3 = lo3 + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi3 = hi3 + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo3 = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi3 = Math.imul(ah8, bh0);
        lo3 = lo3 + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi3 = hi3 + Math.imul(ah7, bh1) | 0;
        lo3 = lo3 + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi3 = hi3 + Math.imul(ah6, bh2) | 0;
        lo3 = lo3 + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi3 = hi3 + Math.imul(ah5, bh3) | 0;
        lo3 = lo3 + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi3 = hi3 + Math.imul(ah4, bh4) | 0;
        lo3 = lo3 + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi3 = hi3 + Math.imul(ah3, bh5) | 0;
        lo3 = lo3 + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi3 = hi3 + Math.imul(ah2, bh6) | 0;
        lo3 = lo3 + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi3 = hi3 + Math.imul(ah1, bh7) | 0;
        lo3 = lo3 + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi3 = hi3 + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo3 = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi3 = Math.imul(ah9, bh0);
        lo3 = lo3 + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi3 = hi3 + Math.imul(ah8, bh1) | 0;
        lo3 = lo3 + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi3 = hi3 + Math.imul(ah7, bh2) | 0;
        lo3 = lo3 + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi3 = hi3 + Math.imul(ah6, bh3) | 0;
        lo3 = lo3 + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi3 = hi3 + Math.imul(ah5, bh4) | 0;
        lo3 = lo3 + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi3 = hi3 + Math.imul(ah4, bh5) | 0;
        lo3 = lo3 + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi3 = hi3 + Math.imul(ah3, bh6) | 0;
        lo3 = lo3 + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi3 = hi3 + Math.imul(ah2, bh7) | 0;
        lo3 = lo3 + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi3 = hi3 + Math.imul(ah1, bh8) | 0;
        lo3 = lo3 + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi3 = hi3 + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo3 = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi3 = Math.imul(ah9, bh1);
        lo3 = lo3 + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi3 = hi3 + Math.imul(ah8, bh2) | 0;
        lo3 = lo3 + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi3 = hi3 + Math.imul(ah7, bh3) | 0;
        lo3 = lo3 + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi3 = hi3 + Math.imul(ah6, bh4) | 0;
        lo3 = lo3 + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi3 = hi3 + Math.imul(ah5, bh5) | 0;
        lo3 = lo3 + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi3 = hi3 + Math.imul(ah4, bh6) | 0;
        lo3 = lo3 + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi3 = hi3 + Math.imul(ah3, bh7) | 0;
        lo3 = lo3 + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi3 = hi3 + Math.imul(ah2, bh8) | 0;
        lo3 = lo3 + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi3 = hi3 + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo3 = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi3 = Math.imul(ah9, bh2);
        lo3 = lo3 + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi3 = hi3 + Math.imul(ah8, bh3) | 0;
        lo3 = lo3 + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi3 = hi3 + Math.imul(ah7, bh4) | 0;
        lo3 = lo3 + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi3 = hi3 + Math.imul(ah6, bh5) | 0;
        lo3 = lo3 + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi3 = hi3 + Math.imul(ah5, bh6) | 0;
        lo3 = lo3 + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi3 = hi3 + Math.imul(ah4, bh7) | 0;
        lo3 = lo3 + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi3 = hi3 + Math.imul(ah3, bh8) | 0;
        lo3 = lo3 + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi3 = hi3 + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo3 = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi3 = Math.imul(ah9, bh3);
        lo3 = lo3 + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi3 = hi3 + Math.imul(ah8, bh4) | 0;
        lo3 = lo3 + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi3 = hi3 + Math.imul(ah7, bh5) | 0;
        lo3 = lo3 + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi3 = hi3 + Math.imul(ah6, bh6) | 0;
        lo3 = lo3 + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi3 = hi3 + Math.imul(ah5, bh7) | 0;
        lo3 = lo3 + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi3 = hi3 + Math.imul(ah4, bh8) | 0;
        lo3 = lo3 + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi3 = hi3 + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo3 = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi3 = Math.imul(ah9, bh4);
        lo3 = lo3 + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi3 = hi3 + Math.imul(ah8, bh5) | 0;
        lo3 = lo3 + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi3 = hi3 + Math.imul(ah7, bh6) | 0;
        lo3 = lo3 + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi3 = hi3 + Math.imul(ah6, bh7) | 0;
        lo3 = lo3 + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi3 = hi3 + Math.imul(ah5, bh8) | 0;
        lo3 = lo3 + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi3 = hi3 + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo3 = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi3 = Math.imul(ah9, bh5);
        lo3 = lo3 + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi3 = hi3 + Math.imul(ah8, bh6) | 0;
        lo3 = lo3 + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi3 = hi3 + Math.imul(ah7, bh7) | 0;
        lo3 = lo3 + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi3 = hi3 + Math.imul(ah6, bh8) | 0;
        lo3 = lo3 + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi3 = hi3 + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo3 = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi3 = Math.imul(ah9, bh6);
        lo3 = lo3 + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi3 = hi3 + Math.imul(ah8, bh7) | 0;
        lo3 = lo3 + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi3 = hi3 + Math.imul(ah7, bh8) | 0;
        lo3 = lo3 + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi3 = hi3 + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo3 = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi3 = Math.imul(ah9, bh7);
        lo3 = lo3 + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi3 = hi3 + Math.imul(ah8, bh8) | 0;
        lo3 = lo3 + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi3 = hi3 + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo3 = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi3 = Math.imul(ah9, bh8);
        lo3 = lo3 + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi3 = hi3 + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo3 = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi3 = Math.imul(ah9, bh9);
        var w18 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi3 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o6[0] = w0;
        o6[1] = w1;
        o6[2] = w22;
        o6[3] = w32;
        o6[4] = w42;
        o6[5] = w52;
        o6[6] = w6;
        o6[7] = w7;
        o6[8] = w8;
        o6[9] = w9;
        o6[10] = w10;
        o6[11] = w11;
        o6[12] = w12;
        o6[13] = w13;
        o6[14] = w14;
        o6[15] = w15;
        o6[16] = w16;
        o6[17] = w17;
        o6[18] = w18;
        if (c5 !== 0) {
          o6[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k7 = 0; k7 < out.length - 1; k7++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k7, num.length - 1);
          for (var j6 = Math.max(0, k7 - self2.length + 1); j6 <= maxJ; j6++) {
            var i5 = k7 - j6;
            var a4 = self2.words[i5] | 0;
            var b4 = num.words[j6] | 0;
            var r5 = a4 * b4;
            var lo3 = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo3 = lo3 + rword | 0;
            rword = lo3 & 67108863;
            ncarry = ncarry + (lo3 >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k7] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k7] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x9, y7) {
        this.x = x9;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N10) {
        var t3 = new Array(N10);
        var l6 = BN3.prototype._countBits(N10) - 1;
        for (var i5 = 0; i5 < N10; i5++) {
          t3[i5] = this.revBin(i5, l6, N10);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x9, l6, N10) {
        if (x9 === 0 || x9 === N10 - 1)
          return x9;
        var rb = 0;
        for (var i5 = 0; i5 < l6; i5++) {
          rb |= (x9 & 1) << l6 - i5 - 1;
          x9 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N10) {
        for (var i5 = 0; i5 < N10; i5++) {
          rtws[i5] = rws[rbt[i5]];
          itws[i5] = iws[rbt[i5]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N10, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N10);
        for (var s5 = 1; s5 < N10; s5 <<= 1) {
          var l6 = s5 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l6);
          var itwdf = Math.sin(2 * Math.PI / l6);
          for (var p5 = 0; p5 < N10; p5 += l6) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j6 = 0; j6 < s5; j6++) {
              var re3 = rtws[p5 + j6];
              var ie2 = itws[p5 + j6];
              var ro3 = rtws[p5 + j6 + s5];
              var io2 = itws[p5 + j6 + s5];
              var rx = rtwdf_ * ro3 - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro3;
              ro3 = rx;
              rtws[p5 + j6] = re3 + ro3;
              itws[p5 + j6] = ie2 + io2;
              rtws[p5 + j6 + s5] = re3 - ro3;
              itws[p5 + j6 + s5] = ie2 - io2;
              if (j6 !== l6) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n6, m4) {
        var N10 = Math.max(m4, n6) | 1;
        var odd = N10 & 1;
        var i5 = 0;
        for (N10 = N10 / 2 | 0; N10; N10 = N10 >>> 1) {
          i5++;
        }
        return 1 << i5 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N10) {
        if (N10 <= 1)
          return;
        for (var i5 = 0; i5 < N10 / 2; i5++) {
          var t3 = rws[i5];
          rws[i5] = rws[N10 - i5 - 1];
          rws[N10 - i5 - 1] = t3;
          t3 = iws[i5];
          iws[i5] = -iws[N10 - i5 - 1];
          iws[N10 - i5 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws3, N10) {
        var carry = 0;
        for (var i5 = 0; i5 < N10 / 2; i5++) {
          var w6 = Math.round(ws3[2 * i5 + 1] / N10) * 8192 + Math.round(ws3[2 * i5] / N10) + carry;
          ws3[i5] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws3;
      };
      FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N10) {
        var carry = 0;
        for (var i5 = 0; i5 < len; i5++) {
          carry = carry + (ws3[i5] | 0);
          rws[2 * i5] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i5 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i5 = 2 * len; i5 < N10; ++i5) {
          rws[i5] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N10) {
        var ph = new Array(N10);
        for (var i5 = 0; i5 < N10; i5++) {
          ph[i5] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x9, y7, out) {
        var N10 = 2 * this.guessLen13b(x9.length, y7.length);
        var rbt = this.makeRBT(N10);
        var _7 = this.stub(N10);
        var rws = new Array(N10);
        var rwst = new Array(N10);
        var iwst = new Array(N10);
        var nrws = new Array(N10);
        var nrwst = new Array(N10);
        var niwst = new Array(N10);
        var rmws = out.words;
        rmws.length = N10;
        this.convert13b(x9.words, x9.length, rws, N10);
        this.convert13b(y7.words, y7.length, nrws, N10);
        this.transform(rws, _7, rwst, iwst, N10, rbt);
        this.transform(nrws, _7, nrwst, niwst, N10, rbt);
        for (var i5 = 0; i5 < N10; i5++) {
          var rx = rwst[i5] * nrwst[i5] - iwst[i5] * niwst[i5];
          iwst[i5] = rwst[i5] * niwst[i5] + iwst[i5] * nrwst[i5];
          rwst[i5] = rx;
        }
        this.conjugate(rwst, iwst, N10);
        this.transform(rwst, iwst, rmws, _7, N10, rbt);
        this.conjugate(rmws, _7, N10);
        this.normalize13b(rmws, N10);
        out.negative = x9.negative ^ y7.negative;
        out.length = x9.length + y7.length;
        return out.strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i5 = 0; i5 < this.length; i5++) {
          var w6 = (this.words[i5] | 0) * num;
          var lo3 = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo3 >>> 26;
          this.words[i5] = lo3 & 67108863;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN3(1);
        var res = this;
        for (var i5 = 0; i5 < w6.length; i5++, res = res.sqr()) {
          if (w6[i5] !== 0)
            break;
        }
        if (++i5 < w6.length) {
          for (var q4 = res.sqr(); i5 < w6.length; i5++, q4 = q4.sqr()) {
            if (w6[i5] === 0)
              continue;
            res = res.mul(q4);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s5 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i5;
        if (r5 !== 0) {
          var carry = 0;
          for (i5 = 0; i5 < this.length; i5++) {
            var newCarry = this.words[i5] & carryMask;
            var c5 = (this.words[i5] | 0) - newCarry << r5;
            this.words[i5] = c5 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i5] = carry;
            this.length++;
          }
        }
        if (s5 !== 0) {
          for (i5 = this.length - 1; i5 >= 0; i5--) {
            this.words[i5 + s5] = this.words[i5];
          }
          for (i5 = 0; i5 < s5; i5++) {
            this.words[i5] = 0;
          }
          this.length += s5;
        }
        return this.strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h7;
        if (hint) {
          h7 = (hint - hint % 26) / 26;
        } else {
          h7 = 0;
        }
        var r5 = bits % 26;
        var s5 = Math.min((bits - r5) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h7 -= s5;
        h7 = Math.max(0, h7);
        if (maskedWords) {
          for (var i5 = 0; i5 < s5; i5++) {
            maskedWords.words[i5] = this.words[i5];
          }
          maskedWords.length = s5;
        }
        if (s5 === 0) {
        } else if (this.length > s5) {
          this.length -= s5;
          for (i5 = 0; i5 < this.length; i5++) {
            this.words[i5] = this.words[i5 + s5];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i5 = this.length - 1; i5 >= 0 && (carry !== 0 || i5 >= h7); i5--) {
          var word = this.words[i5] | 0;
          this.words[i5] = carry << 26 - r5 | word >>> r5;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s5 = (bit - r5) / 26;
        var q4 = 1 << r5;
        if (this.length <= s5)
          return false;
        var w6 = this.words[s5];
        return !!(w6 & q4);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s5 = (bits - r5) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s5) {
          return this;
        }
        if (r5 !== 0) {
          s5++;
        }
        this.length = Math.min(s5, this.length);
        if (r5 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i5 = 0; i5 < this.length && this.words[i5] >= 67108864; i5++) {
          this.words[i5] -= 67108864;
          if (i5 === this.length - 1) {
            this.words[i5 + 1] = 1;
          } else {
            this.words[i5 + 1]++;
          }
        }
        this.length = Math.max(this.length, i5 + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i5 = 0; i5 < this.length && this.words[i5] < 0; i5++) {
            this.words[i5] += 67108864;
            this.words[i5 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i5;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i5 = 0; i5 < num.length; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          var right = (num.words[i5] | 0) * mul3;
          w6 -= right & 67108863;
          carry = (w6 >> 26) - (right / 67108864 | 0);
          this.words[i5 + shift] = w6 & 67108863;
        }
        for (; i5 < this.length - shift; i5++) {
          w6 = (this.words[i5 + shift] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5 + shift] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i5 = 0; i5 < this.length; i5++) {
          w6 = -(this.words[i5] | 0) + carry;
          carry = w6 >> 26;
          this.words[i5] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b4 = b4.ushln(shift);
          a4.iushln(shift);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m4 = a4.length - b4.length;
        var q4;
        if (mode !== "mod") {
          q4 = new BN3(null);
          q4.length = m4 + 1;
          q4.words = new Array(q4.length);
          for (var i5 = 0; i5 < q4.length; i5++) {
            q4.words[i5] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b4, 1, m4);
        if (diff.negative === 0) {
          a4 = diff;
          if (q4) {
            q4.words[m4] = 1;
          }
        }
        for (var j6 = m4 - 1; j6 >= 0; j6--) {
          var qj = (a4.words[b4.length + j6] | 0) * 67108864 + (a4.words[b4.length + j6 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b4, qj, j6);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b4, 1, j6);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q4) {
            q4.words[j6] = qj;
          }
        }
        if (q4) {
          q4.strip();
        }
        a4.strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q4 || null,
          mod: a4
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p5 = (1 << 26) % num;
        var acc = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          acc = (p5 * acc + (this.words[i5] | 0)) % num;
        }
        return acc;
      };
      BN3.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var w6 = (this.words[i5] | 0) + carry * 67108864;
          this.words[i5] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p5) {
        assert2(p5.negative === 0);
        assert2(!p5.isZero());
        var x9 = this;
        var y7 = p5.clone();
        if (x9.negative !== 0) {
          x9 = x9.umod(p5);
        } else {
          x9 = x9.clone();
        }
        var A7 = new BN3(1);
        var B4 = new BN3(0);
        var C7 = new BN3(0);
        var D5 = new BN3(1);
        var g6 = 0;
        while (x9.isEven() && y7.isEven()) {
          x9.iushrn(1);
          y7.iushrn(1);
          ++g6;
        }
        var yp = y7.clone();
        var xp = x9.clone();
        while (!x9.isZero()) {
          for (var i5 = 0, im = 1; (x9.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            x9.iushrn(i5);
            while (i5-- > 0) {
              if (A7.isOdd() || B4.isOdd()) {
                A7.iadd(yp);
                B4.isub(xp);
              }
              A7.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (y7.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            y7.iushrn(j6);
            while (j6-- > 0) {
              if (C7.isOdd() || D5.isOdd()) {
                C7.iadd(yp);
                D5.isub(xp);
              }
              C7.iushrn(1);
              D5.iushrn(1);
            }
          }
          if (x9.cmp(y7) >= 0) {
            x9.isub(y7);
            A7.isub(C7);
            B4.isub(D5);
          } else {
            y7.isub(x9);
            C7.isub(A7);
            D5.isub(B4);
          }
        }
        return {
          a: C7,
          b: D5,
          gcd: y7.iushln(g6)
        };
      };
      BN3.prototype._invmp = function _invmp(p5) {
        assert2(p5.negative === 0);
        assert2(!p5.isZero());
        var a4 = this;
        var b4 = p5.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p5);
        } else {
          a4 = a4.clone();
        }
        var x1 = new BN3(1);
        var x22 = new BN3(0);
        var delta = b4.clone();
        while (a4.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i5 = 0, im = 1; (a4.words[0] & im) === 0 && i5 < 26; ++i5, im <<= 1)
            ;
          if (i5 > 0) {
            a4.iushrn(i5);
            while (i5-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j6 = 0, jm = 1; (b4.words[0] & jm) === 0 && j6 < 26; ++j6, jm <<= 1)
            ;
          if (j6 > 0) {
            b4.iushrn(j6);
            while (j6-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b4) >= 0) {
            a4.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a4);
            x22.isub(x1);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p5);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b4 = num.clone();
        a4.negative = 0;
        b4.negative = 0;
        for (var shift = 0; a4.isEven() && b4.isEven(); shift++) {
          a4.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r5 = a4.cmp(b4);
          if (r5 < 0) {
            var t3 = a4;
            a4 = b4;
            b4 = t3;
          } else if (r5 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a4.isub(b4);
        } while (true);
        return b4.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r5 = bit % 26;
        var s5 = (bit - r5) / 26;
        var q4 = 1 << r5;
        if (this.length <= s5) {
          this._expand(s5 + 1);
          this.words[s5] |= q4;
          return this;
        }
        var carry = q4;
        for (var i5 = s5; carry !== 0 && i5 < this.length; i5++) {
          var w6 = this.words[i5] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i5] = w6;
        }
        if (carry !== 0) {
          this.words[i5] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i5 = this.length - 1; i5 >= 0; i5--) {
          var a4 = this.words[i5] | 0;
          var b4 = num.words[i5] | 0;
          if (a4 === b4)
            continue;
          if (a4 < b4) {
            res = -1;
          } else if (a4 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt5(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt5(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p5) {
        this.name = name2;
        this.p = new BN3(p5, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          if (r5.strip !== void 0) {
            r5.strip();
          } else {
            r5._strip();
          }
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i5 = 0; i5 < outLen; i5++) {
          output.words[i5] = input.words[i5];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i5 = 10; i5 < input.length; i5++) {
          var next = input.words[i5] | 0;
          input.words[i5 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i5 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo3 = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var w6 = num.words[i5] | 0;
          lo3 += w6 * 977;
          num.words[i5] = lo3 & 67108863;
          lo3 = w6 * 64 + (lo3 / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i5 = 0; i5 < num.length; i5++) {
          var hi3 = (num.words[i5] | 0) * 19 + carry;
          var lo3 = hi3 & 67108863;
          hi3 >>>= 26;
          num.words[i5] = lo3;
          carry = hi3;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN3._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert2(a4.negative === 0, "red works only with positives");
        assert2(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b4) {
        assert2((a4.negative | b4.negative) === 0, "red works only with positives");
        assert2(
          a4.red && a4.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        return a4.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg3(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add3(a4, b4) {
        this._verify2(a4, b4);
        var res = a4.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b4) {
        this._verify2(a4, b4);
        var res = a4.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b4) {
        this._verify2(a4, b4);
        var res = a4.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b4) {
        this._verify2(a4, b4);
        var res = a4.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b4) {
        this._verify2(a4, b4);
        return this.imod(a4.imul(b4));
      };
      Red.prototype.mul = function mul3(a4, b4) {
        this._verify2(a4, b4);
        return this.imod(a4.mul(b4));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q4 = this.m.subn(1);
        var s5 = 0;
        while (!q4.isZero() && q4.andln(1) === 0) {
          s5++;
          q4.iushrn(1);
        }
        assert2(!q4.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z7 = this.m.bitLength();
        z7 = new BN3(2 * z7 * z7).toRed(this);
        while (this.pow(z7, lpow).cmp(nOne) !== 0) {
          z7.redIAdd(nOne);
        }
        var c5 = this.pow(z7, q4);
        var r5 = this.pow(a4, q4.addn(1).iushrn(1));
        var t3 = this.pow(a4, q4);
        var m4 = s5;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i5 = 0; tmp.cmp(one) !== 0; i5++) {
            tmp = tmp.redSqr();
          }
          assert2(i5 < m4);
          var b4 = this.pow(c5, new BN3(1).iushln(m4 - i5 - 1));
          r5 = r5.redMul(b4);
          c5 = b4.redSqr();
          t3 = t3.redMul(c5);
          m4 = i5;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a4;
        for (var i5 = 2; i5 < wnd.length; i5++) {
          wnd[i5] = this.mul(wnd[i5 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i5 = num.length - 1; i5 >= 0; i5--) {
          var word = num.words[i5];
          for (var j6 = start - 1; j6 >= 0; j6--) {
            var bit = word >> j6 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i5 !== 0 || j6 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b4) {
        if (a4.isZero() || b4.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t3 = a4.imul(b4);
        var c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t3.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a4, b4) {
        if (a4.isZero() || b4.isZero())
          return new BN3(0)._forceRed(this);
        var t3 = a4.mul(b4);
        var c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u4 = t3.isub(c5).iushrn(this.shift);
        var res = u4;
        if (u4.cmp(this.m) >= 0) {
          res = u4.isub(this.m);
        } else if (u4.cmpn(0) < 0) {
          res = u4.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i5 = 0; i5 < msg.length; i5++)
          res[i5] = msg[i5] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i5 = 0; i5 < msg.length; i5 += 2)
          res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
      } else {
        for (var i5 = 0; i5 < msg.length; i5++) {
          var c5 = msg.charCodeAt(i5);
          var hi3 = c5 >> 8;
          var lo3 = c5 & 255;
          if (hi3)
            res.push(hi3, lo3);
          else
            res.push(lo3);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i5 = 0; i5 < msg.length; i5++)
        res += zero2(msg[i5].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode6(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN3 = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils5();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF2(num, w6, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i5;
      for (i5 = 0; i5 < naf.length; i5 += 1) {
        naf[i5] = 0;
      }
      var ws3 = 1 << w6 + 1;
      var k7 = num.clone();
      for (i5 = 0; i5 < naf.length; i5++) {
        var z7;
        var mod = k7.andln(ws3 - 1);
        if (k7.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z7 = (ws3 >> 1) - mod;
          else
            z7 = mod;
          k7.isubn(z7);
        } else {
          z7 = 0;
        }
        naf[i5] = z7;
        k7.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF2;
    function getJSF2(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF2;
    function cachedProperty(obj, name2, computer) {
      var key2 = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN3(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js"(exports, module) {
    var r5;
    module.exports = function rand2(len) {
      if (!r5)
        r5 = new Rand(null);
      return r5.generate(len);
    };
    function Rand(rand2) {
      this.rand = rand2;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate2(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n6) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n6);
      var res = new Uint8Array(n6);
      for (var i5 = 0; i5 < res.length; i5++)
        res[i5] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n6) {
          var arr = new Uint8Array(n6);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n6) {
          var arr = new Uint8Array(n6);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n6) {
          return crypto2.randomBytes(n6);
        };
      } catch (e4) {
      }
    }
    var crypto2;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var utils = require_utils6();
    var getNAF2 = utils.getNAF;
    var getJSF2 = utils.getJSF;
    var assert2 = utils.assert;
    function BaseCurve2(type, conf) {
      this.type = type;
      this.p = new BN3(conf.p, 16);
      this.red = conf.prime ? BN3.red(conf.prime) : BN3.mont(this.p);
      this.zero = new BN3(0).toRed(this.red);
      this.one = new BN3(1).toRed(this.red);
      this.two = new BN3(2).toRed(this.red);
      this.n = conf.n && new BN3(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve2;
    BaseCurve2.prototype.point = function point3() {
      throw new Error("Not implemented");
    };
    BaseCurve2.prototype.validate = function validate5() {
      throw new Error("Not implemented");
    };
    BaseCurve2.prototype._fixedNafMul = function _fixedNafMul2(p5, k7) {
      assert2(p5.precomputed);
      var doubles = p5._getDoubles();
      var naf = getNAF2(k7, 1, this._bitLength);
      var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I5 /= 3;
      var repr = [];
      var j6;
      var nafW;
      for (j6 = 0; j6 < naf.length; j6 += doubles.step) {
        nafW = 0;
        for (var l6 = j6 + doubles.step - 1; l6 >= j6; l6--)
          nafW = (nafW << 1) + naf[l6];
        repr.push(nafW);
      }
      var a4 = this.jpoint(null, null, null);
      var b4 = this.jpoint(null, null, null);
      for (var i5 = I5; i5 > 0; i5--) {
        for (j6 = 0; j6 < repr.length; j6++) {
          nafW = repr[j6];
          if (nafW === i5)
            b4 = b4.mixedAdd(doubles.points[j6]);
          else if (nafW === -i5)
            b4 = b4.mixedAdd(doubles.points[j6].neg());
        }
        a4 = a4.add(b4);
      }
      return a4.toP();
    };
    BaseCurve2.prototype._wnafMul = function _wnafMul2(p5, k7) {
      var w6 = 4;
      var nafPoints = p5._getNAFPoints(w6);
      w6 = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF2(k7, w6, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i5 = naf.length - 1; i5 >= 0; i5--) {
        for (var l6 = 0; i5 >= 0 && naf[i5] === 0; i5--)
          l6++;
        if (i5 >= 0)
          l6++;
        acc = acc.dblp(l6);
        if (i5 < 0)
          break;
        var z7 = naf[i5];
        assert2(z7 !== 0);
        if (p5.type === "affine") {
          if (z7 > 0)
            acc = acc.mixedAdd(wnd[z7 - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z7 - 1 >> 1].neg());
        } else {
          if (z7 > 0)
            acc = acc.add(wnd[z7 - 1 >> 1]);
          else
            acc = acc.add(wnd[-z7 - 1 >> 1].neg());
        }
      }
      return p5.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve2.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i5;
      var j6;
      var p5;
      for (i5 = 0; i5 < len; i5++) {
        p5 = points[i5];
        var nafPoints = p5._getNAFPoints(defW);
        wndWidth[i5] = nafPoints.wnd;
        wnd[i5] = nafPoints.points;
      }
      for (i5 = len - 1; i5 >= 1; i5 -= 2) {
        var a4 = i5 - 1;
        var b4 = i5;
        if (wndWidth[a4] !== 1 || wndWidth[b4] !== 1) {
          naf[a4] = getNAF2(coeffs[a4], wndWidth[a4], this._bitLength);
          naf[b4] = getNAF2(coeffs[b4], wndWidth[b4], this._bitLength);
          max = Math.max(naf[a4].length, max);
          max = Math.max(naf[b4].length, max);
          continue;
        }
        var comb = [
          points[a4],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b4]
          /* 7 */
        ];
        if (points[a4].y.cmp(points[b4].y) === 0) {
          comb[1] = points[a4].add(points[b4]);
          comb[2] = points[a4].toJ().mixedAdd(points[b4].neg());
        } else if (points[a4].y.cmp(points[b4].y.redNeg()) === 0) {
          comb[1] = points[a4].toJ().mixedAdd(points[b4]);
          comb[2] = points[a4].add(points[b4].neg());
        } else {
          comb[1] = points[a4].toJ().mixedAdd(points[b4]);
          comb[2] = points[a4].toJ().mixedAdd(points[b4].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF2(coeffs[a4], coeffs[b4]);
        max = Math.max(jsf[0].length, max);
        naf[a4] = new Array(max);
        naf[b4] = new Array(max);
        for (j6 = 0; j6 < max; j6++) {
          var ja = jsf[0][j6] | 0;
          var jb = jsf[1][j6] | 0;
          naf[a4][j6] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b4][j6] = 0;
          wnd[a4] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i5 = max; i5 >= 0; i5--) {
        var k7 = 0;
        while (i5 >= 0) {
          var zero = true;
          for (j6 = 0; j6 < len; j6++) {
            tmp[j6] = naf[j6][i5] | 0;
            if (tmp[j6] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k7++;
          i5--;
        }
        if (i5 >= 0)
          k7++;
        acc = acc.dblp(k7);
        if (i5 < 0)
          break;
        for (j6 = 0; j6 < len; j6++) {
          var z7 = tmp[j6];
          p5;
          if (z7 === 0)
            continue;
          else if (z7 > 0)
            p5 = wnd[j6][z7 - 1 >> 1];
          else if (z7 < 0)
            p5 = wnd[j6][-z7 - 1 >> 1].neg();
          if (p5.type === "affine")
            acc = acc.mixedAdd(p5);
          else
            acc = acc.add(p5);
        }
      }
      for (i5 = 0; i5 < len; i5++)
        wnd[i5] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint2(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve2.BasePoint = BasePoint2;
    BasePoint2.prototype.eq = function eq4() {
      throw new Error("Not implemented");
    };
    BasePoint2.prototype.validate = function validate5() {
      return this.curve.validate(this);
    };
    BaseCurve2.prototype.decodePoint = function decodePoint2(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert2(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert2(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint2.prototype.encodeCompressed = function encodeCompressed2(enc) {
      return this.encode(enc, true);
    };
    BasePoint2.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x9 = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x9);
      return [4].concat(x9, this.getY().toArray("be", len));
    };
    BasePoint2.prototype.encode = function encode6(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint2.prototype.precompute = function precompute2(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint2.prototype._hasDoubles = function _hasDoubles2(k7) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k7.bitLength() + 1) / doubles.step);
    };
    BasePoint2.prototype._getDoubles = function _getDoubles2(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i5 = 0; i5 < power; i5 += step) {
        for (var j6 = 0; j6 < step; j6++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint2.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl3 = max === 1 ? null : this.dbl();
      for (var i5 = 1; i5 < max; i5++)
        res[i5] = res[i5 - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint2.prototype._getBeta = function _getBeta3() {
      return null;
    };
    BasePoint2.prototype.dblp = function dblp3(k7) {
      var r5 = this;
      for (var i5 = 0; i5 < k7; i5++)
        r5 = r5.dbl();
      return r5;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var BN3 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function ShortCurve2(conf) {
      Base.call(this, "short", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve2, Base);
    module.exports = ShortCurve2;
    ShortCurve2.prototype._getEndomorphism = function _getEndomorphism2(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN3(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN3(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN3(vec.a, 16),
            b: new BN3(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve2.prototype._getEndoRoots = function _getEndoRoots2(num) {
      var red = num === this.p ? this.red : BN3.mont(num);
      var tinv = new BN3(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s5 = new BN3(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s5).fromRed();
      var l22 = ntinv.redSub(s5).fromRed();
      return [l1, l22];
    };
    ShortCurve2.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u4 = lambda;
      var v8 = this.n.clone();
      var x1 = new BN3(1);
      var y1 = new BN3(0);
      var x22 = new BN3(0);
      var y22 = new BN3(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a22;
      var b22;
      var prevR;
      var i5 = 0;
      var r5;
      var x9;
      while (u4.cmpn(0) !== 0) {
        var q4 = v8.div(u4);
        r5 = v8.sub(q4.mul(u4));
        x9 = x22.sub(q4.mul(x1));
        var y7 = y22.sub(q4.mul(y1));
        if (!a1 && r5.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r5.neg();
          b1 = x9;
        } else if (a1 && ++i5 === 2) {
          break;
        }
        prevR = r5;
        v8 = u4;
        u4 = r5;
        x22 = x1;
        x1 = x9;
        y22 = y1;
        y1 = y7;
      }
      a22 = r5.neg();
      b22 = x9;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a22.sqr().add(b22.sqr());
      if (len2.cmp(len1) >= 0) {
        a22 = a0;
        b22 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a22.negative) {
        a22 = a22.neg();
        b22 = b22.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a22, b: b22 }
      ];
    };
    ShortCurve2.prototype._endoSplit = function _endoSplit2(k7) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v22 = basis[1];
      var c1 = v22.b.mul(k7).divRound(this.n);
      var c22 = v1.b.neg().mul(k7).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p22 = c22.mul(v22.a);
      var q1 = c1.mul(v1.b);
      var q22 = c22.mul(v22.b);
      var k1 = k7.sub(p1).sub(p22);
      var k22 = q1.add(q22).neg();
      return { k1, k2: k22 };
    };
    ShortCurve2.prototype.pointFromX = function pointFromX2(x9, odd) {
      x9 = new BN3(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var y22 = x9.redSqr().redMul(x9).redIAdd(x9.redMul(this.a)).redIAdd(this.b);
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    ShortCurve2.prototype.validate = function validate5(point3) {
      if (point3.inf)
        return true;
      var x9 = point3.x;
      var y7 = point3.y;
      var ax = this.a.redMul(x9);
      var rhs = x9.redSqr().redMul(x9).redIAdd(ax).redIAdd(this.b);
      return y7.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve2.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i5 = 0; i5 < points.length; i5++) {
        var split = this._endoSplit(coeffs[i5]);
        var p5 = points[i5];
        var beta = p5._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p5 = p5.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i5 * 2] = p5;
        npoints[i5 * 2 + 1] = beta;
        ncoeffs[i5 * 2] = split.k1;
        ncoeffs[i5 * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i5 * 2, jacobianResult);
      for (var j6 = 0; j6 < i5 * 2; j6++) {
        npoints[j6] = null;
        ncoeffs[j6] = null;
      }
      return res;
    };
    function Point2(curve, x9, y7, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x9 === null && y7 === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN3(x9, 16);
        this.y = new BN3(y7, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point2, Base.BasePoint);
    ShortCurve2.prototype.point = function point3(x9, y7, isRed) {
      return new Point2(this, x9, y7, isRed);
    };
    ShortCurve2.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
      return Point2.fromJSON(this, obj, red);
    };
    Point2.prototype._getBeta = function _getBeta3() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p5) {
          return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point2.prototype.toJSON = function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point2.fromJSON = function fromJSON2(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.inf;
    };
    Point2.prototype.add = function add3(p5) {
      if (this.inf)
        return p5;
      if (p5.inf)
        return this;
      if (this.eq(p5))
        return this.dbl();
      if (this.neg().eq(p5))
        return this.curve.point(null, null);
      if (this.x.cmp(p5.x) === 0)
        return this.curve.point(null, null);
      var c5 = this.y.redSub(p5.y);
      if (c5.cmpn(0) !== 0)
        c5 = c5.redMul(this.x.redSub(p5.x).redInvm());
      var nx = c5.redSqr().redISub(this.x).redISub(p5.x);
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.dbl = function dbl3() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a4 = this.curve.a;
      var x22 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
      var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.getX = function getX2() {
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY2() {
      return this.y.fromRed();
    };
    Point2.prototype.mul = function mul3(k7) {
      k7 = new BN3(k7, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k7))
        return this.curve._fixedNafMul(this, k7);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k7]);
      else
        return this.curve._wnafMul(this, k7);
    };
    Point2.prototype.mulAdd = function mulAdd2(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point2.prototype.jmulAdd = function jmulAdd2(k1, p22, k22) {
      var points = [this, p22];
      var coeffs = [k1, k22];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point2.prototype.eq = function eq4(p5) {
      return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
    };
    Point2.prototype.neg = function neg3(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p5) {
          return p5.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point2.prototype.toJ = function toJ2() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint2(curve, x9, y7, z7) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x9 === null && y7 === null && z7 === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN3(0);
      } else {
        this.x = new BN3(x9, 16);
        this.y = new BN3(y7, 16);
        this.z = new BN3(z7, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint2, Base.BasePoint);
    ShortCurve2.prototype.jpoint = function jpoint2(x9, y7, z7) {
      return new JPoint2(this, x9, y7, z7);
    };
    JPoint2.prototype.toP = function toP2() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint2.prototype.neg = function neg3() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint2.prototype.add = function add3(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      var pz2 = p5.z.redSqr();
      var z22 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u22 = p5.x.redMul(z22);
      var s1 = this.y.redMul(pz2.redMul(p5.z));
      var s22 = p5.y.redMul(z22.redMul(this.z));
      var h7 = u1.redSub(u22);
      var r5 = s1.redSub(s22);
      if (h7.cmpn(0) === 0) {
        if (r5.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v8 = u1.redMul(h22);
      var nx = r5.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r5.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(p5.z).redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.mixedAdd = function mixedAdd2(p5) {
      if (this.isInfinity())
        return p5.toJ();
      if (p5.isInfinity())
        return this;
      var z22 = this.z.redSqr();
      var u1 = this.x;
      var u22 = p5.x.redMul(z22);
      var s1 = this.y;
      var s22 = p5.y.redMul(z22).redMul(this.z);
      var h7 = u1.redSub(u22);
      var r5 = s1.redSub(s22);
      if (h7.cmpn(0) === 0) {
        if (r5.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h22 = h7.redSqr();
      var h32 = h22.redMul(h7);
      var v8 = u1.redMul(h22);
      var nx = r5.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
      var ny = r5.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
      var nz = this.z.redMul(h7);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.dblp = function dblp3(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i5;
      if (this.curve.zeroA || this.curve.threeA) {
        var r5 = this;
        for (i5 = 0; i5 < pow; i5++)
          r5 = r5.dbl();
        return r5;
      }
      var a4 = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i5 = 0; i5 < pow; i5++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c5.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var dny = c5.redMul(t22);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i5 + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint2.prototype.dbl = function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint2.prototype._zeroDbl = function _zeroDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s5 = s5.redIAdd(s5);
        var m4 = xx.redAdd(xx).redIAdd(xx);
        var t3 = m4.redSqr().redISub(s5).redISub(s5);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t3;
        ny = m4.redMul(s5.redISub(t3)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a4 = this.x.redSqr();
        var b4 = this.y.redSqr();
        var c5 = b4.redSqr();
        var d6 = this.x.redAdd(b4).redSqr().redISub(a4).redISub(c5);
        d6 = d6.redIAdd(d6);
        var e4 = a4.redAdd(a4).redIAdd(a4);
        var f5 = e4.redSqr();
        var c8 = c5.redIAdd(c5);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f5.redISub(d6).redISub(d6);
        ny = e4.redMul(d6.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype._threeDbl = function _threeDbl2() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s5 = s5.redIAdd(s5);
        var m4 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t3 = m4.redSqr().redISub(s5).redISub(s5);
        nx = t3;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m4.redMul(s5.redISub(t3)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype._dbl = function _dbl2() {
      var a4 = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c5.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c5.redMul(t22).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.trpl = function trpl2() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m4 = xx.redAdd(xx).redIAdd(xx);
      var mm = m4.redSqr();
      var e4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e4 = e4.redIAdd(e4);
      e4 = e4.redAdd(e4).redIAdd(e4);
      e4 = e4.redISub(mm);
      var ee2 = e4.redSqr();
      var t3 = yyyy.redIAdd(yyyy);
      t3 = t3.redIAdd(t3);
      t3 = t3.redIAdd(t3);
      t3 = t3.redIAdd(t3);
      var u4 = m4.redIAdd(e4).redSqr().redISub(mm).redISub(ee2).redISub(t3);
      var yyu4 = yy.redMul(u4);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee2).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u4.redMul(t3.redISub(u4)).redISub(e4.redMul(ee2)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e4).redSqr().redISub(zz).redISub(ee2);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint2.prototype.mul = function mul3(k7, kbase) {
      k7 = new BN3(k7, kbase);
      return this.curve._wnafMul(this, k7);
    };
    JPoint2.prototype.eq = function eq4(p5) {
      if (p5.type === "affine")
        return this.eq(p5.toJ());
      if (this === p5)
        return true;
      var z22 = this.z.redSqr();
      var pz2 = p5.z.redSqr();
      if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
        return false;
      var z32 = z22.redMul(this.z);
      var pz3 = pz2.redMul(p5.z);
      return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
    };
    JPoint2.prototype.eqXToP = function eqXToP2(x9) {
      var zs3 = this.z.redSqr();
      var rx = x9.toRed(this.curve.red).redMul(zs3);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t3 = this.curve.redN.redMul(zs3);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t3);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint2.prototype.isInfinity = function isInfinity3() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils6();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN3(conf.a, 16).toRed(this.red);
      this.b = new BN3(conf.b, 16).toRed(this.red);
      this.i4 = new BN3(4).toRed(this.red).redInvm();
      this.two = new BN3(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate5(point3) {
      var x9 = point3.normalize().x;
      var x22 = x9.redSqr();
      var rhs = x22.redMul(x9).redAdd(x22.redMul(this.a)).redAdd(x9);
      var y7 = rhs.redSqrt();
      return y7.redSqr().cmp(rhs) === 0;
    };
    function Point2(curve, x9, z7) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && z7 === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN3(x9, 16);
        this.z = new BN3(z7, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint2(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point3(x9, z7) {
      return new Point2(this, x9, z7);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    };
    Point2.prototype.precompute = function precompute2() {
    };
    Point2.prototype._encode = function _encode2() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point2.fromJSON = function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1] || curve.one);
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.z.cmpn(0) === 0;
    };
    Point2.prototype.dbl = function dbl3() {
      var a4 = this.x.redAdd(this.z);
      var aa = a4.redSqr();
      var b4 = this.x.redSub(this.z);
      var bb = b4.redSqr();
      var c5 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c5.redMul(bb.redAdd(this.curve.a24.redMul(c5)));
      return this.curve.point(nx, nz);
    };
    Point2.prototype.add = function add3() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.diffAdd = function diffAdd(p5, diff) {
      var a4 = this.x.redAdd(this.z);
      var b4 = this.x.redSub(this.z);
      var c5 = p5.x.redAdd(p5.z);
      var d6 = p5.x.redSub(p5.z);
      var da = d6.redMul(a4);
      var cb = c5.redMul(b4);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point2.prototype.mul = function mul3(k7) {
      var t3 = k7.clone();
      var a4 = this;
      var b4 = this.curve.point(null, null);
      var c5 = this;
      for (var bits = []; t3.cmpn(0) !== 0; t3.iushrn(1))
        bits.push(t3.andln(1));
      for (var i5 = bits.length - 1; i5 >= 0; i5--) {
        if (bits[i5] === 0) {
          a4 = a4.diffAdd(b4, c5);
          b4 = b4.dbl();
        } else {
          b4 = a4.diffAdd(b4, c5);
          a4 = a4.dbl();
        }
      }
      return b4;
    };
    Point2.prototype.mulAdd = function mulAdd2() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.eq = function eq4(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point2.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point2.prototype.getX = function getX2() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var BN3 = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN3(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN3(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN3(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint2(x9, y7, z7, t3) {
      return this.point(x9, y7, z7, t3);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX2(x9, odd) {
      x9 = new BN3(x9, 16);
      if (!x9.red)
        x9 = x9.toRed(this.red);
      var x22 = x9.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x22));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
      var y22 = rhs.redMul(lhs.redInvm());
      var y7 = y22.redSqrt();
      if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y7.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y7 = y7.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y7, odd) {
      y7 = new BN3(y7, 16);
      if (!y7.red)
        y7 = y7.toRed(this.red);
      var y22 = y7.redSqr();
      var lhs = y22.redSub(this.c2);
      var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x22 = lhs.redMul(rhs.redInvm());
      if (x22.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y7);
      }
      var x9 = x22.redSqrt();
      if (x9.redSqr().redSub(x22).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x9.fromRed().isOdd() !== odd)
        x9 = x9.redNeg();
      return this.point(x9, y7);
    };
    EdwardsCurve.prototype.validate = function validate5(point3) {
      if (point3.isInfinity())
        return true;
      point3.normalize();
      var x22 = point3.x.redSqr();
      var y22 = point3.y.redSqr();
      var lhs = x22.redMul(this.a).redAdd(y22);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
      return lhs.cmp(rhs) === 0;
    };
    function Point2(curve, x9, y7, z7, t3) {
      Base.BasePoint.call(this, curve, "projective");
      if (x9 === null && y7 === null && z7 === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN3(x9, 16);
        this.y = new BN3(y7, 16);
        this.z = z7 ? new BN3(z7, 16) : this.curve.one;
        this.t = t3 && new BN3(t3, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
      return Point2.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point3(x9, y7, z7, t3) {
      return new Point2(this, x9, y7, z7, t3);
    };
    Point2.fromJSON = function fromJSON2(curve, obj) {
      return new Point2(curve, obj[0], obj[1], obj[2]);
    };
    Point2.prototype.inspect = function inspect4() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity3() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point2.prototype._extDbl = function _extDbl() {
      var a4 = this.x.redSqr();
      var b4 = this.y.redSqr();
      var c5 = this.z.redSqr();
      c5 = c5.redIAdd(c5);
      var d6 = this.curve._mulA(a4);
      var e4 = this.x.redAdd(this.y).redSqr().redISub(a4).redISub(b4);
      var g6 = d6.redAdd(b4);
      var f5 = g6.redSub(c5);
      var h7 = d6.redSub(b4);
      var nx = e4.redMul(f5);
      var ny = g6.redMul(h7);
      var nt4 = e4.redMul(h7);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point2.prototype._projDbl = function _projDbl() {
      var b4 = this.x.redAdd(this.y).redSqr();
      var c5 = this.x.redSqr();
      var d6 = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e4;
      var h7;
      var j6;
      if (this.curve.twisted) {
        e4 = this.curve._mulA(c5);
        var f5 = e4.redAdd(d6);
        if (this.zOne) {
          nx = b4.redSub(c5).redSub(d6).redMul(f5.redSub(this.curve.two));
          ny = f5.redMul(e4.redSub(d6));
          nz = f5.redSqr().redSub(f5).redSub(f5);
        } else {
          h7 = this.z.redSqr();
          j6 = f5.redSub(h7).redISub(h7);
          nx = b4.redSub(c5).redISub(d6).redMul(j6);
          ny = f5.redMul(e4.redSub(d6));
          nz = f5.redMul(j6);
        }
      } else {
        e4 = c5.redAdd(d6);
        h7 = this.curve._mulC(this.z).redSqr();
        j6 = e4.redSub(h7).redSub(h7);
        nx = this.curve._mulC(b4.redISub(e4)).redMul(j6);
        ny = this.curve._mulC(e4).redMul(c5.redISub(d6));
        nz = e4.redMul(j6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.dbl = function dbl3() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point2.prototype._extAdd = function _extAdd(p5) {
      var a4 = this.y.redSub(this.x).redMul(p5.y.redSub(p5.x));
      var b4 = this.y.redAdd(this.x).redMul(p5.y.redAdd(p5.x));
      var c5 = this.t.redMul(this.curve.dd).redMul(p5.t);
      var d6 = this.z.redMul(p5.z.redAdd(p5.z));
      var e4 = b4.redSub(a4);
      var f5 = d6.redSub(c5);
      var g6 = d6.redAdd(c5);
      var h7 = b4.redAdd(a4);
      var nx = e4.redMul(f5);
      var ny = g6.redMul(h7);
      var nt4 = e4.redMul(h7);
      var nz = f5.redMul(g6);
      return this.curve.point(nx, ny, nz, nt4);
    };
    Point2.prototype._projAdd = function _projAdd(p5) {
      var a4 = this.z.redMul(p5.z);
      var b4 = a4.redSqr();
      var c5 = this.x.redMul(p5.x);
      var d6 = this.y.redMul(p5.y);
      var e4 = this.curve.d.redMul(c5).redMul(d6);
      var f5 = b4.redSub(e4);
      var g6 = b4.redAdd(e4);
      var tmp = this.x.redAdd(this.y).redMul(p5.x.redAdd(p5.y)).redISub(c5).redISub(d6);
      var nx = a4.redMul(f5).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a4.redMul(g6).redMul(d6.redSub(this.curve._mulA(c5)));
        nz = f5.redMul(g6);
      } else {
        ny = a4.redMul(g6).redMul(d6.redSub(c5));
        nz = this.curve._mulC(f5).redMul(g6);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.add = function add3(p5) {
      if (this.isInfinity())
        return p5;
      if (p5.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p5);
      else
        return this._projAdd(p5);
    };
    Point2.prototype.mul = function mul3(k7) {
      if (this._hasDoubles(k7))
        return this.curve._fixedNafMul(this, k7);
      else
        return this.curve._wnafMul(this, k7);
    };
    Point2.prototype.mulAdd = function mulAdd2(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, false);
    };
    Point2.prototype.jmulAdd = function jmulAdd2(k1, p5, k22) {
      return this.curve._wnafMulAdd(1, [this, p5], [k1, k22], 2, true);
    };
    Point2.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi2 = this.z.redInvm();
      this.x = this.x.redMul(zi2);
      this.y = this.y.redMul(zi2);
      if (this.t)
        this.t = this.t.redMul(zi2);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point2.prototype.neg = function neg3() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point2.prototype.getX = function getX2() {
      this.normalize();
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY2() {
      this.normalize();
      return this.y.fromRed();
    };
    Point2.prototype.eq = function eq4(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point2.prototype.eqXToP = function eqXToP2(x9) {
      var rx = x9.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x9.clone();
      var t3 = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t3);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils6();
    var assert2 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e4) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils5();
    var assert2 = require_minimalistic_assert();
    function HmacDRBG2(options) {
      if (!(this instanceof HmacDRBG2))
        return new HmacDRBG2(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG2;
    HmacDRBG2.prototype._init = function init2(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i5 = 0; i5 < this.V.length; i5++) {
        this.K[i5] = 0;
        this.V[i5] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG2.prototype._hmac = function hmac2() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG2.prototype._update = function update2(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG2.prototype.reseed = function reseed2(entropy, entropyEnc, add3, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add3;
        add3 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add3 = utils.toArray(add3, addEnc);
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add3 || []));
      this._reseed = 1;
    };
    HmacDRBG2.prototype.generate = function generate2(len, enc, add3, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add3;
        add3 = enc;
        enc = null;
      }
      if (add3) {
        add3 = utils.toArray(add3, addEnc || "hex");
        this._update(add3);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add3);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var utils = require_utils6();
    var assert2 = utils.assert;
    function KeyPair2(ec2, options) {
      this.ec = ec2;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair2;
    KeyPair2.fromPublic = function fromPublic2(ec2, pub, enc) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair2.fromPrivate = function fromPrivate2(ec2, priv, enc) {
      if (priv instanceof KeyPair2)
        return priv;
      return new KeyPair2(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair2.prototype.validate = function validate5() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair2.prototype.getPublic = function getPublic2(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair2.prototype.getPrivate = function getPrivate2(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair2.prototype._importPrivate = function _importPrivate2(key2, enc) {
      this.priv = new BN3(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair2.prototype._importPublic = function _importPublic2(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert2(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert2(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair2.prototype.derive = function derive2(pub) {
      if (!pub.validate()) {
        assert2(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair2.prototype.sign = function sign3(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair2.prototype.verify = function verify3(msg, signature2, options) {
      return this.ec.verify(msg, signature2, this, void 0, options);
    };
    KeyPair2.prototype.inspect = function inspect4() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var utils = require_utils6();
    var assert2 = utils.assert;
    function Signature2(options, enc) {
      if (options instanceof Signature2)
        return options;
      if (this._importDER(options, enc))
        return;
      assert2(options.r && options.s, "Signature without r or s");
      this.r = new BN3(options.r, 16);
      this.s = new BN3(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature2;
    function Position2() {
      this.place = 0;
    }
    function getLength2(buf, p5) {
      var initial = buf[p5.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p5.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i5 = 0, off = p5.place; i5 < octetLen; i5++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p5.place = off;
      return val;
    }
    function rmPadding2(buf) {
      var i5 = 0;
      var len = buf.length - 1;
      while (!buf[i5] && !(buf[i5 + 1] & 128) && i5 < len) {
        i5++;
      }
      if (i5 === 0) {
        return buf;
      }
      return buf.slice(i5);
    }
    Signature2.prototype._importDER = function _importDER2(data, enc) {
      data = utils.toArray(data, enc);
      var p5 = new Position2();
      if (data[p5.place++] !== 48) {
        return false;
      }
      var len = getLength2(data, p5);
      if (len === false) {
        return false;
      }
      if (len + p5.place !== data.length) {
        return false;
      }
      if (data[p5.place++] !== 2) {
        return false;
      }
      var rlen = getLength2(data, p5);
      if (rlen === false) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var r5 = data.slice(p5.place, rlen + p5.place);
      p5.place += rlen;
      if (data[p5.place++] !== 2) {
        return false;
      }
      var slen = getLength2(data, p5);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p5.place) {
        return false;
      }
      if ((data[p5.place] & 128) !== 0) {
        return false;
      }
      var s5 = data.slice(p5.place, slen + p5.place);
      if (r5[0] === 0) {
        if (r5[1] & 128) {
          r5 = r5.slice(1);
        } else {
          return false;
        }
      }
      if (s5[0] === 0) {
        if (s5[1] & 128) {
          s5 = s5.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN3(r5);
      this.s = new BN3(s5);
      this.recoveryParam = null;
      return true;
    };
    function constructLength2(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature2.prototype.toDER = function toDER2(enc) {
      var r5 = this.r.toArray();
      var s5 = this.s.toArray();
      if (r5[0] & 128)
        r5 = [0].concat(r5);
      if (s5[0] & 128)
        s5 = [0].concat(s5);
      r5 = rmPadding2(r5);
      s5 = rmPadding2(s5);
      while (!s5[0] && !(s5[1] & 128)) {
        s5 = s5.slice(1);
      }
      var arr = [2];
      constructLength2(arr, r5.length);
      arr = arr.concat(r5);
      arr.push(2);
      constructLength2(arr, s5.length);
      var backHalf = arr.concat(s5);
      var res = [48];
      constructLength2(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var HmacDRBG2 = require_hmac_drbg();
    var utils = require_utils6();
    var curves = require_curves();
    var rand2 = require_brorand();
    var assert2 = utils.assert;
    var KeyPair2 = require_key();
    var Signature2 = require_signature();
    function EC2(options) {
      if (!(this instanceof EC2))
        return new EC2(options);
      if (typeof options === "string") {
        assert2(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC2;
    EC2.prototype.keyPair = function keyPair2(options) {
      return new KeyPair2(this, options);
    };
    EC2.prototype.keyFromPrivate = function keyFromPrivate2(priv, enc) {
      return KeyPair2.fromPrivate(this, priv, enc);
    };
    EC2.prototype.keyFromPublic = function keyFromPublic2(pub, enc) {
      return KeyPair2.fromPublic(this, pub, enc);
    };
    EC2.prototype.genKeyPair = function genKeyPair2(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG2({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand2(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN3(2));
      for (; ; ) {
        var priv = new BN3(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC2.prototype._truncateToN = function _truncateToN2(msg, truncOnly, bitLength) {
      var byteLength;
      if (BN3.isBN(msg) || typeof msg === "number") {
        msg = new BN3(msg, 16);
        byteLength = msg.byteLength();
      } else if (typeof msg === "object") {
        byteLength = msg.length;
        msg = new BN3(msg, 16);
      } else {
        var str = msg.toString();
        byteLength = str.length + 1 >>> 1;
        msg = new BN3(str, 16);
      }
      if (typeof bitLength !== "number") {
        bitLength = byteLength * 8;
      }
      var delta = bitLength - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC2.prototype.sign = function sign3(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      if (typeof msg !== "string" && typeof msg !== "number" && !BN3.isBN(msg)) {
        assert2(
          typeof msg === "object" && msg && typeof msg.length === "number",
          "Expected message to be an array-like, a hex string, or a BN instance"
        );
        assert2(msg.length >>> 0 === msg.length);
        for (var i5 = 0; i5 < msg.length; i5++)
          assert2((msg[i5] & 255) === msg[i5]);
      }
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(msg, false, options.msgBitLength);
      assert2(!msg.isNeg(), "Can not sign a negative message");
      var bytes = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      assert2(new BN3(nonce).eq(msg), "Can not sign message");
      var drbg = new HmacDRBG2({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN3(1));
      for (var iter = 0; ; iter++) {
        var k7 = options.k ? options.k(iter) : new BN3(drbg.generate(this.n.byteLength()));
        k7 = this._truncateToN(k7, true);
        if (k7.cmpn(1) <= 0 || k7.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k7);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r5 = kpX.umod(this.n);
        if (r5.cmpn(0) === 0)
          continue;
        var s5 = k7.invm(this.n).mul(r5.mul(key2.getPrivate()).iadd(msg));
        s5 = s5.umod(this.n);
        if (s5.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r5) !== 0 ? 2 : 0);
        if (options.canonical && s5.cmp(this.nh) > 0) {
          s5 = this.n.sub(s5);
          recoveryParam ^= 1;
        }
        return new Signature2({ r: r5, s: s5, recoveryParam });
      }
    };
    EC2.prototype.verify = function verify3(msg, signature2, key2, enc, options) {
      if (!options)
        options = {};
      msg = this._truncateToN(msg, false, options.msgBitLength);
      key2 = this.keyFromPublic(key2, enc);
      signature2 = new Signature2(signature2, "hex");
      var r5 = signature2.r;
      var s5 = signature2.s;
      if (r5.cmpn(1) < 0 || r5.cmp(this.n) >= 0)
        return false;
      if (s5.cmpn(1) < 0 || s5.cmp(this.n) >= 0)
        return false;
      var sinv = s5.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u22 = sinv.mul(r5).umod(this.n);
      var p5;
      if (!this.curve._maxwellTrick) {
        p5 = this.g.mulAdd(u1, key2.getPublic(), u22);
        if (p5.isInfinity())
          return false;
        return p5.getX().umod(this.n).cmp(r5) === 0;
      }
      p5 = this.g.jmulAdd(u1, key2.getPublic(), u22);
      if (p5.isInfinity())
        return false;
      return p5.eqXToP(r5);
    };
    EC2.prototype.recoverPubKey = function(msg, signature2, j6, enc) {
      assert2((3 & j6) === j6, "The recovery param is more than two bits");
      signature2 = new Signature2(signature2, enc);
      var n6 = this.n;
      var e4 = new BN3(msg);
      var r5 = signature2.r;
      var s5 = signature2.s;
      var isYOdd = j6 & 1;
      var isSecondKey = j6 >> 1;
      if (r5.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r5 = this.curve.pointFromX(r5.add(this.curve.n), isYOdd);
      else
        r5 = this.curve.pointFromX(r5, isYOdd);
      var rInv = signature2.r.invm(n6);
      var s1 = n6.sub(e4).mul(rInv).umod(n6);
      var s22 = s5.mul(rInv).umod(n6);
      return this.g.mulAdd(s1, r5, s22);
    };
    EC2.prototype.getKeyRecoveryParam = function(e4, signature2, Q5, enc) {
      signature2 = new Signature2(signature2, enc);
      if (signature2.recoveryParam !== null)
        return signature2.recoveryParam;
      for (var i5 = 0; i5 < 4; i5++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e4, signature2, i5);
        } catch (e5) {
          continue;
        }
        if (Qprime.eq(Q5))
          return i5;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils6();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair2(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair2.fromPublic = function fromPublic2(eddsa, pub) {
      if (pub instanceof KeyPair2)
        return pub;
      return new KeyPair2(eddsa, { pub });
    };
    KeyPair2.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair2)
        return secret;
      return new KeyPair2(eddsa, { secret });
    };
    KeyPair2.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair2, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair2, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair2, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a4 = hash2.slice(0, eddsa.encodingLength);
      a4[0] &= 248;
      a4[lastIx] &= 127;
      a4[lastIx] |= 64;
      return a4;
    });
    cachedProperty(KeyPair2, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair2, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair2, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair2.prototype.sign = function sign3(message) {
      assert2(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair2.prototype.verify = function verify3(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair2.prototype.getSecret = function getSecret(enc) {
      assert2(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair2.prototype.getPublic = function getPublic2(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair2;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN3 = require_bn2();
    var utils = require_utils6();
    var assert2 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature2(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert2(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert2(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN3)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature2, "S", function S4() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature2, "R", function R3() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature2, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature2, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature2.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature2.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature2;
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils6();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair2 = require_key2();
    var Signature2 = require_signature2();
    function EDDSA(curve) {
      assert2(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign3(message, secret) {
      message = parseBytes(message);
      var key2 = this.keyFromSecret(secret);
      var r5 = this.hashInt(key2.messagePrefix(), message);
      var R3 = this.g.mul(r5);
      var Rencoded = this.encodePoint(R3);
      var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
      var S4 = r5.add(s_).umod(this.curve.n);
      return this.makeSignature({ R: R3, S: S4, Rencoded });
    };
    EDDSA.prototype.verify = function verify3(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key2 = this.keyFromPublic(pub);
      var h7 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key2.pub().mul(h7));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i5 = 0; i5 < arguments.length; i5++)
        hash3.update(arguments[i5]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic2(pub) {
      return KeyPair2.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair2.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature2)
        return sig;
      return new Signature2(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point3) {
      var enc = point3.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point3.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint2(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y7 = utils.intFromLE(normed);
      return this.curve.pointFromY(y7, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/.pnpm/elliptic@6.6.1/node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils6();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/.pnpm/@walletconnect+environment@1.0.1/node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/.pnpm/ws@7.5.9_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/ws@7.5.9_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e4) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset = array.length;
      while (++index < length2) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n6, iteratee) {
      var index = -1, result = Array(n6);
      while (++index < n6) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size = data.size;
      data.set(key2, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function assocIndexOf(array, key2) {
      var length2 = array.length;
      while (length2--) {
        if (eq4(array[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq4(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key2) {
      var data = map.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e4) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e4) {
        }
        try {
          return func + "";
        } catch (e4) {
        }
      }
      return "";
    }
    function eq4(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/.pnpm/@jnwng+walletconnect-solana@0.2.0_@react-native-async-storage+async-storage@1.24.0_react-nati_zpi2ztbgjwb3tlevgvxfiessg4/node_modules/@jnwng/walletconnect-solana/lib/esm/adapter.js
init_index_browser_esm();
var import_qrcode_modal = __toESM(require_cjs3(), 1);

// node_modules/.pnpm/@walletconnect+core@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.77_rzhbh6h45w5w3zg6quyi3j7toq/node_modules/@walletconnect/core/dist/index.es.js
init_events();

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.2/node_modules/@walletconnect/heartbeat/dist/index.es.js
init_events();
var import_time = __toESM(require_cjs4());

// node_modules/.pnpm/@walletconnect+events@1.0.1/node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// node_modules/.pnpm/@walletconnect+heartbeat@1.2.2/node_modules/@walletconnect/heartbeat/dist/index.es.js
var n2 = class extends IEvents {
  constructor(e4) {
    super();
  }
};
var s3 = import_time.FIVE_SECONDS;
var r3 = { pulse: "heartbeat_pulse" };
var i3 = class extends n2 {
  constructor(e4) {
    super(e4), this.events = new EventEmitter(), this.interval = s3, this.interval = e4?.interval || s3;
  }
  static async init(e4) {
    const t3 = new i3(e4);
    return await t3.init(), t3;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e4, t3) {
    this.events.on(e4, t3);
  }
  once(e4, t3) {
    this.events.once(e4, t3);
  }
  off(e4, t3) {
    this.events.off(e4, t3);
  }
  removeListener(e4, t3) {
    this.events.removeListener(e4, t3);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r3.pulse);
  }
};

// node_modules/.pnpm/destr@2.0.3/node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key2, value) {
  if (key2 === "__proto__" || key2 === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key2);
    return;
  }
  return value;
}
function warnKeyDropped(key2) {
  console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/.pnpm/unstorage@1.14.4_idb-keyval@6.2.1_ioredis@5.4.2/node_modules/unstorage/dist/shared/unstorage.BqzpVTXx.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c5) => c5.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key2) {
  if (!key2) {
    return "";
  }
  return key2.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}

// node_modules/.pnpm/unstorage@1.14.4_idb-keyval@6.2.1_ioredis@5.4.2/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key2) {
      return data.has(key2);
    },
    getItem(key2) {
      return data.get(key2) ?? null;
    },
    getItemRaw(key2) {
      return data.get(key2) ?? null;
    },
    setItem(key2, value) {
      data.set(key2, value);
    },
    setItemRaw(key2, value) {
      data.set(key2, value);
    },
    removeItem(key2) {
      data.delete(key2);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key2) => {
    for (const base3 of context.mountpoints) {
      if (key2.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key2.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key2,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key2) => {
    if (!context.watching) {
      return;
    }
    key2 = normalizeKey(key2);
    for (const listener of context.watchListeners) {
      listener(event, key2);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key2 = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key2);
      getBatch(mount).items.push({
        key: key2,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r5) => r5.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r5) => r5.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2, opts);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async removeItem(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key2);
      }
    },
    // Meta
    async getMeta(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key2, value, opts = {}) {
      return this.setItem(key2 + "$", value, opts);
    },
    removeMeta(key2, opts = {}) {
      return this.removeItem(key2 + "$", opts);
    },
    // Keys
    async getKeys(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key2 of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key2);
          if (!maskedMounts.some((p5) => fullKey.startsWith(p5))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p5) => !p5.startsWith(mount.mountpoint))
        ];
      }
      return base3 ? allKeys.filter(
        (key2) => key2.startsWith(base3) && key2[key2.length - 1] !== "$"
      ) : allKeys.filter((key2) => key2[key2.length - 1] !== "$");
    },
    // Utils
    async clear(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m4) => {
          if (m4.driver.clear) {
            return asyncCall(m4.driver.clear, m4.relativeBase, opts);
          }
          if (m4.driver.removeItem) {
            const keys2 = await m4.driver.getKeys(m4.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key2) => m4.driver.removeItem(key2, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a4, b4) => b4.length - a4.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base3, _dispose = true) {
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        context.unwatch[base3]?.();
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key2) => key2 !== base3);
      delete context.mounts[base3];
    },
    getMount(key2 = "") {
      key2 = normalizeKey(key2) + ":";
      const m4 = getMount(key2);
      return {
        driver: m4.driver,
        base: m4.base
      };
    },
    getMounts(base3 = "", opts = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts.parents);
      return mounts.map((m4) => ({
        driver: m4.driver,
        base: m4.mountpoint
      }));
    },
    // Aliases
    keys: (base3, opts = {}) => storage.getKeys(base3, opts),
    get: (key2, opts = {}) => storage.getItem(key2, opts),
    set: (key2, value, opts = {}) => storage.setItem(key2, value, opts),
    has: (key2, opts = {}) => storage.hasItem(key2, opts),
    del: (key2, opts = {}) => storage.removeItem(key2, opts),
    remove: (key2, opts = {}) => storage.removeItem(key2, opts)
  };
  return storage;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key2) => onChange(event, base3 + key2)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/.pnpm/idb-keyval@6.2.1/node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key2, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
}
function set(key2, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key2);
    return promisifyRequest(store.transaction);
  });
}
function del(key2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key2);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/.pnpm/@walletconnect+safe-json@1.0.2/node_modules/@walletconnect/safe-json/dist/esm/index.js
var JSONStringify = (data) => JSON.stringify(data, (_7, value) => typeof value === "bigint" ? value.toString() + "n" : value);
var JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_7, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse3(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify3(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}

// node_modules/.pnpm/@walletconnect+keyvaluestorage@1.1.1_@react-native-async-storage+async-storage@1.24.0_react-n_a366gli6h4w3bpkfn2qrtdpsoi/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x3 = "idb-keyval";
var z3 = (i5 = {}) => {
  const t3 = i5.base && i5.base.length > 0 ? `${i5.base}:` : "", e4 = (s5) => t3 + s5;
  let n6;
  return i5.dbName && i5.storeName && (n6 = createStore(i5.dbName, i5.storeName)), { name: x3, options: i5, async hasItem(s5) {
    return !(typeof await get(e4(s5), n6) > "u");
  }, async getItem(s5) {
    return await get(e4(s5), n6) ?? null;
  }, setItem(s5, a4) {
    return set(e4(s5), a4, n6);
  }, removeItem(s5) {
    return del(e4(s5), n6);
  }, getKeys() {
    return keys(n6);
  }, clear() {
    return clear(n6);
  } };
};
var D3 = "WALLET_CONNECT_V2_INDEXED_DB";
var E4 = "keyvaluestorage";
var _4 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z3({ dbName: D3, storeName: E4 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t3) => [t3.key, t3.value]);
  }
  async getItem(t3) {
    const e4 = await this.indexedDb.getItem(t3);
    if (e4 !== null)
      return e4;
  }
  async setItem(t3, e4) {
    await this.indexedDb.setItem(t3, safeJsonStringify3(e4));
  }
  async removeItem(t3) {
    await this.indexedDb.removeItem(t3);
  }
};
var l4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
var c3 = { exports: {} };
(function() {
  let i5;
  function t3() {
  }
  i5 = t3, i5.prototype.getItem = function(e4) {
    return this.hasOwnProperty(e4) ? String(this[e4]) : null;
  }, i5.prototype.setItem = function(e4, n6) {
    this[e4] = String(n6);
  }, i5.prototype.removeItem = function(e4) {
    delete this[e4];
  }, i5.prototype.clear = function() {
    const e4 = this;
    Object.keys(e4).forEach(function(n6) {
      e4[n6] = void 0, delete e4[n6];
    });
  }, i5.prototype.key = function(e4) {
    return e4 = e4 || 0, Object.keys(this)[e4];
  }, i5.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l4 < "u" && l4.localStorage ? c3.exports = l4.localStorage : typeof window < "u" && window.localStorage ? c3.exports = window.localStorage : c3.exports = new t3();
})();
function k3(i5) {
  var t3;
  return [i5[0], safeJsonParse3((t3 = i5[1]) != null ? t3 : "")];
}
var K2 = class {
  constructor() {
    this.localStorage = c3.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k3);
  }
  async getItem(t3) {
    const e4 = this.localStorage.getItem(t3);
    if (e4 !== null)
      return safeJsonParse3(e4);
  }
  async setItem(t3, e4) {
    this.localStorage.setItem(t3, safeJsonStringify3(e4));
  }
  async removeItem(t3) {
    this.localStorage.removeItem(t3);
  }
};
var N3 = "wc_storage_version";
var y4 = 1;
var O2 = async (i5, t3, e4) => {
  const n6 = N3, s5 = await t3.getItem(n6);
  if (s5 && s5 >= y4) {
    e4(t3);
    return;
  }
  const a4 = await i5.getKeys();
  if (!a4.length) {
    e4(t3);
    return;
  }
  const m4 = [];
  for (; a4.length; ) {
    const r5 = a4.shift();
    if (!r5)
      continue;
    const o6 = r5.toLowerCase();
    if (o6.includes("wc@") || o6.includes("walletconnect") || o6.includes("wc_") || o6.includes("wallet_connect")) {
      const f5 = await i5.getItem(r5);
      await t3.setItem(r5, f5), m4.push(r5);
    }
  }
  await t3.setItem(n6, y4), e4(t3), j3(i5, m4);
};
var j3 = async (i5, t3) => {
  t3.length && t3.forEach(async (e4) => {
    await i5.removeItem(e4);
  });
};
var h3 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e4) => {
      this.storage = e4, this.initialized = true;
    };
    const t3 = new K2();
    this.storage = t3;
    try {
      const e4 = new _4();
      O2(t3, e4, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t3) {
    return await this.initialize(), this.storage.getItem(t3);
  }
  async setItem(t3, e4) {
    return await this.initialize(), this.storage.setItem(t3, e4);
  }
  async removeItem(t3) {
    return await this.initialize(), this.storage.removeItem(t3);
  }
  async initialize() {
    this.initialized || await new Promise((t3) => {
      const e4 = setInterval(() => {
        this.initialized && (clearInterval(e4), t3());
      }, 20);
    });
  }
};

// node_modules/.pnpm/@walletconnect+logger@2.1.2/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser2());
var import_pino2 = __toESM(require_browser2());
var c4 = { level: "info" };
var n3 = "custom_context";
var l5 = 1e3 * 1024;
var O3 = class {
  constructor(e4) {
    this.nodeValue = e4, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d3 = class {
  constructor(e4) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e4, this.sizeInBytes = 0;
  }
  append(e4) {
    const t3 = new O3(e4);
    if (t3.size > this.maxSizeInBytes)
      throw new Error(`[LinkedList] Value too big to insert into list: ${e4} with size ${t3.size}`);
    for (; this.size + t3.size > this.maxSizeInBytes; )
      this.shift();
    this.head ? (this.tail && (this.tail.next = t3), this.tail = t3) : (this.head = t3, this.tail = t3), this.lengthInNodes++, this.sizeInBytes += t3.size;
  }
  shift() {
    if (!this.head)
      return;
    const e4 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e4.size;
  }
  toArray() {
    const e4 = [];
    let t3 = this.head;
    for (; t3 !== null; )
      e4.push(t3.value), t3 = t3.next;
    return e4;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e4 = this.head;
    return { next: () => {
      if (!e4)
        return { done: true, value: null };
      const t3 = e4.value;
      return e4 = e4.next, { done: false, value: t3 };
    } };
  }
};
var L3 = class {
  constructor(e4, t3 = l5) {
    this.level = e4 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t3, this.logs = new d3(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e4, t3) {
    t3 === import_pino.levels.values.error ? console.error(e4) : t3 === import_pino.levels.values.warn ? console.warn(e4) : t3 === import_pino.levels.values.debug ? console.debug(e4) : t3 === import_pino.levels.values.trace ? console.trace(e4) : console.log(e4);
  }
  appendToLogs(e4) {
    this.logs.append(safeJsonStringify3({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e4 }));
    const t3 = typeof e4 == "string" ? JSON.parse(e4).level : e4.level;
    t3 >= this.levelValue && this.forwardToConsole(e4, t3);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d3(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e4) {
    const t3 = this.getLogArray();
    return t3.push(safeJsonStringify3({ extraMetadata: e4 })), new Blob(t3, { type: "application/json" });
  }
};
var m3 = class {
  constructor(e4, t3 = l5) {
    this.baseChunkLogger = new L3(e4, t3);
  }
  write(e4) {
    this.baseChunkLogger.appendToLogs(e4);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e4) {
    return this.baseChunkLogger.logsToBlob(e4);
  }
  downloadLogsBlobInBrowser(e4) {
    const t3 = URL.createObjectURL(this.logsToBlob(e4)), o6 = document.createElement("a");
    o6.href = t3, o6.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o6), o6.click(), document.body.removeChild(o6), URL.revokeObjectURL(t3);
  }
};
var B2 = class {
  constructor(e4, t3 = l5) {
    this.baseChunkLogger = new L3(e4, t3);
  }
  write(e4) {
    this.baseChunkLogger.appendToLogs(e4);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e4) {
    return this.baseChunkLogger.logsToBlob(e4);
  }
};
var x4 = Object.defineProperty;
var S2 = Object.defineProperties;
var _5 = Object.getOwnPropertyDescriptors;
var p3 = Object.getOwnPropertySymbols;
var T4 = Object.prototype.hasOwnProperty;
var z4 = Object.prototype.propertyIsEnumerable;
var f3 = (r5, e4, t3) => e4 in r5 ? x4(r5, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : r5[e4] = t3;
var i4 = (r5, e4) => {
  for (var t3 in e4 || (e4 = {}))
    T4.call(e4, t3) && f3(r5, t3, e4[t3]);
  if (p3)
    for (var t3 of p3(e4))
      z4.call(e4, t3) && f3(r5, t3, e4[t3]);
  return r5;
};
var g3 = (r5, e4) => S2(r5, _5(e4));
function k4(r5) {
  return g3(i4({}, r5), { level: r5?.level || c4.level });
}
function v3(r5, e4 = n3) {
  return r5[e4] || "";
}
function b2(r5, e4, t3 = n3) {
  return r5[t3] = e4, r5;
}
function y5(r5, e4 = n3) {
  let t3 = "";
  return typeof r5.bindings > "u" ? t3 = v3(r5, e4) : t3 = r5.bindings().context || "", t3;
}
function w4(r5, e4, t3 = n3) {
  const o6 = y5(r5, t3);
  return o6.trim() ? `${o6}/${e4}` : e4;
}
function E5(r5, e4, t3 = n3) {
  const o6 = w4(r5, e4, t3), a4 = r5.child({ context: o6 });
  return b2(a4, o6, t3);
}
function C3(r5) {
  var e4, t3;
  const o6 = new m3((e4 = r5.opts) == null ? void 0 : e4.level, r5.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g3(i4({}, r5.opts), { level: "trace", browser: g3(i4({}, (t3 = r5.opts) == null ? void 0 : t3.browser), { write: (a4) => o6.write(a4) }) })), chunkLoggerController: o6 };
}
function I3(r5) {
  var e4;
  const t3 = new B2((e4 = r5.opts) == null ? void 0 : e4.level, r5.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g3(i4({}, r5.opts), { level: "trace" }), t3), chunkLoggerController: t3 };
}
function A4(r5) {
  return typeof r5.loggerOverride < "u" && typeof r5.loggerOverride != "string" ? { logger: r5.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C3(r5) : I3(r5);
}

// node_modules/.pnpm/@walletconnect+types@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.7_bps4kbgsairipd6giqlgkgeuty/node_modules/@walletconnect/types/dist/index.es.js
var n4 = class extends IEvents {
  constructor(s5) {
    super(), this.opts = s5, this.protocol = "wc", this.version = 2;
  }
};
var h5 = class extends IEvents {
  constructor(s5, t3) {
    super(), this.core = s5, this.logger = t3, this.records = /* @__PURE__ */ new Map();
  }
};
var a3 = class {
  constructor(s5, t3) {
    this.logger = s5, this.core = t3;
  }
};
var g4 = class extends IEvents {
  constructor(s5, t3) {
    super(), this.relayer = s5, this.logger = t3;
  }
};
var u3 = class extends IEvents {
  constructor(s5) {
    super();
  }
};
var p4 = class {
  constructor(s5, t3, e4, f5) {
    this.core = s5, this.logger = t3, this.name = e4;
  }
};
var d4 = class extends IEvents {
  constructor(s5, t3) {
    super(), this.relayer = s5, this.logger = t3;
  }
};
var x5 = class extends IEvents {
  constructor(s5, t3) {
    super(), this.core = s5, this.logger = t3;
  }
};
var y6 = class {
  constructor(s5, t3, e4) {
    this.core = s5, this.logger = t3, this.store = e4;
  }
};
var v4 = class {
  constructor(s5, t3) {
    this.projectId = s5, this.logger = t3;
  }
};
var C4 = class {
  constructor(s5, t3, e4) {
    this.core = s5, this.logger = t3, this.telemetryEnabled = e4;
  }
};
var S3 = class {
  constructor(s5) {
    this.opts = s5, this.protocol = "wc", this.version = 2;
  }
};
var M3 = class {
  constructor(s5) {
    this.client = s5;
  }
};

// node_modules/.pnpm/@walletconnect+core@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.77_rzhbh6h45w5w3zg6quyi3j7toq/node_modules/@walletconnect/core/dist/index.es.js
var import_time4 = __toESM(require_cjs4());

// node_modules/.pnpm/@walletconnect+relay-auth@1.1.0/node_modules/@walletconnect/relay-auth/dist/index.es.js
var import_time2 = __toESM(require_cjs4());
function En(t3) {
  return t3 instanceof Uint8Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint8Array";
}
function fe(t3, ...e4) {
  if (!En(t3))
    throw new Error("Uint8Array expected");
  if (e4.length > 0 && !e4.includes(t3.length))
    throw new Error("Uint8Array expected of length " + e4 + ", got length=" + t3.length);
}
function De(t3, e4 = true) {
  if (t3.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e4 && t3.finished)
    throw new Error("Hash#digest() has already been called");
}
function gn(t3, e4) {
  fe(t3);
  const n6 = e4.outputLen;
  if (t3.length < n6)
    throw new Error("digestInto() expects output buffer of length at least " + n6);
}
var it = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var _t = (t3) => new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
function yn(t3) {
  if (typeof t3 != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t3);
  return new Uint8Array(new TextEncoder().encode(t3));
}
function de(t3) {
  return typeof t3 == "string" && (t3 = yn(t3)), fe(t3), t3;
}
var xn = class {
  clone() {
    return this._cloneInto();
  }
};
function Bn(t3) {
  const e4 = (r5) => t3().update(de(r5)).digest(), n6 = t3();
  return e4.outputLen = n6.outputLen, e4.blockLen = n6.blockLen, e4.create = () => t3(), e4;
}
function he(t3 = 32) {
  if (it && typeof it.getRandomValues == "function")
    return it.getRandomValues(new Uint8Array(t3));
  if (it && typeof it.randomBytes == "function")
    return it.randomBytes(t3);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn(t3, e4, n6, r5) {
  if (typeof t3.setBigUint64 == "function")
    return t3.setBigUint64(e4, n6, r5);
  const o6 = BigInt(32), s5 = BigInt(4294967295), a4 = Number(n6 >> o6 & s5), u4 = Number(n6 & s5), i5 = r5 ? 4 : 0, D5 = r5 ? 0 : 4;
  t3.setUint32(e4 + i5, a4, r5), t3.setUint32(e4 + D5, u4, r5);
}
var An = class extends xn {
  constructor(e4, n6, r5, o6) {
    super(), this.blockLen = e4, this.outputLen = n6, this.padOffset = r5, this.isLE = o6, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e4), this.view = _t(this.buffer);
  }
  update(e4) {
    De(this);
    const { view: n6, buffer: r5, blockLen: o6 } = this;
    e4 = de(e4);
    const s5 = e4.length;
    for (let a4 = 0; a4 < s5; ) {
      const u4 = Math.min(o6 - this.pos, s5 - a4);
      if (u4 === o6) {
        const i5 = _t(e4);
        for (; o6 <= s5 - a4; a4 += o6)
          this.process(i5, a4);
        continue;
      }
      r5.set(e4.subarray(a4, a4 + u4), this.pos), this.pos += u4, a4 += u4, this.pos === o6 && (this.process(n6, 0), this.pos = 0);
    }
    return this.length += e4.length, this.roundClean(), this;
  }
  digestInto(e4) {
    De(this), gn(e4, this), this.finished = true;
    const { buffer: n6, view: r5, blockLen: o6, isLE: s5 } = this;
    let { pos: a4 } = this;
    n6[a4++] = 128, this.buffer.subarray(a4).fill(0), this.padOffset > o6 - a4 && (this.process(r5, 0), a4 = 0);
    for (let l6 = a4; l6 < o6; l6++)
      n6[l6] = 0;
    Cn(r5, o6 - 8, BigInt(this.length * 8), s5), this.process(r5, 0);
    const u4 = _t(e4), i5 = this.outputLen;
    if (i5 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const D5 = i5 / 4, c5 = this.get();
    if (D5 > c5.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l6 = 0; l6 < D5; l6++)
      u4.setUint32(4 * l6, c5[l6], s5);
  }
  digest() {
    const { buffer: e4, outputLen: n6 } = this;
    this.digestInto(e4);
    const r5 = e4.slice(0, n6);
    return this.destroy(), r5;
  }
  _cloneInto(e4) {
    e4 || (e4 = new this.constructor()), e4.set(...this.get());
    const { blockLen: n6, buffer: r5, length: o6, finished: s5, destroyed: a4, pos: u4 } = this;
    return e4.length = o6, e4.pos = u4, e4.finished = s5, e4.destroyed = a4, o6 % n6 && e4.buffer.set(r5), e4;
  }
};
var wt = BigInt(2 ** 32 - 1);
var St = BigInt(32);
function le(t3, e4 = false) {
  return e4 ? { h: Number(t3 & wt), l: Number(t3 >> St & wt) } : { h: Number(t3 >> St & wt) | 0, l: Number(t3 & wt) | 0 };
}
function mn(t3, e4 = false) {
  let n6 = new Uint32Array(t3.length), r5 = new Uint32Array(t3.length);
  for (let o6 = 0; o6 < t3.length; o6++) {
    const { h: s5, l: a4 } = le(t3[o6], e4);
    [n6[o6], r5[o6]] = [s5, a4];
  }
  return [n6, r5];
}
var _n = (t3, e4) => BigInt(t3 >>> 0) << St | BigInt(e4 >>> 0);
var Sn = (t3, e4, n6) => t3 >>> n6;
var vn = (t3, e4, n6) => t3 << 32 - n6 | e4 >>> n6;
var In = (t3, e4, n6) => t3 >>> n6 | e4 << 32 - n6;
var Un = (t3, e4, n6) => t3 << 32 - n6 | e4 >>> n6;
var Tn = (t3, e4, n6) => t3 << 64 - n6 | e4 >>> n6 - 32;
var Fn = (t3, e4, n6) => t3 >>> n6 - 32 | e4 << 64 - n6;
var Nn = (t3, e4) => e4;
var Ln = (t3, e4) => t3;
var On = (t3, e4, n6) => t3 << n6 | e4 >>> 32 - n6;
var Hn = (t3, e4, n6) => e4 << n6 | t3 >>> 32 - n6;
var zn = (t3, e4, n6) => e4 << n6 - 32 | t3 >>> 64 - n6;
var Mn = (t3, e4, n6) => t3 << n6 - 32 | e4 >>> 64 - n6;
function qn(t3, e4, n6, r5) {
  const o6 = (e4 >>> 0) + (r5 >>> 0);
  return { h: t3 + n6 + (o6 / 2 ** 32 | 0) | 0, l: o6 | 0 };
}
var $n = (t3, e4, n6) => (t3 >>> 0) + (e4 >>> 0) + (n6 >>> 0);
var kn = (t3, e4, n6, r5) => e4 + n6 + r5 + (t3 / 2 ** 32 | 0) | 0;
var Rn = (t3, e4, n6, r5) => (t3 >>> 0) + (e4 >>> 0) + (n6 >>> 0) + (r5 >>> 0);
var jn = (t3, e4, n6, r5, o6) => e4 + n6 + r5 + o6 + (t3 / 2 ** 32 | 0) | 0;
var Zn = (t3, e4, n6, r5, o6) => (t3 >>> 0) + (e4 >>> 0) + (n6 >>> 0) + (r5 >>> 0) + (o6 >>> 0);
var Gn = (t3, e4, n6, r5, o6, s5) => e4 + n6 + r5 + o6 + s5 + (t3 / 2 ** 32 | 0) | 0;
var x6 = { fromBig: le, split: mn, toBig: _n, shrSH: Sn, shrSL: vn, rotrSH: In, rotrSL: Un, rotrBH: Tn, rotrBL: Fn, rotr32H: Nn, rotr32L: Ln, rotlSH: On, rotlSL: Hn, rotlBH: zn, rotlBL: Mn, add: qn, add3L: $n, add3H: kn, add4L: Rn, add4H: jn, add5H: Gn, add5L: Zn };
var [Vn, Yn] = (() => x6.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t3) => BigInt(t3))))();
var P3 = new Uint32Array(80);
var Q2 = new Uint32Array(80);
var Jn = class extends An {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e4, Al: n6, Bh: r5, Bl: o6, Ch: s5, Cl: a4, Dh: u4, Dl: i5, Eh: D5, El: c5, Fh: l6, Fl: p5, Gh: w6, Gl: h7, Hh: g6, Hl: S4 } = this;
    return [e4, n6, r5, o6, s5, a4, u4, i5, D5, c5, l6, p5, w6, h7, g6, S4];
  }
  set(e4, n6, r5, o6, s5, a4, u4, i5, D5, c5, l6, p5, w6, h7, g6, S4) {
    this.Ah = e4 | 0, this.Al = n6 | 0, this.Bh = r5 | 0, this.Bl = o6 | 0, this.Ch = s5 | 0, this.Cl = a4 | 0, this.Dh = u4 | 0, this.Dl = i5 | 0, this.Eh = D5 | 0, this.El = c5 | 0, this.Fh = l6 | 0, this.Fl = p5 | 0, this.Gh = w6 | 0, this.Gl = h7 | 0, this.Hh = g6 | 0, this.Hl = S4 | 0;
  }
  process(e4, n6) {
    for (let d6 = 0; d6 < 16; d6++, n6 += 4)
      P3[d6] = e4.getUint32(n6), Q2[d6] = e4.getUint32(n6 += 4);
    for (let d6 = 16; d6 < 80; d6++) {
      const m4 = P3[d6 - 15] | 0, F5 = Q2[d6 - 15] | 0, q4 = x6.rotrSH(m4, F5, 1) ^ x6.rotrSH(m4, F5, 8) ^ x6.shrSH(m4, F5, 7), z7 = x6.rotrSL(m4, F5, 1) ^ x6.rotrSL(m4, F5, 8) ^ x6.shrSL(m4, F5, 7), I5 = P3[d6 - 2] | 0, O4 = Q2[d6 - 2] | 0, ot4 = x6.rotrSH(I5, O4, 19) ^ x6.rotrBH(I5, O4, 61) ^ x6.shrSH(I5, O4, 6), tt3 = x6.rotrSL(I5, O4, 19) ^ x6.rotrBL(I5, O4, 61) ^ x6.shrSL(I5, O4, 6), st3 = x6.add4L(z7, tt3, Q2[d6 - 7], Q2[d6 - 16]), at4 = x6.add4H(st3, q4, ot4, P3[d6 - 7], P3[d6 - 16]);
      P3[d6] = at4 | 0, Q2[d6] = st3 | 0;
    }
    let { Ah: r5, Al: o6, Bh: s5, Bl: a4, Ch: u4, Cl: i5, Dh: D5, Dl: c5, Eh: l6, El: p5, Fh: w6, Fl: h7, Gh: g6, Gl: S4, Hh: v8, Hl: L5 } = this;
    for (let d6 = 0; d6 < 80; d6++) {
      const m4 = x6.rotrSH(l6, p5, 14) ^ x6.rotrSH(l6, p5, 18) ^ x6.rotrBH(l6, p5, 41), F5 = x6.rotrSL(l6, p5, 14) ^ x6.rotrSL(l6, p5, 18) ^ x6.rotrBL(l6, p5, 41), q4 = l6 & w6 ^ ~l6 & g6, z7 = p5 & h7 ^ ~p5 & S4, I5 = x6.add5L(L5, F5, z7, Yn[d6], Q2[d6]), O4 = x6.add5H(I5, v8, m4, q4, Vn[d6], P3[d6]), ot4 = I5 | 0, tt3 = x6.rotrSH(r5, o6, 28) ^ x6.rotrBH(r5, o6, 34) ^ x6.rotrBH(r5, o6, 39), st3 = x6.rotrSL(r5, o6, 28) ^ x6.rotrBL(r5, o6, 34) ^ x6.rotrBL(r5, o6, 39), at4 = r5 & s5 ^ r5 & u4 ^ s5 & u4, Ct4 = o6 & a4 ^ o6 & i5 ^ a4 & i5;
      v8 = g6 | 0, L5 = S4 | 0, g6 = w6 | 0, S4 = h7 | 0, w6 = l6 | 0, h7 = p5 | 0, { h: l6, l: p5 } = x6.add(D5 | 0, c5 | 0, O4 | 0, ot4 | 0), D5 = u4 | 0, c5 = i5 | 0, u4 = s5 | 0, i5 = a4 | 0, s5 = r5 | 0, a4 = o6 | 0;
      const At3 = x6.add3L(ot4, st3, Ct4);
      r5 = x6.add3H(At3, O4, tt3, at4), o6 = At3 | 0;
    }
    ({ h: r5, l: o6 } = x6.add(this.Ah | 0, this.Al | 0, r5 | 0, o6 | 0)), { h: s5, l: a4 } = x6.add(this.Bh | 0, this.Bl | 0, s5 | 0, a4 | 0), { h: u4, l: i5 } = x6.add(this.Ch | 0, this.Cl | 0, u4 | 0, i5 | 0), { h: D5, l: c5 } = x6.add(this.Dh | 0, this.Dl | 0, D5 | 0, c5 | 0), { h: l6, l: p5 } = x6.add(this.Eh | 0, this.El | 0, l6 | 0, p5 | 0), { h: w6, l: h7 } = x6.add(this.Fh | 0, this.Fl | 0, w6 | 0, h7 | 0), { h: g6, l: S4 } = x6.add(this.Gh | 0, this.Gl | 0, g6 | 0, S4 | 0), { h: v8, l: L5 } = x6.add(this.Hh | 0, this.Hl | 0, v8 | 0, L5 | 0), this.set(r5, o6, s5, a4, u4, i5, D5, c5, l6, p5, w6, h7, g6, S4, v8, L5);
  }
  roundClean() {
    P3.fill(0), Q2.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Kn = Bn(() => new Jn());
var vt = BigInt(0);
var be = BigInt(1);
var Wn = BigInt(2);
function It(t3) {
  return t3 instanceof Uint8Array || ArrayBuffer.isView(t3) && t3.constructor.name === "Uint8Array";
}
function Ut(t3) {
  if (!It(t3))
    throw new Error("Uint8Array expected");
}
function Tt(t3, e4) {
  if (typeof e4 != "boolean")
    throw new Error(t3 + " boolean expected, got " + e4);
}
var Xn = Array.from({ length: 256 }, (t3, e4) => e4.toString(16).padStart(2, "0"));
function Ft(t3) {
  Ut(t3);
  let e4 = "";
  for (let n6 = 0; n6 < t3.length; n6++)
    e4 += Xn[t3[n6]];
  return e4;
}
function pe(t3) {
  if (typeof t3 != "string")
    throw new Error("hex string expected, got " + typeof t3);
  return t3 === "" ? vt : BigInt("0x" + t3);
}
var K3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function we(t3) {
  if (t3 >= K3._0 && t3 <= K3._9)
    return t3 - K3._0;
  if (t3 >= K3.A && t3 <= K3.F)
    return t3 - (K3.A - 10);
  if (t3 >= K3.a && t3 <= K3.f)
    return t3 - (K3.a - 10);
}
function Ee(t3) {
  if (typeof t3 != "string")
    throw new Error("hex string expected, got " + typeof t3);
  const e4 = t3.length, n6 = e4 / 2;
  if (e4 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e4);
  const r5 = new Uint8Array(n6);
  for (let o6 = 0, s5 = 0; o6 < n6; o6++, s5 += 2) {
    const a4 = we(t3.charCodeAt(s5)), u4 = we(t3.charCodeAt(s5 + 1));
    if (a4 === void 0 || u4 === void 0) {
      const i5 = t3[s5] + t3[s5 + 1];
      throw new Error('hex string expected, got non-hex character "' + i5 + '" at index ' + s5);
    }
    r5[o6] = a4 * 16 + u4;
  }
  return r5;
}
function Pn(t3) {
  return pe(Ft(t3));
}
function Et(t3) {
  return Ut(t3), pe(Ft(Uint8Array.from(t3).reverse()));
}
function ge(t3, e4) {
  return Ee(t3.toString(16).padStart(e4 * 2, "0"));
}
function Nt(t3, e4) {
  return ge(t3, e4).reverse();
}
function W2(t3, e4, n6) {
  let r5;
  if (typeof e4 == "string")
    try {
      r5 = Ee(e4);
    } catch (s5) {
      throw new Error(t3 + " must be hex string or Uint8Array, cause: " + s5);
    }
  else if (It(e4))
    r5 = Uint8Array.from(e4);
  else
    throw new Error(t3 + " must be hex string or Uint8Array");
  const o6 = r5.length;
  if (typeof n6 == "number" && o6 !== n6)
    throw new Error(t3 + " of length " + n6 + " expected, got " + o6);
  return r5;
}
function ye(...t3) {
  let e4 = 0;
  for (let r5 = 0; r5 < t3.length; r5++) {
    const o6 = t3[r5];
    Ut(o6), e4 += o6.length;
  }
  const n6 = new Uint8Array(e4);
  for (let r5 = 0, o6 = 0; r5 < t3.length; r5++) {
    const s5 = t3[r5];
    n6.set(s5, o6), o6 += s5.length;
  }
  return n6;
}
var Lt = (t3) => typeof t3 == "bigint" && vt <= t3;
function Qn(t3, e4, n6) {
  return Lt(t3) && Lt(e4) && Lt(n6) && e4 <= t3 && t3 < n6;
}
function ft(t3, e4, n6, r5) {
  if (!Qn(e4, n6, r5))
    throw new Error("expected valid " + t3 + ": " + n6 + " <= n < " + r5 + ", got " + e4);
}
function tr(t3) {
  let e4;
  for (e4 = 0; t3 > vt; t3 >>= be, e4 += 1)
    ;
  return e4;
}
var er = (t3) => (Wn << BigInt(t3 - 1)) - be;
var nr = { bigint: (t3) => typeof t3 == "bigint", function: (t3) => typeof t3 == "function", boolean: (t3) => typeof t3 == "boolean", string: (t3) => typeof t3 == "string", stringOrUint8Array: (t3) => typeof t3 == "string" || It(t3), isSafeInteger: (t3) => Number.isSafeInteger(t3), array: (t3) => Array.isArray(t3), field: (t3, e4) => e4.Fp.isValid(t3), hash: (t3) => typeof t3 == "function" && Number.isSafeInteger(t3.outputLen) };
function Ot(t3, e4, n6 = {}) {
  const r5 = (o6, s5, a4) => {
    const u4 = nr[s5];
    if (typeof u4 != "function")
      throw new Error("invalid validator function");
    const i5 = t3[o6];
    if (!(a4 && i5 === void 0) && !u4(i5, t3))
      throw new Error("param " + String(o6) + " is invalid. Expected " + s5 + ", got " + i5);
  };
  for (const [o6, s5] of Object.entries(e4))
    r5(o6, s5, false);
  for (const [o6, s5] of Object.entries(n6))
    r5(o6, s5, true);
  return t3;
}
function xe(t3) {
  const e4 = /* @__PURE__ */ new WeakMap();
  return (n6, ...r5) => {
    const o6 = e4.get(n6);
    if (o6 !== void 0)
      return o6;
    const s5 = t3(n6, ...r5);
    return e4.set(n6, s5), s5;
  };
}
var M4 = BigInt(0);
var N4 = BigInt(1);
var nt = BigInt(2);
var rr = BigInt(3);
var Ht = BigInt(4);
var Be = BigInt(5);
var Ce = BigInt(8);
function H3(t3, e4) {
  const n6 = t3 % e4;
  return n6 >= M4 ? n6 : e4 + n6;
}
function or(t3, e4, n6) {
  if (e4 < M4)
    throw new Error("invalid exponent, negatives unsupported");
  if (n6 <= M4)
    throw new Error("invalid modulus");
  if (n6 === N4)
    return M4;
  let r5 = N4;
  for (; e4 > M4; )
    e4 & N4 && (r5 = r5 * t3 % n6), t3 = t3 * t3 % n6, e4 >>= N4;
  return r5;
}
function J2(t3, e4, n6) {
  let r5 = t3;
  for (; e4-- > M4; )
    r5 *= r5, r5 %= n6;
  return r5;
}
function Ae(t3, e4) {
  if (t3 === M4)
    throw new Error("invert: expected non-zero number");
  if (e4 <= M4)
    throw new Error("invert: expected positive modulus, got " + e4);
  let n6 = H3(t3, e4), r5 = e4, o6 = M4, s5 = N4;
  for (; n6 !== M4; ) {
    const u4 = r5 / n6, i5 = r5 % n6, D5 = o6 - s5 * u4;
    r5 = n6, n6 = i5, o6 = s5, s5 = D5;
  }
  if (r5 !== N4)
    throw new Error("invert: does not exist");
  return H3(o6, e4);
}
function sr(t3) {
  const e4 = (t3 - N4) / nt;
  let n6, r5, o6;
  for (n6 = t3 - N4, r5 = 0; n6 % nt === M4; n6 /= nt, r5++)
    ;
  for (o6 = nt; o6 < t3 && or(o6, e4, t3) !== t3 - N4; o6++)
    if (o6 > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (r5 === 1) {
    const a4 = (t3 + N4) / Ht;
    return function(i5, D5) {
      const c5 = i5.pow(D5, a4);
      if (!i5.eql(i5.sqr(c5), D5))
        throw new Error("Cannot find square root");
      return c5;
    };
  }
  const s5 = (n6 + N4) / nt;
  return function(u4, i5) {
    if (u4.pow(i5, e4) === u4.neg(u4.ONE))
      throw new Error("Cannot find square root");
    let D5 = r5, c5 = u4.pow(u4.mul(u4.ONE, o6), n6), l6 = u4.pow(i5, s5), p5 = u4.pow(i5, n6);
    for (; !u4.eql(p5, u4.ONE); ) {
      if (u4.eql(p5, u4.ZERO))
        return u4.ZERO;
      let w6 = 1;
      for (let g6 = u4.sqr(p5); w6 < D5 && !u4.eql(g6, u4.ONE); w6++)
        g6 = u4.sqr(g6);
      const h7 = u4.pow(c5, N4 << BigInt(D5 - w6 - 1));
      c5 = u4.sqr(h7), l6 = u4.mul(l6, h7), p5 = u4.mul(p5, c5), D5 = w6;
    }
    return l6;
  };
}
function ir(t3) {
  if (t3 % Ht === rr) {
    const e4 = (t3 + N4) / Ht;
    return function(r5, o6) {
      const s5 = r5.pow(o6, e4);
      if (!r5.eql(r5.sqr(s5), o6))
        throw new Error("Cannot find square root");
      return s5;
    };
  }
  if (t3 % Ce === Be) {
    const e4 = (t3 - Be) / Ce;
    return function(r5, o6) {
      const s5 = r5.mul(o6, nt), a4 = r5.pow(s5, e4), u4 = r5.mul(o6, a4), i5 = r5.mul(r5.mul(u4, nt), a4), D5 = r5.mul(u4, r5.sub(i5, r5.ONE));
      if (!r5.eql(r5.sqr(D5), o6))
        throw new Error("Cannot find square root");
      return D5;
    };
  }
  return sr(t3);
}
var ur = (t3, e4) => (H3(t3, e4) & N4) === N4;
var cr = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ar(t3) {
  const e4 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n6 = cr.reduce((r5, o6) => (r5[o6] = "function", r5), e4);
  return Ot(t3, n6);
}
function fr(t3, e4, n6) {
  if (n6 < M4)
    throw new Error("invalid exponent, negatives unsupported");
  if (n6 === M4)
    return t3.ONE;
  if (n6 === N4)
    return e4;
  let r5 = t3.ONE, o6 = e4;
  for (; n6 > M4; )
    n6 & N4 && (r5 = t3.mul(r5, o6)), o6 = t3.sqr(o6), n6 >>= N4;
  return r5;
}
function Dr(t3, e4) {
  const n6 = new Array(e4.length), r5 = e4.reduce((s5, a4, u4) => t3.is0(a4) ? s5 : (n6[u4] = s5, t3.mul(s5, a4)), t3.ONE), o6 = t3.inv(r5);
  return e4.reduceRight((s5, a4, u4) => t3.is0(a4) ? s5 : (n6[u4] = t3.mul(s5, n6[u4]), t3.mul(s5, a4)), o6), n6;
}
function me(t3, e4) {
  const n6 = e4 !== void 0 ? e4 : t3.toString(2).length, r5 = Math.ceil(n6 / 8);
  return { nBitLength: n6, nByteLength: r5 };
}
function _e(t3, e4, n6 = false, r5 = {}) {
  if (t3 <= M4)
    throw new Error("invalid field: expected ORDER > 0, got " + t3);
  const { nBitLength: o6, nByteLength: s5 } = me(t3, e4);
  if (s5 > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a4;
  const u4 = Object.freeze({ ORDER: t3, isLE: n6, BITS: o6, BYTES: s5, MASK: er(o6), ZERO: M4, ONE: N4, create: (i5) => H3(i5, t3), isValid: (i5) => {
    if (typeof i5 != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof i5);
    return M4 <= i5 && i5 < t3;
  }, is0: (i5) => i5 === M4, isOdd: (i5) => (i5 & N4) === N4, neg: (i5) => H3(-i5, t3), eql: (i5, D5) => i5 === D5, sqr: (i5) => H3(i5 * i5, t3), add: (i5, D5) => H3(i5 + D5, t3), sub: (i5, D5) => H3(i5 - D5, t3), mul: (i5, D5) => H3(i5 * D5, t3), pow: (i5, D5) => fr(u4, i5, D5), div: (i5, D5) => H3(i5 * Ae(D5, t3), t3), sqrN: (i5) => i5 * i5, addN: (i5, D5) => i5 + D5, subN: (i5, D5) => i5 - D5, mulN: (i5, D5) => i5 * D5, inv: (i5) => Ae(i5, t3), sqrt: r5.sqrt || ((i5) => (a4 || (a4 = ir(t3)), a4(u4, i5))), invertBatch: (i5) => Dr(u4, i5), cmov: (i5, D5, c5) => c5 ? D5 : i5, toBytes: (i5) => n6 ? Nt(i5, s5) : ge(i5, s5), fromBytes: (i5) => {
    if (i5.length !== s5)
      throw new Error("Field.fromBytes: expected " + s5 + " bytes, got " + i5.length);
    return n6 ? Et(i5) : Pn(i5);
  } });
  return Object.freeze(u4);
}
var Se = BigInt(0);
var gt = BigInt(1);
function zt(t3, e4) {
  const n6 = e4.negate();
  return t3 ? n6 : e4;
}
function ve(t3, e4) {
  if (!Number.isSafeInteger(t3) || t3 <= 0 || t3 > e4)
    throw new Error("invalid window size, expected [1.." + e4 + "], got W=" + t3);
}
function Mt(t3, e4) {
  ve(t3, e4);
  const n6 = Math.ceil(e4 / t3) + 1, r5 = 2 ** (t3 - 1);
  return { windows: n6, windowSize: r5 };
}
function dr(t3, e4) {
  if (!Array.isArray(t3))
    throw new Error("array expected");
  t3.forEach((n6, r5) => {
    if (!(n6 instanceof e4))
      throw new Error("invalid point at index " + r5);
  });
}
function hr(t3, e4) {
  if (!Array.isArray(t3))
    throw new Error("array of scalars expected");
  t3.forEach((n6, r5) => {
    if (!e4.isValid(n6))
      throw new Error("invalid scalar at index " + r5);
  });
}
var qt = /* @__PURE__ */ new WeakMap();
var Ie = /* @__PURE__ */ new WeakMap();
function $t(t3) {
  return Ie.get(t3) || 1;
}
function lr(t3, e4) {
  return { constTimeNegate: zt, hasPrecomputes(n6) {
    return $t(n6) !== 1;
  }, unsafeLadder(n6, r5, o6 = t3.ZERO) {
    let s5 = n6;
    for (; r5 > Se; )
      r5 & gt && (o6 = o6.add(s5)), s5 = s5.double(), r5 >>= gt;
    return o6;
  }, precomputeWindow(n6, r5) {
    const { windows: o6, windowSize: s5 } = Mt(r5, e4), a4 = [];
    let u4 = n6, i5 = u4;
    for (let D5 = 0; D5 < o6; D5++) {
      i5 = u4, a4.push(i5);
      for (let c5 = 1; c5 < s5; c5++)
        i5 = i5.add(u4), a4.push(i5);
      u4 = i5.double();
    }
    return a4;
  }, wNAF(n6, r5, o6) {
    const { windows: s5, windowSize: a4 } = Mt(n6, e4);
    let u4 = t3.ZERO, i5 = t3.BASE;
    const D5 = BigInt(2 ** n6 - 1), c5 = 2 ** n6, l6 = BigInt(n6);
    for (let p5 = 0; p5 < s5; p5++) {
      const w6 = p5 * a4;
      let h7 = Number(o6 & D5);
      o6 >>= l6, h7 > a4 && (h7 -= c5, o6 += gt);
      const g6 = w6, S4 = w6 + Math.abs(h7) - 1, v8 = p5 % 2 !== 0, L5 = h7 < 0;
      h7 === 0 ? i5 = i5.add(zt(v8, r5[g6])) : u4 = u4.add(zt(L5, r5[S4]));
    }
    return { p: u4, f: i5 };
  }, wNAFUnsafe(n6, r5, o6, s5 = t3.ZERO) {
    const { windows: a4, windowSize: u4 } = Mt(n6, e4), i5 = BigInt(2 ** n6 - 1), D5 = 2 ** n6, c5 = BigInt(n6);
    for (let l6 = 0; l6 < a4; l6++) {
      const p5 = l6 * u4;
      if (o6 === Se)
        break;
      let w6 = Number(o6 & i5);
      if (o6 >>= c5, w6 > u4 && (w6 -= D5, o6 += gt), w6 === 0)
        continue;
      let h7 = r5[p5 + Math.abs(w6) - 1];
      w6 < 0 && (h7 = h7.negate()), s5 = s5.add(h7);
    }
    return s5;
  }, getPrecomputes(n6, r5, o6) {
    let s5 = qt.get(r5);
    return s5 || (s5 = this.precomputeWindow(r5, n6), n6 !== 1 && qt.set(r5, o6(s5))), s5;
  }, wNAFCached(n6, r5, o6) {
    const s5 = $t(n6);
    return this.wNAF(s5, this.getPrecomputes(s5, n6, o6), r5);
  }, wNAFCachedUnsafe(n6, r5, o6, s5) {
    const a4 = $t(n6);
    return a4 === 1 ? this.unsafeLadder(n6, r5, s5) : this.wNAFUnsafe(a4, this.getPrecomputes(a4, n6, o6), r5, s5);
  }, setWindowSize(n6, r5) {
    ve(r5, e4), Ie.set(n6, r5), qt.delete(n6);
  } };
}
function br(t3, e4, n6, r5) {
  if (dr(n6, t3), hr(r5, e4), n6.length !== r5.length)
    throw new Error("arrays of points and scalars must have equal length");
  const o6 = t3.ZERO, s5 = tr(BigInt(n6.length)), a4 = s5 > 12 ? s5 - 3 : s5 > 4 ? s5 - 2 : s5 ? 2 : 1, u4 = (1 << a4) - 1, i5 = new Array(u4 + 1).fill(o6), D5 = Math.floor((e4.BITS - 1) / a4) * a4;
  let c5 = o6;
  for (let l6 = D5; l6 >= 0; l6 -= a4) {
    i5.fill(o6);
    for (let w6 = 0; w6 < r5.length; w6++) {
      const h7 = r5[w6], g6 = Number(h7 >> BigInt(l6) & BigInt(u4));
      i5[g6] = i5[g6].add(n6[w6]);
    }
    let p5 = o6;
    for (let w6 = i5.length - 1, h7 = o6; w6 > 0; w6--)
      h7 = h7.add(i5[w6]), p5 = p5.add(h7);
    if (c5 = c5.add(p5), l6 !== 0)
      for (let w6 = 0; w6 < a4; w6++)
        c5 = c5.double();
  }
  return c5;
}
function pr(t3) {
  return ar(t3.Fp), Ot(t3, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me(t3.n, t3.nBitLength), ...t3, p: t3.Fp.ORDER });
}
var G2 = BigInt(0);
var j4 = BigInt(1);
var yt = BigInt(2);
var wr = BigInt(8);
var Er = { zip215: true };
function gr(t3) {
  const e4 = pr(t3);
  return Ot(t3, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e4 });
}
function yr(t3) {
  const e4 = gr(t3), { Fp: n6, n: r5, prehash: o6, hash: s5, randomBytes: a4, nByteLength: u4, h: i5 } = e4, D5 = yt << BigInt(u4 * 8) - j4, c5 = n6.create, l6 = _e(e4.n, e4.nBitLength), p5 = e4.uvRatio || ((y7, f5) => {
    try {
      return { isValid: true, value: n6.sqrt(y7 * n6.inv(f5)) };
    } catch {
      return { isValid: false, value: G2 };
    }
  }), w6 = e4.adjustScalarBytes || ((y7) => y7), h7 = e4.domain || ((y7, f5, b4) => {
    if (Tt("phflag", b4), f5.length || b4)
      throw new Error("Contexts/pre-hash are not supported");
    return y7;
  });
  function g6(y7, f5) {
    ft("coordinate " + y7, f5, G2, D5);
  }
  function S4(y7) {
    if (!(y7 instanceof d6))
      throw new Error("ExtendedPoint expected");
  }
  const v8 = xe((y7, f5) => {
    const { ex: b4, ey: E7, ez: B4 } = y7, C7 = y7.is0();
    f5 == null && (f5 = C7 ? wr : n6.inv(B4));
    const A7 = c5(b4 * f5), U3 = c5(E7 * f5), _7 = c5(B4 * f5);
    if (C7)
      return { x: G2, y: j4 };
    if (_7 !== j4)
      throw new Error("invZ was invalid");
    return { x: A7, y: U3 };
  }), L5 = xe((y7) => {
    const { a: f5, d: b4 } = e4;
    if (y7.is0())
      throw new Error("bad point: ZERO");
    const { ex: E7, ey: B4, ez: C7, et: A7 } = y7, U3 = c5(E7 * E7), _7 = c5(B4 * B4), T6 = c5(C7 * C7), $4 = c5(T6 * T6), R3 = c5(U3 * f5), V4 = c5(T6 * c5(R3 + _7)), Y3 = c5($4 + c5(b4 * c5(U3 * _7)));
    if (V4 !== Y3)
      throw new Error("bad point: equation left != right (1)");
    const Z3 = c5(E7 * B4), X3 = c5(C7 * A7);
    if (Z3 !== X3)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d6 {
    constructor(f5, b4, E7, B4) {
      this.ex = f5, this.ey = b4, this.ez = E7, this.et = B4, g6("x", f5), g6("y", b4), g6("z", E7), g6("t", B4), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f5) {
      if (f5 instanceof d6)
        throw new Error("extended point not allowed");
      const { x: b4, y: E7 } = f5 || {};
      return g6("x", b4), g6("y", E7), new d6(b4, E7, j4, c5(b4 * E7));
    }
    static normalizeZ(f5) {
      const b4 = n6.invertBatch(f5.map((E7) => E7.ez));
      return f5.map((E7, B4) => E7.toAffine(b4[B4])).map(d6.fromAffine);
    }
    static msm(f5, b4) {
      return br(d6, l6, f5, b4);
    }
    _setWindowSize(f5) {
      q4.setWindowSize(this, f5);
    }
    assertValidity() {
      L5(this);
    }
    equals(f5) {
      S4(f5);
      const { ex: b4, ey: E7, ez: B4 } = this, { ex: C7, ey: A7, ez: U3 } = f5, _7 = c5(b4 * U3), T6 = c5(C7 * B4), $4 = c5(E7 * U3), R3 = c5(A7 * B4);
      return _7 === T6 && $4 === R3;
    }
    is0() {
      return this.equals(d6.ZERO);
    }
    negate() {
      return new d6(c5(-this.ex), this.ey, this.ez, c5(-this.et));
    }
    double() {
      const { a: f5 } = e4, { ex: b4, ey: E7, ez: B4 } = this, C7 = c5(b4 * b4), A7 = c5(E7 * E7), U3 = c5(yt * c5(B4 * B4)), _7 = c5(f5 * C7), T6 = b4 + E7, $4 = c5(c5(T6 * T6) - C7 - A7), R3 = _7 + A7, V4 = R3 - U3, Y3 = _7 - A7, Z3 = c5($4 * V4), X3 = c5(R3 * Y3), et3 = c5($4 * Y3), pt4 = c5(V4 * R3);
      return new d6(Z3, X3, pt4, et3);
    }
    add(f5) {
      S4(f5);
      const { a: b4, d: E7 } = e4, { ex: B4, ey: C7, ez: A7, et: U3 } = this, { ex: _7, ey: T6, ez: $4, et: R3 } = f5;
      if (b4 === BigInt(-1)) {
        const re3 = c5((C7 - B4) * (T6 + _7)), oe4 = c5((C7 + B4) * (T6 - _7)), mt3 = c5(oe4 - re3);
        if (mt3 === G2)
          return this.double();
        const se2 = c5(A7 * yt * R3), ie2 = c5(U3 * yt * $4), ue2 = ie2 + se2, ce3 = oe4 + re3, ae4 = ie2 - se2, Dn3 = c5(ue2 * mt3), dn3 = c5(ce3 * ae4), hn3 = c5(ue2 * ae4), ln3 = c5(mt3 * ce3);
        return new d6(Dn3, dn3, ln3, hn3);
      }
      const V4 = c5(B4 * _7), Y3 = c5(C7 * T6), Z3 = c5(U3 * E7 * R3), X3 = c5(A7 * $4), et3 = c5((B4 + C7) * (_7 + T6) - V4 - Y3), pt4 = X3 - Z3, ee2 = X3 + Z3, ne3 = c5(Y3 - b4 * V4), un3 = c5(et3 * pt4), cn3 = c5(ee2 * ne3), an3 = c5(et3 * ne3), fn3 = c5(pt4 * ee2);
      return new d6(un3, cn3, fn3, an3);
    }
    subtract(f5) {
      return this.add(f5.negate());
    }
    wNAF(f5) {
      return q4.wNAFCached(this, f5, d6.normalizeZ);
    }
    multiply(f5) {
      const b4 = f5;
      ft("scalar", b4, j4, r5);
      const { p: E7, f: B4 } = this.wNAF(b4);
      return d6.normalizeZ([E7, B4])[0];
    }
    multiplyUnsafe(f5, b4 = d6.ZERO) {
      const E7 = f5;
      return ft("scalar", E7, G2, r5), E7 === G2 ? F5 : this.is0() || E7 === j4 ? this : q4.wNAFCachedUnsafe(this, E7, d6.normalizeZ, b4);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i5).is0();
    }
    isTorsionFree() {
      return q4.unsafeLadder(this, r5).is0();
    }
    toAffine(f5) {
      return v8(this, f5);
    }
    clearCofactor() {
      const { h: f5 } = e4;
      return f5 === j4 ? this : this.multiplyUnsafe(f5);
    }
    static fromHex(f5, b4 = false) {
      const { d: E7, a: B4 } = e4, C7 = n6.BYTES;
      f5 = W2("pointHex", f5, C7), Tt("zip215", b4);
      const A7 = f5.slice(), U3 = f5[C7 - 1];
      A7[C7 - 1] = U3 & -129;
      const _7 = Et(A7), T6 = b4 ? D5 : n6.ORDER;
      ft("pointHex.y", _7, G2, T6);
      const $4 = c5(_7 * _7), R3 = c5($4 - j4), V4 = c5(E7 * $4 - B4);
      let { isValid: Y3, value: Z3 } = p5(R3, V4);
      if (!Y3)
        throw new Error("Point.fromHex: invalid y coordinate");
      const X3 = (Z3 & j4) === j4, et3 = (U3 & 128) !== 0;
      if (!b4 && Z3 === G2 && et3)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return et3 !== X3 && (Z3 = c5(-Z3)), d6.fromAffine({ x: Z3, y: _7 });
    }
    static fromPrivateKey(f5) {
      return O4(f5).point;
    }
    toRawBytes() {
      const { x: f5, y: b4 } = this.toAffine(), E7 = Nt(b4, n6.BYTES);
      return E7[E7.length - 1] |= f5 & j4 ? 128 : 0, E7;
    }
    toHex() {
      return Ft(this.toRawBytes());
    }
  }
  d6.BASE = new d6(e4.Gx, e4.Gy, j4, c5(e4.Gx * e4.Gy)), d6.ZERO = new d6(G2, j4, j4, G2);
  const { BASE: m4, ZERO: F5 } = d6, q4 = lr(d6, u4 * 8);
  function z7(y7) {
    return H3(y7, r5);
  }
  function I5(y7) {
    return z7(Et(y7));
  }
  function O4(y7) {
    const f5 = n6.BYTES;
    y7 = W2("private key", y7, f5);
    const b4 = W2("hashed private key", s5(y7), 2 * f5), E7 = w6(b4.slice(0, f5)), B4 = b4.slice(f5, 2 * f5), C7 = I5(E7), A7 = m4.multiply(C7), U3 = A7.toRawBytes();
    return { head: E7, prefix: B4, scalar: C7, point: A7, pointBytes: U3 };
  }
  function ot4(y7) {
    return O4(y7).pointBytes;
  }
  function tt3(y7 = new Uint8Array(), ...f5) {
    const b4 = ye(...f5);
    return I5(s5(h7(b4, W2("context", y7), !!o6)));
  }
  function st3(y7, f5, b4 = {}) {
    y7 = W2("message", y7), o6 && (y7 = o6(y7));
    const { prefix: E7, scalar: B4, pointBytes: C7 } = O4(f5), A7 = tt3(b4.context, E7, y7), U3 = m4.multiply(A7).toRawBytes(), _7 = tt3(b4.context, U3, C7, y7), T6 = z7(A7 + _7 * B4);
    ft("signature.s", T6, G2, r5);
    const $4 = ye(U3, Nt(T6, n6.BYTES));
    return W2("result", $4, n6.BYTES * 2);
  }
  const at4 = Er;
  function Ct4(y7, f5, b4, E7 = at4) {
    const { context: B4, zip215: C7 } = E7, A7 = n6.BYTES;
    y7 = W2("signature", y7, 2 * A7), f5 = W2("message", f5), b4 = W2("publicKey", b4, A7), C7 !== void 0 && Tt("zip215", C7), o6 && (f5 = o6(f5));
    const U3 = Et(y7.slice(A7, 2 * A7));
    let _7, T6, $4;
    try {
      _7 = d6.fromHex(b4, C7), T6 = d6.fromHex(y7.slice(0, A7), C7), $4 = m4.multiplyUnsafe(U3);
    } catch {
      return false;
    }
    if (!C7 && _7.isSmallOrder())
      return false;
    const R3 = tt3(B4, T6.toRawBytes(), _7.toRawBytes(), f5);
    return T6.add(_7.multiplyUnsafe(R3)).subtract($4).clearCofactor().equals(d6.ZERO);
  }
  return m4._setWindowSize(8), { CURVE: e4, getPublicKey: ot4, sign: st3, verify: Ct4, ExtendedPoint: d6, utils: { getExtendedPublicKey: O4, randomPrivateKey: () => a4(n6.BYTES), precompute(y7 = 8, f5 = d6.BASE) {
    return f5._setWindowSize(y7), f5.multiply(BigInt(3)), f5;
  } } };
}
BigInt(0), BigInt(1);
var kt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Ue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
var xr = BigInt(1);
var Te = BigInt(2);
BigInt(3);
var Br = BigInt(5);
var Cr = BigInt(8);
function Ar(t3) {
  const e4 = BigInt(10), n6 = BigInt(20), r5 = BigInt(40), o6 = BigInt(80), s5 = kt, u4 = t3 * t3 % s5 * t3 % s5, i5 = J2(u4, Te, s5) * u4 % s5, D5 = J2(i5, xr, s5) * t3 % s5, c5 = J2(D5, Br, s5) * D5 % s5, l6 = J2(c5, e4, s5) * c5 % s5, p5 = J2(l6, n6, s5) * l6 % s5, w6 = J2(p5, r5, s5) * p5 % s5, h7 = J2(w6, o6, s5) * w6 % s5, g6 = J2(h7, o6, s5) * w6 % s5, S4 = J2(g6, e4, s5) * c5 % s5;
  return { pow_p_5_8: J2(S4, Te, s5) * t3 % s5, b2: u4 };
}
function mr(t3) {
  return t3[0] &= 248, t3[31] &= 127, t3[31] |= 64, t3;
}
function _r(t3, e4) {
  const n6 = kt, r5 = H3(e4 * e4 * e4, n6), o6 = H3(r5 * r5 * e4, n6), s5 = Ar(t3 * o6).pow_p_5_8;
  let a4 = H3(t3 * r5 * s5, n6);
  const u4 = H3(e4 * a4 * a4, n6), i5 = a4, D5 = H3(a4 * Ue, n6), c5 = u4 === t3, l6 = u4 === H3(-t3, n6), p5 = u4 === H3(-t3 * Ue, n6);
  return c5 && (a4 = i5), (l6 || p5) && (a4 = D5), ur(a4, n6) && (a4 = H3(-a4, n6)), { isValid: c5 || l6, value: a4 };
}
var Sr = (() => _e(kt, void 0, true))();
var vr = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn, randomBytes: he, adjustScalarBytes: mr, uvRatio: _r }))();
var Rt = (() => yr(vr))();
var jt = "EdDSA";
var Zt = "JWT";
var ut = ".";
var Dt = "base64url";
var Gt = "utf8";
var xt = "utf8";
var Vt = ":";
var Yt = "did";
var Jt = "key";
var dt = "base58btc";
var Kt = "z";
var Wt = "K36";
var Ne = 32;
function Xt(t3) {
  return globalThis.Buffer != null ? new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength) : t3;
}
function Le(t3 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t3)) : new Uint8Array(t3);
}
function Oe(t3, e4) {
  e4 || (e4 = t3.reduce((o6, s5) => o6 + s5.length, 0));
  const n6 = Le(e4);
  let r5 = 0;
  for (const o6 of t3)
    n6.set(o6, r5), r5 += o6.length;
  return Xt(n6);
}
function Ir(t3, e4) {
  if (t3.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var n6 = new Uint8Array(256), r5 = 0; r5 < n6.length; r5++)
    n6[r5] = 255;
  for (var o6 = 0; o6 < t3.length; o6++) {
    var s5 = t3.charAt(o6), a4 = s5.charCodeAt(0);
    if (n6[a4] !== 255)
      throw new TypeError(s5 + " is ambiguous");
    n6[a4] = o6;
  }
  var u4 = t3.length, i5 = t3.charAt(0), D5 = Math.log(u4) / Math.log(256), c5 = Math.log(256) / Math.log(u4);
  function l6(h7) {
    if (h7 instanceof Uint8Array || (ArrayBuffer.isView(h7) ? h7 = new Uint8Array(h7.buffer, h7.byteOffset, h7.byteLength) : Array.isArray(h7) && (h7 = Uint8Array.from(h7))), !(h7 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (h7.length === 0)
      return "";
    for (var g6 = 0, S4 = 0, v8 = 0, L5 = h7.length; v8 !== L5 && h7[v8] === 0; )
      v8++, g6++;
    for (var d6 = (L5 - v8) * c5 + 1 >>> 0, m4 = new Uint8Array(d6); v8 !== L5; ) {
      for (var F5 = h7[v8], q4 = 0, z7 = d6 - 1; (F5 !== 0 || q4 < S4) && z7 !== -1; z7--, q4++)
        F5 += 256 * m4[z7] >>> 0, m4[z7] = F5 % u4 >>> 0, F5 = F5 / u4 >>> 0;
      if (F5 !== 0)
        throw new Error("Non-zero carry");
      S4 = q4, v8++;
    }
    for (var I5 = d6 - S4; I5 !== d6 && m4[I5] === 0; )
      I5++;
    for (var O4 = i5.repeat(g6); I5 < d6; ++I5)
      O4 += t3.charAt(m4[I5]);
    return O4;
  }
  function p5(h7) {
    if (typeof h7 != "string")
      throw new TypeError("Expected String");
    if (h7.length === 0)
      return new Uint8Array();
    var g6 = 0;
    if (h7[g6] !== " ") {
      for (var S4 = 0, v8 = 0; h7[g6] === i5; )
        S4++, g6++;
      for (var L5 = (h7.length - g6) * D5 + 1 >>> 0, d6 = new Uint8Array(L5); h7[g6]; ) {
        var m4 = n6[h7.charCodeAt(g6)];
        if (m4 === 255)
          return;
        for (var F5 = 0, q4 = L5 - 1; (m4 !== 0 || F5 < v8) && q4 !== -1; q4--, F5++)
          m4 += u4 * d6[q4] >>> 0, d6[q4] = m4 % 256 >>> 0, m4 = m4 / 256 >>> 0;
        if (m4 !== 0)
          throw new Error("Non-zero carry");
        v8 = F5, g6++;
      }
      if (h7[g6] !== " ") {
        for (var z7 = L5 - v8; z7 !== L5 && d6[z7] === 0; )
          z7++;
        for (var I5 = new Uint8Array(S4 + (L5 - z7)), O4 = S4; z7 !== L5; )
          I5[O4++] = d6[z7++];
        return I5;
      }
    }
  }
  function w6(h7) {
    var g6 = p5(h7);
    if (g6)
      return g6;
    throw new Error(`Non-${e4} character`);
  }
  return { encode: l6, decodeUnsafe: p5, decode: w6 };
}
var Ur = Ir;
var Tr = Ur;
var He = (t3) => {
  if (t3 instanceof Uint8Array && t3.constructor.name === "Uint8Array")
    return t3;
  if (t3 instanceof ArrayBuffer)
    return new Uint8Array(t3);
  if (ArrayBuffer.isView(t3))
    return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Fr = (t3) => new TextEncoder().encode(t3);
var Nr = (t3) => new TextDecoder().decode(t3);
var Lr = class {
  constructor(e4, n6, r5) {
    this.name = e4, this.prefix = n6, this.baseEncode = r5;
  }
  encode(e4) {
    if (e4 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e4)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Or = class {
  constructor(e4, n6, r5) {
    if (this.name = e4, this.prefix = n6, n6.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = n6.codePointAt(0), this.baseDecode = r5;
  }
  decode(e4) {
    if (typeof e4 == "string") {
      if (e4.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e4)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e4.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e4) {
    return ze(this, e4);
  }
};
var Hr = class {
  constructor(e4) {
    this.decoders = e4;
  }
  or(e4) {
    return ze(this, e4);
  }
  decode(e4) {
    const n6 = e4[0], r5 = this.decoders[n6];
    if (r5)
      return r5.decode(e4);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e4)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (t3, e4) => new Hr({ ...t3.decoders || { [t3.prefix]: t3 }, ...e4.decoders || { [e4.prefix]: e4 } });
var zr = class {
  constructor(e4, n6, r5, o6) {
    this.name = e4, this.prefix = n6, this.baseEncode = r5, this.baseDecode = o6, this.encoder = new Lr(e4, n6, r5), this.decoder = new Or(e4, n6, o6);
  }
  encode(e4) {
    return this.encoder.encode(e4);
  }
  decode(e4) {
    return this.decoder.decode(e4);
  }
};
var Bt = ({ name: t3, prefix: e4, encode: n6, decode: r5 }) => new zr(t3, e4, n6, r5);
var ht = ({ prefix: t3, name: e4, alphabet: n6 }) => {
  const { encode: r5, decode: o6 } = Tr(n6, e4);
  return Bt({ prefix: t3, name: e4, encode: r5, decode: (s5) => He(o6(s5)) });
};
var Mr = (t3, e4, n6, r5) => {
  const o6 = {};
  for (let c5 = 0; c5 < e4.length; ++c5)
    o6[e4[c5]] = c5;
  let s5 = t3.length;
  for (; t3[s5 - 1] === "="; )
    --s5;
  const a4 = new Uint8Array(s5 * n6 / 8 | 0);
  let u4 = 0, i5 = 0, D5 = 0;
  for (let c5 = 0; c5 < s5; ++c5) {
    const l6 = o6[t3[c5]];
    if (l6 === void 0)
      throw new SyntaxError(`Non-${r5} character`);
    i5 = i5 << n6 | l6, u4 += n6, u4 >= 8 && (u4 -= 8, a4[D5++] = 255 & i5 >> u4);
  }
  if (u4 >= n6 || 255 & i5 << 8 - u4)
    throw new SyntaxError("Unexpected end of data");
  return a4;
};
var qr = (t3, e4, n6) => {
  const r5 = e4[e4.length - 1] === "=", o6 = (1 << n6) - 1;
  let s5 = "", a4 = 0, u4 = 0;
  for (let i5 = 0; i5 < t3.length; ++i5)
    for (u4 = u4 << 8 | t3[i5], a4 += 8; a4 > n6; )
      a4 -= n6, s5 += e4[o6 & u4 >> a4];
  if (a4 && (s5 += e4[o6 & u4 << n6 - a4]), r5)
    for (; s5.length * n6 & 7; )
      s5 += "=";
  return s5;
};
var k5 = ({ name: t3, prefix: e4, bitsPerChar: n6, alphabet: r5 }) => Bt({ prefix: e4, name: t3, encode(o6) {
  return qr(o6, r5, n6);
}, decode(o6) {
  return Mr(o6, r5, n6, t3);
} });
var $r = Bt({ prefix: "\0", name: "identity", encode: (t3) => Nr(t3), decode: (t3) => Fr(t3) });
var kr = Object.freeze({ __proto__: null, identity: $r });
var Rr = k5({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jr = Object.freeze({ __proto__: null, base2: Rr });
var Zr = k5({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gr = Object.freeze({ __proto__: null, base8: Zr });
var Vr = ht({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Yr = Object.freeze({ __proto__: null, base10: Vr });
var Jr = k5({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Kr = k5({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Wr = Object.freeze({ __proto__: null, base16: Jr, base16upper: Kr });
var Xr = k5({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr = k5({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Qr = k5({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var to = k5({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var eo = k5({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var no = k5({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ro = k5({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var oo = k5({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var so = k5({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var io = Object.freeze({ __proto__: null, base32: Xr, base32upper: Pr, base32pad: Qr, base32padupper: to, base32hex: eo, base32hexupper: no, base32hexpad: ro, base32hexpadupper: oo, base32z: so });
var uo = ht({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var co = ht({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ao = Object.freeze({ __proto__: null, base36: uo, base36upper: co });
var fo = ht({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Do = ht({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ho = Object.freeze({ __proto__: null, base58btc: fo, base58flickr: Do });
var lo = k5({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var bo = k5({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var po = k5({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var wo = k5({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Eo = Object.freeze({ __proto__: null, base64: lo, base64pad: bo, base64url: po, base64urlpad: wo });
var Me = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var go = Me.reduce((t3, e4, n6) => (t3[n6] = e4, t3), []);
var yo = Me.reduce((t3, e4, n6) => (t3[e4.codePointAt(0)] = n6, t3), []);
function xo(t3) {
  return t3.reduce((e4, n6) => (e4 += go[n6], e4), "");
}
function Bo(t3) {
  const e4 = [];
  for (const n6 of t3) {
    const r5 = yo[n6.codePointAt(0)];
    if (r5 === void 0)
      throw new Error(`Non-base256emoji character: ${n6}`);
    e4.push(r5);
  }
  return new Uint8Array(e4);
}
var Co = Bt({ prefix: "\u{1F680}", name: "base256emoji", encode: xo, decode: Bo });
var Ao = Object.freeze({ __proto__: null, base256emoji: Co });
var mo = $e;
var qe = 128;
var _o = 127;
var So = ~_o;
var vo = Math.pow(2, 31);
function $e(t3, e4, n6) {
  e4 = e4 || [], n6 = n6 || 0;
  for (var r5 = n6; t3 >= vo; )
    e4[n6++] = t3 & 255 | qe, t3 /= 128;
  for (; t3 & So; )
    e4[n6++] = t3 & 255 | qe, t3 >>>= 7;
  return e4[n6] = t3 | 0, $e.bytes = n6 - r5 + 1, e4;
}
var Io = Pt;
var Uo = 128;
var ke = 127;
function Pt(t3, r5) {
  var n6 = 0, r5 = r5 || 0, o6 = 0, s5 = r5, a4, u4 = t3.length;
  do {
    if (s5 >= u4)
      throw Pt.bytes = 0, new RangeError("Could not decode varint");
    a4 = t3[s5++], n6 += o6 < 28 ? (a4 & ke) << o6 : (a4 & ke) * Math.pow(2, o6), o6 += 7;
  } while (a4 >= Uo);
  return Pt.bytes = s5 - r5, n6;
}
var To = Math.pow(2, 7);
var Fo = Math.pow(2, 14);
var No = Math.pow(2, 21);
var Lo = Math.pow(2, 28);
var Oo = Math.pow(2, 35);
var Ho = Math.pow(2, 42);
var zo = Math.pow(2, 49);
var Mo = Math.pow(2, 56);
var qo = Math.pow(2, 63);
var $o = function(t3) {
  return t3 < To ? 1 : t3 < Fo ? 2 : t3 < No ? 3 : t3 < Lo ? 4 : t3 < Oo ? 5 : t3 < Ho ? 6 : t3 < zo ? 7 : t3 < Mo ? 8 : t3 < qo ? 9 : 10;
};
var ko = { encode: mo, decode: Io, encodingLength: $o };
var Re = ko;
var je = (t3, e4, n6 = 0) => (Re.encode(t3, e4, n6), e4);
var Ze = (t3) => Re.encodingLength(t3);
var Qt = (t3, e4) => {
  const n6 = e4.byteLength, r5 = Ze(t3), o6 = r5 + Ze(n6), s5 = new Uint8Array(o6 + n6);
  return je(t3, s5, 0), je(n6, s5, r5), s5.set(e4, o6), new Ro(t3, n6, e4, s5);
};
var Ro = class {
  constructor(e4, n6, r5, o6) {
    this.code = e4, this.size = n6, this.digest = r5, this.bytes = o6;
  }
};
var Ge = ({ name: t3, code: e4, encode: n6 }) => new jo(t3, e4, n6);
var jo = class {
  constructor(e4, n6, r5) {
    this.name = e4, this.code = n6, this.encode = r5;
  }
  digest(e4) {
    if (e4 instanceof Uint8Array) {
      const n6 = this.encode(e4);
      return n6 instanceof Uint8Array ? Qt(this.code, n6) : n6.then((r5) => Qt(this.code, r5));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve = (t3) => async (e4) => new Uint8Array(await crypto.subtle.digest(t3, e4));
var Zo = Ge({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
var Go = Ge({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
var Vo = Object.freeze({ __proto__: null, sha256: Zo, sha512: Go });
var Ye = 0;
var Yo = "identity";
var Je = He;
var Jo = (t3) => Qt(Ye, Je(t3));
var Ko = { code: Ye, name: Yo, encode: Je, digest: Jo };
var Wo = Object.freeze({ __proto__: null, identity: Ko });
new TextEncoder(), new TextDecoder();
var Ke = { ...kr, ...jr, ...Gr, ...Yr, ...Wr, ...io, ...ao, ...ho, ...Eo, ...Ao };
({ ...Vo, ...Wo });
function We(t3, e4, n6, r5) {
  return { name: t3, prefix: e4, encoder: { name: t3, prefix: e4, encode: n6 }, decoder: { decode: r5 } };
}
var Xe = We("utf8", "u", (t3) => "u" + new TextDecoder("utf8").decode(t3), (t3) => new TextEncoder().encode(t3.substring(1)));
var te = We("ascii", "a", (t3) => {
  let e4 = "a";
  for (let n6 = 0; n6 < t3.length; n6++)
    e4 += String.fromCharCode(t3[n6]);
  return e4;
}, (t3) => {
  t3 = t3.substring(1);
  const e4 = Le(t3.length);
  for (let n6 = 0; n6 < t3.length; n6++)
    e4[n6] = t3.charCodeAt(n6);
  return e4;
});
var Pe = { utf8: Xe, "utf-8": Xe, hex: Ke.base16, latin1: te, ascii: te, binary: te, ...Ke };
function ct(t3, e4 = "utf8") {
  const n6 = Pe[e4];
  if (!n6)
    throw new Error(`Unsupported encoding "${e4}"`);
  return (e4 === "utf8" || e4 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t3.buffer, t3.byteOffset, t3.byteLength).toString("utf8") : n6.encoder.encode(t3).substring(1);
}
function rt(t3, e4 = "utf8") {
  const n6 = Pe[e4];
  if (!n6)
    throw new Error(`Unsupported encoding "${e4}"`);
  return (e4 === "utf8" || e4 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t3, "utf-8")) : n6.decoder.decode(`${n6.prefix}${t3}`);
}
function lt(t3) {
  return safeJsonParse3(ct(rt(t3, Dt), Gt));
}
function bt(t3) {
  return ct(rt(safeJsonStringify3(t3), Gt), Dt);
}
function Qe(t3) {
  const e4 = rt(Wt, dt), n6 = Kt + ct(Oe([e4, t3]), dt);
  return [Yt, Jt, n6].join(Vt);
}
function en(t3) {
  return ct(t3, Dt);
}
function nn(t3) {
  return rt(t3, Dt);
}
function rn(t3) {
  return rt([bt(t3.header), bt(t3.payload)].join(ut), xt);
}
function on(t3) {
  return [bt(t3.header), bt(t3.payload), en(t3.signature)].join(ut);
}
function sn(t3) {
  const e4 = t3.split(ut), n6 = lt(e4[0]), r5 = lt(e4[1]), o6 = nn(e4[2]), s5 = rt(e4.slice(0, 2).join(ut), xt);
  return { header: n6, payload: r5, signature: o6, data: s5 };
}
function Po(t3 = he(Ne)) {
  const e4 = Rt.getPublicKey(t3);
  return { secretKey: Oe([t3, e4]), publicKey: e4 };
}
async function Qo(t3, e4, n6, r5, o6 = (0, import_time2.fromMiliseconds)(Date.now())) {
  const s5 = { alg: jt, typ: Zt }, a4 = Qe(r5.publicKey), u4 = o6 + n6, i5 = { iss: a4, sub: t3, aud: e4, iat: o6, exp: u4 }, D5 = rn({ header: s5, payload: i5 }), c5 = Rt.sign(D5, r5.secretKey.slice(0, 32));
  return on({ header: s5, payload: i5, signature: c5 });
}

// node_modules/.pnpm/detect-browser@5.3.0/node_modules/detect-browser/es/index.js
var __spreadArray = function(to2, from3, pack) {
  if (pack || arguments.length === 2)
    for (var i5 = 0, l6 = from3.length, ar4; i5 < l6; i5++) {
      if (ar4 || !(i5 in from3)) {
        if (!ar4)
          ar4 = Array.prototype.slice.call(from3, 0, i5);
        ar4[i5] = from3[i5];
      }
    }
  return to2.concat(ar4 || Array.prototype.slice.call(from3));
};
var BrowserInfo2 = (
  /** @class */
  function() {
    function BrowserInfo3(name2, version9, os2) {
      this.name = name2;
      this.version = version9;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo3;
  }()
);
var NodeInfo2 = (
  /** @class */
  function() {
    function NodeInfo3(version9) {
      this.version = version9;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo3;
  }()
);
var SearchBotDeviceInfo2 = (
  /** @class */
  function() {
    function SearchBotDeviceInfo3(name2, version9, os2, bot) {
      this.name = name2;
      this.version = version9;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo3;
  }()
);
var BotInfo2 = (
  /** @class */
  function() {
    function BotInfo3() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo3;
  }()
);
var ReactNativeInfo2 = (
  /** @class */
  function() {
    function ReactNativeInfo3() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo3;
  }()
);
var SEARCHBOX_UA_REGEX2 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX2 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS2 = 3;
var userAgentRules2 = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX2]
];
var operatingSystemRules2 = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect2(userAgent) {
  if (!!userAgent) {
    return parseUserAgent2(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo2();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent2(navigator.userAgent);
  }
  return getNodeVersion2();
}
function matchUserAgent2(ua) {
  return ua !== "" && userAgentRules2.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent2(ua) {
  var matchedRule = matchUserAgent2(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo2();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS2) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts2(REQUIRED_VERSION_PARTS2 - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version9 = versionParts.join(".");
  var os2 = detectOS3(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX2.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo2(name2, version9, os2, searchBotMatch[1]);
  }
  return new BrowserInfo2(name2, version9, os2);
}
function detectOS3(ua) {
  for (var ii3 = 0, count = operatingSystemRules2.length; ii3 < count; ii3++) {
    var _a = operatingSystemRules2[ii3], os2 = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion2() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo2(process.version.slice(1)) : null;
}
function createVersionParts2(count) {
  var output = [];
  for (var ii3 = 0; ii3 < count; ii3++) {
    output.push("0");
  }
  return output;
}

// node_modules/.pnpm/@walletconnect+utils@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.7_ns66rv5a2qkg5opcug3atvw5u4/node_modules/@walletconnect/utils/dist/index.es.js
var import_time3 = __toESM(require_cjs4());
var import_window_getters = __toESM(require_cjs5());
var import_window_metadata = __toESM(require_cjs6());

// node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// node_modules/.pnpm/@ethersproject+logger@5.7.0/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version9) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version9,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i5 = 0; i5 < value.length; i5++) {
            hex += HEX[value[i5] >> 4];
            hex += HEX[value[i5] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version9) {
    return new Logger(version9);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// node_modules/.pnpm/@ethersproject+bytes@5.7.0/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i5 = 0; i5 < value.length; i5++) {
    const v8 = value[i5];
    if (!isInteger(v8) || v8 < 0 || v8 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i5 = 0; i5 < hex.length; i5 += 2) {
      result.push(parseInt(hex.substring(i5, i5 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i5 = 0; i5 < value.length; i5++) {
      let v8 = value[i5];
      result += HexCharacters[(v8 & 240) >> 4] + HexCharacters[v8 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs4 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs4);
      const recoveryParam = vs4[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs4[0] &= 127;
      const s5 = hexlify(vs4);
      if (result.s == null) {
        result.s = s5;
      } else if (result.s !== s5) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs3 = arrayify(result.s);
    if (vs3[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs3[0] |= 128;
    }
    const _vs = hexlify(vs3);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toESM(require_bn());

// node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3 = "bignumber/5.7.0";

// node_modules/.pnpm/@ethersproject+bignumber@5.7.0/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger2 = new Logger(version3);
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}

// node_modules/.pnpm/@ethersproject+keccak256@5.7.0/node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/_version.js
var version4 = "address/5.7.0";

// node_modules/.pnpm/@ethersproject+address@5.7.0/node_modules/@ethersproject/address/lib.esm/index.js
var logger3 = new Logger(version4);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i5 = 0; i5 < 40; i5++) {
    expanded[i5] = chars[i5].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i5 = 0; i5 < 40; i5 += 2) {
    if (hashed[i5 >> 1] >> 4 >= 8) {
      chars[i5] = chars[i5].toUpperCase();
    }
    if ((hashed[i5 >> 1] & 15) >= 8) {
      chars[i5 + 1] = chars[i5 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x9) {
  if (Math.log10) {
    return Math.log10(x9);
  }
  return Math.log(x9) / Math.LN10;
}
var ibanLookup = {};
for (let i5 = 0; i5 < 10; i5++) {
  ibanLookup[String(i5)] = String(i5);
}
for (let i5 = 0; i5 < 26; i5++) {
  ibanLookup[String.fromCharCode(65 + i5)] = String(10 + i5);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c5) => {
    return ibanLookup[c5];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger3.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger3.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger3.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/_version.js
var version5 = "properties/5.7.0";

// node_modules/.pnpm/@ethersproject+properties@5.7.0/node_modules/@ethersproject/properties/lib.esm/index.js
var logger4 = new Logger(version5);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
var import_bn2 = __toESM(require_bn());
var import_hash = __toESM(require_hash());
function createCommonjsModule(fn3, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base3) {
      return commonjsRequire(path, base3 === void 0 || base3 === null ? module.path : base3);
    }
  }, fn3(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l6, r5, msg) {
  if (l6 != r5)
    throw new Error(msg || "Assertion failed: " + l6 + " != " + r5);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i5 = 0; i5 < msg.length; i5++)
        res[i5] = msg[i5] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i5 = 0; i5 < msg.length; i5 += 2)
        res.push(parseInt(msg[i5] + msg[i5 + 1], 16));
    } else {
      for (var i5 = 0; i5 < msg.length; i5++) {
        var c5 = msg.charCodeAt(i5);
        var hi3 = c5 >> 8;
        var lo3 = c5 & 255;
        if (hi3)
          res.push(hi3, lo3);
        else
          res.push(lo3);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = "";
    for (var i5 = 0; i5 < msg.length; i5++)
      res += zero2(msg[i5].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode6(arr, enc) {
    if (enc === "hex")
      return toHex(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF2(num, w6, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws3 = 1 << w6 + 1;
    var k7 = num.clone();
    for (var i5 = 0; i5 < naf.length; i5++) {
      var z7;
      var mod = k7.andln(ws3 - 1);
      if (k7.isOdd()) {
        if (mod > (ws3 >> 1) - 1)
          z7 = (ws3 >> 1) - mod;
        else
          z7 = mod;
        k7.isubn(z7);
      } else {
        z7 = 0;
      }
      naf[i5] = z7;
      k7.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u22;
      if ((m24 & 1) === 0) {
        u22 = 0;
      } else {
        m8 = k22.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u22 = -m24;
        else
          u22 = m24;
      }
      jsf[1].push(u22);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u22 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn2.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p5, k7) {
  assert$1(p5.precomputed);
  var doubles = p5._getDoubles();
  var naf = getNAF(k7, 1, this._bitLength);
  var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I5 /= 3;
  var repr = [];
  var j6;
  var nafW;
  for (j6 = 0; j6 < naf.length; j6 += doubles.step) {
    nafW = 0;
    for (var l6 = j6 + doubles.step - 1; l6 >= j6; l6--)
      nafW = (nafW << 1) + naf[l6];
    repr.push(nafW);
  }
  var a4 = this.jpoint(null, null, null);
  var b4 = this.jpoint(null, null, null);
  for (var i5 = I5; i5 > 0; i5--) {
    for (j6 = 0; j6 < repr.length; j6++) {
      nafW = repr[j6];
      if (nafW === i5)
        b4 = b4.mixedAdd(doubles.points[j6]);
      else if (nafW === -i5)
        b4 = b4.mixedAdd(doubles.points[j6].neg());
    }
    a4 = a4.add(b4);
  }
  return a4.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p5, k7) {
  var w6 = 4;
  var nafPoints = p5._getNAFPoints(w6);
  w6 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k7, w6, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i5 = naf.length - 1; i5 >= 0; i5--) {
    for (var l6 = 0; i5 >= 0 && naf[i5] === 0; i5--)
      l6++;
    if (i5 >= 0)
      l6++;
    acc = acc.dblp(l6);
    if (i5 < 0)
      break;
    var z7 = naf[i5];
    assert$1(z7 !== 0);
    if (p5.type === "affine") {
      if (z7 > 0)
        acc = acc.mixedAdd(wnd[z7 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z7 - 1 >> 1].neg());
    } else {
      if (z7 > 0)
        acc = acc.add(wnd[z7 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z7 - 1 >> 1].neg());
    }
  }
  return p5.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i5;
  var j6;
  var p5;
  for (i5 = 0; i5 < len; i5++) {
    p5 = points[i5];
    var nafPoints = p5._getNAFPoints(defW);
    wndWidth[i5] = nafPoints.wnd;
    wnd[i5] = nafPoints.points;
  }
  for (i5 = len - 1; i5 >= 1; i5 -= 2) {
    var a4 = i5 - 1;
    var b4 = i5;
    if (wndWidth[a4] !== 1 || wndWidth[b4] !== 1) {
      naf[a4] = getNAF(coeffs[a4], wndWidth[a4], this._bitLength);
      naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
      max = Math.max(naf[a4].length, max);
      max = Math.max(naf[b4].length, max);
      continue;
    }
    var comb = [
      points[a4],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b4]
      /* 7 */
    ];
    if (points[a4].y.cmp(points[b4].y) === 0) {
      comb[1] = points[a4].add(points[b4]);
      comb[2] = points[a4].toJ().mixedAdd(points[b4].neg());
    } else if (points[a4].y.cmp(points[b4].y.redNeg()) === 0) {
      comb[1] = points[a4].toJ().mixedAdd(points[b4]);
      comb[2] = points[a4].add(points[b4].neg());
    } else {
      comb[1] = points[a4].toJ().mixedAdd(points[b4]);
      comb[2] = points[a4].toJ().mixedAdd(points[b4].neg());
    }
    var index = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a4], coeffs[b4]);
    max = Math.max(jsf[0].length, max);
    naf[a4] = new Array(max);
    naf[b4] = new Array(max);
    for (j6 = 0; j6 < max; j6++) {
      var ja = jsf[0][j6] | 0;
      var jb = jsf[1][j6] | 0;
      naf[a4][j6] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b4][j6] = 0;
      wnd[a4] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i5 = max; i5 >= 0; i5--) {
    var k7 = 0;
    while (i5 >= 0) {
      var zero = true;
      for (j6 = 0; j6 < len; j6++) {
        tmp[j6] = naf[j6][i5] | 0;
        if (tmp[j6] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k7++;
      i5--;
    }
    if (i5 >= 0)
      k7++;
    acc = acc.dblp(k7);
    if (i5 < 0)
      break;
    for (j6 = 0; j6 < len; j6++) {
      var z7 = tmp[j6];
      p5;
      if (z7 === 0)
        continue;
      else if (z7 > 0)
        p5 = wnd[j6][z7 - 1 >> 1];
      else if (z7 < 0)
        p5 = wnd[j6][-z7 - 1 >> 1].neg();
      if (p5.type === "affine")
        acc = acc.mixedAdd(p5);
      else
        acc = acc.add(p5);
    }
  }
  for (i5 = 0; i5 < len; i5++)
    wnd[i5] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x9 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x9);
  return [4].concat(x9, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k7) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k7.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i5 = 0; i5 < power; i5 += step) {
    for (var j6 = 0; j6 < step; j6++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl3 = max === 1 ? null : this.dbl();
  for (var i5 = 1; i5 < max; i5++)
    res[i5] = res[i5 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k7) {
  var r5 = this;
  for (var i5 = 0; i5 < k7; i5++)
    r5 = r5.dbl();
  return r5;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn2.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn2.default(vec.a, 16),
        b: new import_bn2.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn2.default.mont(num);
  var tinv = new import_bn2.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s5 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s5).fromRed();
  var l22 = ntinv.redSub(s5).fromRed();
  return [l1, l22];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u4 = lambda;
  var v8 = this.n.clone();
  var x1 = new import_bn2.default(1);
  var y1 = new import_bn2.default(0);
  var x22 = new import_bn2.default(0);
  var y22 = new import_bn2.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b22;
  var prevR;
  var i5 = 0;
  var r5;
  var x9;
  while (u4.cmpn(0) !== 0) {
    var q4 = v8.div(u4);
    r5 = v8.sub(q4.mul(u4));
    x9 = x22.sub(q4.mul(x1));
    var y7 = y22.sub(q4.mul(y1));
    if (!a1 && r5.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r5.neg();
      b1 = x9;
    } else if (a1 && ++i5 === 2) {
      break;
    }
    prevR = r5;
    v8 = u4;
    u4 = r5;
    x22 = x1;
    x1 = x9;
    y22 = y1;
    y1 = y7;
  }
  a22 = r5.neg();
  b22 = x9;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b22.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b22 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b22 = b22.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b22 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k7) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v22 = basis[1];
  var c1 = v22.b.mul(k7).divRound(this.n);
  var c22 = v1.b.neg().mul(k7).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p22 = c22.mul(v22.a);
  var q1 = c1.mul(v1.b);
  var q22 = c22.mul(v22.b);
  var k1 = k7.sub(p1).sub(p22);
  var k22 = q1.add(q22).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x9, odd) {
  x9 = new import_bn2.default(x9, 16);
  if (!x9.red)
    x9 = x9.toRed(this.red);
  var y22 = x9.redSqr().redMul(x9).redIAdd(x9.redMul(this.a)).redIAdd(this.b);
  var y7 = y22.redSqrt();
  if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y7.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y7 = y7.redNeg();
  return this.point(x9, y7);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x9 = point3.x;
  var y7 = point3.y;
  var ax = this.a.redMul(x9);
  var rhs = x9.redSqr().redMul(x9).redIAdd(ax).redIAdd(this.b);
  return y7.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i5 = 0; i5 < points.length; i5++) {
    var split = this._endoSplit(coeffs[i5]);
    var p5 = points[i5];
    var beta = p5._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p5 = p5.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i5 * 2] = p5;
    npoints[i5 * 2 + 1] = beta;
    ncoeffs[i5 * 2] = split.k1;
    ncoeffs[i5 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i5 * 2, jacobianResult);
  for (var j6 = 0; j6 < i5 * 2; j6++) {
    npoints[j6] = null;
    ncoeffs[j6] = null;
  }
  return res;
};
function Point(curve, x9, y7, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x9 === null && y7 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x9, 16);
    this.y = new import_bn2.default(y7, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x9, y7, isRed) {
  return new Point(this, x9, y7, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p5) {
      return curve.point(p5.x.redMul(curve.endo.beta), p5.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p5) {
  if (this.inf)
    return p5;
  if (p5.inf)
    return this;
  if (this.eq(p5))
    return this.dbl();
  if (this.neg().eq(p5))
    return this.curve.point(null, null);
  if (this.x.cmp(p5.x) === 0)
    return this.curve.point(null, null);
  var c5 = this.y.redSub(p5.y);
  if (c5.cmpn(0) !== 0)
    c5 = c5.redMul(this.x.redSub(p5.x).redInvm());
  var nx = c5.redSqr().redISub(this.x).redISub(p5.x);
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a4 = this.curve.a;
  var x22 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
  var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k7) {
  k7 = new import_bn2.default(k7, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k7))
    return this.curve._fixedNafMul(this, k7);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k7]);
  else
    return this.curve._wnafMul(this, k7);
};
Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p5) {
  return this === p5 || this.inf === p5.inf && (this.inf || this.x.cmp(p5.x) === 0 && this.y.cmp(p5.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p5) {
      return p5.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x9, y7, z7) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x9 === null && y7 === null && z7 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x9, 16);
    this.y = new import_bn2.default(y7, 16);
    this.z = new import_bn2.default(z7, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x9, y7, z7) {
  return new JPoint(this, x9, y7, z7);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p5) {
  if (this.isInfinity())
    return p5;
  if (p5.isInfinity())
    return this;
  var pz2 = p5.z.redSqr();
  var z22 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u22 = p5.x.redMul(z22);
  var s1 = this.y.redMul(pz2.redMul(p5.z));
  var s22 = p5.y.redMul(z22.redMul(this.z));
  var h7 = u1.redSub(u22);
  var r5 = s1.redSub(s22);
  if (h7.cmpn(0) === 0) {
    if (r5.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h7.redSqr();
  var h32 = h22.redMul(h7);
  var v8 = u1.redMul(h22);
  var nx = r5.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
  var ny = r5.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p5.z).redMul(h7);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p5) {
  if (this.isInfinity())
    return p5.toJ();
  if (p5.isInfinity())
    return this;
  var z22 = this.z.redSqr();
  var u1 = this.x;
  var u22 = p5.x.redMul(z22);
  var s1 = this.y;
  var s22 = p5.y.redMul(z22).redMul(this.z);
  var h7 = u1.redSub(u22);
  var r5 = s1.redSub(s22);
  if (h7.cmpn(0) === 0) {
    if (r5.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h7.redSqr();
  var h32 = h22.redMul(h7);
  var v8 = u1.redMul(h22);
  var nx = r5.redSqr().redIAdd(h32).redISub(v8).redISub(v8);
  var ny = r5.redMul(v8.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h7);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i5;
  if (this.curve.zeroA || this.curve.threeA) {
    var r5 = this;
    for (i5 = 0; i5 < pow; i5++)
      r5 = r5.dbl();
    return r5;
  }
  var a4 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i5 = 0; i5 < pow; i5++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c5.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var dny = c5.redMul(t22);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i5 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s5 = s5.redIAdd(s5);
    var m4 = xx.redAdd(xx).redIAdd(xx);
    var t3 = m4.redSqr().redISub(s5).redISub(s5);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t3;
    ny = m4.redMul(s5.redISub(t3)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a4 = this.x.redSqr();
    var b4 = this.y.redSqr();
    var c5 = b4.redSqr();
    var d6 = this.x.redAdd(b4).redSqr().redISub(a4).redISub(c5);
    d6 = d6.redIAdd(d6);
    var e4 = a4.redAdd(a4).redIAdd(a4);
    var f5 = e4.redSqr();
    var c8 = c5.redIAdd(c5);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f5.redISub(d6).redISub(d6);
    ny = e4.redMul(d6.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s5 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s5 = s5.redIAdd(s5);
    var m4 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t3 = m4.redSqr().redISub(s5).redISub(s5);
    nx = t3;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m4.redMul(s5.redISub(t3)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a4 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c5.redSqr().redISub(t1.redAdd(t1));
  var t22 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c5.redMul(t22).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m4 = xx.redAdd(xx).redIAdd(xx);
  var mm = m4.redSqr();
  var e4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e4 = e4.redIAdd(e4);
  e4 = e4.redAdd(e4).redIAdd(e4);
  e4 = e4.redISub(mm);
  var ee2 = e4.redSqr();
  var t3 = yyyy.redIAdd(yyyy);
  t3 = t3.redIAdd(t3);
  t3 = t3.redIAdd(t3);
  t3 = t3.redIAdd(t3);
  var u4 = m4.redIAdd(e4).redSqr().redISub(mm).redISub(ee2).redISub(t3);
  var yyu4 = yy.redMul(u4);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u4.redMul(t3.redISub(u4)).redISub(e4.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e4).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k7, kbase) {
  k7 = new import_bn2.default(k7, kbase);
  return this.curve._wnafMul(this, k7);
};
JPoint.prototype.eq = function eq3(p5) {
  if (p5.type === "affine")
    return this.eq(p5.toJ());
  if (this === p5)
    return true;
  var z22 = this.z.redSqr();
  var pz2 = p5.z.redSqr();
  if (this.x.redMul(pz2).redISub(p5.x.redMul(z22)).cmpn(0) !== 0)
    return false;
  var z32 = z22.redMul(this.z);
  var pz3 = pz2.redMul(p5.z);
  return this.y.redMul(pz3).redISub(p5.y.redMul(z32)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x9) {
  var zs3 = this.z.redSqr();
  var rx = x9.toRed(this.curve.red).redMul(zs3);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x9.clone();
  var t3 = this.curve.redN.redMul(zs3);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t3);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert2 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e4) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash.default.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i5 = 0; i5 < this.V.length; i5++) {
    this.K[i5] = 0;
    this.V[i5] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new import_hash.default.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new import_bn2.default(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p5) {
  var initial = buf[p5.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i5 = 0, off = p5.place; i5 < octetLen; i5++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p5.place = off;
  return val;
}
function rmPadding(buf) {
  var i5 = 0;
  var len = buf.length - 1;
  while (!buf[i5] && !(buf[i5 + 1] & 128) && i5 < len) {
    i5++;
  }
  if (i5 === 0) {
    return buf;
  }
  return buf.slice(i5);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p5 = new Position();
  if (data[p5.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p5);
  if (len === false) {
    return false;
  }
  if (len + p5.place !== data.length) {
    return false;
  }
  if (data[p5.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p5);
  if (rlen === false) {
    return false;
  }
  var r5 = data.slice(p5.place, rlen + p5.place);
  p5.place += rlen;
  if (data[p5.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p5);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p5.place) {
    return false;
  }
  var s5 = data.slice(p5.place, slen + p5.place);
  if (r5[0] === 0) {
    if (r5[1] & 128) {
      r5 = r5.slice(1);
    } else {
      return false;
    }
  }
  if (s5[0] === 0) {
    if (s5[1] & 128) {
      s5 = s5.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn2.default(r5);
  this.s = new import_bn2.default(s5);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r5 = this.r.toArray();
  var s5 = this.s.toArray();
  if (r5[0] & 128)
    r5 = [0].concat(r5);
  if (s5[0] & 128)
    s5 = [0].concat(s5);
  r5 = rmPadding(r5);
  s5 = rmPadding(s5);
  while (!s5[0] && !(s5[1] & 128)) {
    s5 = s5.slice(1);
  }
  var arr = [2];
  constructLength(arr, r5.length);
  arr = arr.concat(r5);
  arr.push(2);
  constructLength(arr, s5.length);
  var backHalf = arr.concat(s5);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn2.default(2));
  for (; ; ) {
    var priv = new import_bn2.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn2.default(1));
  for (var iter = 0; ; iter++) {
    var k7 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
    k7 = this._truncateToN(k7, true);
    if (k7.cmpn(1) <= 0 || k7.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k7);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r5 = kpX.umod(this.n);
    if (r5.cmpn(0) === 0)
      continue;
    var s5 = k7.invm(this.n).mul(r5.mul(key2.getPrivate()).iadd(msg));
    s5 = s5.umod(this.n);
    if (s5.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r5) !== 0 ? 2 : 0);
    if (options.canonical && s5.cmp(this.nh) > 0) {
      s5 = this.n.sub(s5);
      recoveryParam ^= 1;
    }
    return new signature({ r: r5, s: s5, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r5 = signature$1.r;
  var s5 = signature$1.s;
  if (r5.cmpn(1) < 0 || r5.cmp(this.n) >= 0)
    return false;
  if (s5.cmpn(1) < 0 || s5.cmp(this.n) >= 0)
    return false;
  var sinv = s5.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u22 = sinv.mul(r5).umod(this.n);
  var p5;
  if (!this.curve._maxwellTrick) {
    p5 = this.g.mulAdd(u1, key2.getPublic(), u22);
    if (p5.isInfinity())
      return false;
    return p5.getX().umod(this.n).cmp(r5) === 0;
  }
  p5 = this.g.jmulAdd(u1, key2.getPublic(), u22);
  if (p5.isInfinity())
    return false;
  return p5.eqXToP(r5);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j6, enc) {
  assert$5((3 & j6) === j6, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n6 = this.n;
  var e4 = new import_bn2.default(msg);
  var r5 = signature$1.r;
  var s5 = signature$1.s;
  var isYOdd = j6 & 1;
  var isSecondKey = j6 >> 1;
  if (r5.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r5 = this.curve.pointFromX(r5.add(this.curve.n), isYOdd);
  else
    r5 = this.curve.pointFromX(r5, isYOdd);
  var rInv = signature$1.r.invm(n6);
  var s1 = n6.sub(e4).mul(rInv).umod(n6);
  var s22 = s5.mul(rInv).umod(n6);
  return this.g.mulAdd(s1, r5, s22);
};
EC.prototype.getKeyRecoveryParam = function(e4, signature$1, Q5, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i5 = 0; i5 < 4; i5++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e4, signature$1, i5);
    } catch (e5) {
      continue;
    }
    if (Qprime.eq(Q5))
      return i5;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;

// node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version6 = "signing-key/5.7.0";

// node_modules/.pnpm/@ethersproject+signing-key@5.7.0/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger5 = new Logger(version6);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger5.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest2) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest2);
    if (digestBytes.length !== 32) {
      logger5.throwArgumentError("bad digest length", "digest", digest2);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey(digest2, signature2) {
  const sig = splitSignature(signature2);
  const rs2 = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest2), rs2, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger5.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/_version.js
var version7 = "transactions/5.7.0";

// node_modules/.pnpm/@ethersproject+transactions@5.7.0/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger6 = new Logger(version7);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest2, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest2), signature2));
}

// node_modules/.pnpm/uint8arrays@3.1.0/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return globalThis.Buffer.allocUnsafe(size);
  }
  return new Uint8Array(size);
}

// node_modules/.pnpm/uint8arrays@3.1.0/node_modules/uint8arrays/esm/src/concat.js
function concat2(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j6 = 0; j6 < BASE_MAP.length; j6++) {
    BASE_MAP[j6] = 255;
  }
  for (var i5 = 0; i5 < ALPHABET.length; i5++) {
    var x9 = ALPHABET.charAt(i5);
    var xc = x9.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x9 + " is ambiguous");
    }
    BASE_MAP[xc] = i5;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode6(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i6 = 0;
      for (var it1 = size - 1; (carry !== 0 || i6 < length2) && it1 !== -1; it1--, i6++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i6;
      pbegin++;
    }
    var it22 = size - length2;
    while (it22 !== size && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size; ++it22) {
      str += ALPHABET.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i6 = 0;
      for (var it32 = size - 1; (carry !== 0 || i6 < length2) && it32 !== -1; it32--, i6++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i6;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it42 = size - length2;
    while (it42 !== size && b256[it42] === 0) {
      it42++;
    }
    var vch = new Uint8Array(zeroes + (size - it42));
    var j7 = zeroes;
    while (it42 !== size) {
      vch[j7++] = b256[it42++];
    }
    return vch;
  }
  function decode6(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode6,
    decodeUnsafe,
    decode: decode6
  };
}
var src = base2;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii3 = 0; ii3 < aa.byteLength; ii3++) {
    if (aa[ii3] !== bb[ii3]) {
      return false;
    }
  }
  return true;
};
var coerce = (o6) => {
  if (o6 instanceof Uint8Array && o6.constructor.name === "Uint8Array")
    return o6;
  if (o6 instanceof ArrayBuffer)
    return new Uint8Array(o6);
  if (ArrayBuffer.isView(o6)) {
    return new Uint8Array(o6.buffer, o6.byteOffset, o6.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b4) => new TextDecoder().decode(b4);

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or2(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or2 = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name2, prefix, encode: encode6, decode: decode6 }) => new Codec(name2, prefix, encode6, decode6);
var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode6, decode: decode6 } = base_x_default(alphabet2, name2);
  return from({
    prefix,
    name: name2,
    encode: encode6,
    decode: (text) => coerce(decode6(text))
  });
};
var decode = (string2, alphabet2, bitsPerChar, name2) => {
  const codes = {};
  for (let i5 = 0; i5 < alphabet2.length; ++i5) {
    codes[alphabet2[i5]] = i5;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i5 = 0; i5 < end; ++i5) {
    const value = codes[string2[i5]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode2 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i5 = 0; i5 < data.length; ++i5) {
    buffer = buffer << 8 | data[i5];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode2(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet2, bitsPerChar, name2);
    }
  });
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p5, c5, i5) => {
  p5[i5] = c5;
  return p5;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p5, c5, i5) => {
  p5[c5.codePointAt(0)] = i5;
  return p5;
}, []);
function encode3(data) {
  return data.reduce((p5, c5) => {
    p5 += alphabetBytesToChars[c5];
    return p5;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode3,
  decode: decode2
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b4, l6 = buf.length;
  do {
    if (counter >= l6) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b4 = buf[counter++];
    res += shift < 28 ? (b4 & REST$1) << shift : (b4 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b4 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode4 = (data, offset = 0) => {
  const code2 = varint_default.decode(data, offset);
  return [
    code2,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes);
};
var decode5 = (multihash) => {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode4(bytes);
  const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest2, bytes);
};
var equals2 = (a4, b4) => {
  if (a4 === b4) {
    return true;
  } else {
    return a4.code === b4.code && a4.size === b4.size && equals(a4.bytes, b4.bytes);
  }
};
var Digest = class {
  constructor(code2, size, digest2, bytes) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name2, code: code2, encode: encode6 }) => new Hasher(name2, code2, encode6);
var Hasher = class {
  constructor(name2, code2, encode6) {
    this.name = name2;
    this.code = code2;
    this.encode = encode6;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode5 = coerce;
var digest = (input) => create(code, encode5(input));
var identity2 = {
  code,
  name,
  encode: encode5,
  digest
};

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class {
  constructor(version9, code2, multihash, bytes) {
    this.code = code2;
    this.version = version9;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes, version: version9, _baseCache } = this;
    switch (version9) {
      case 0:
        return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version9, code: code2, multihash, bytes } = value;
      return new CID(version9, code2, multihash, bytes || encodeCID(version9, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version9, multihash, code: code2 } = value;
      const digest2 = decode5(multihash);
      return CID.create(version9, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version9, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version9) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version9, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version9, code2, digest2.bytes);
        return new CID(version9, code2, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return CID.create(1, code2, digest2);
  }
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i5, length2] = decode4(initialBytes.subarray(offset));
      offset += length2;
      return i5;
    };
    let version9 = next();
    let codec = DAG_PB_CODE;
    if (version9 === 18) {
      version9 = 0;
      offset = 0;
    } else if (version9 === 1) {
      codec = next();
    }
    if (version9 !== 0 && version9 !== 1) {
      throw new RangeError(`Invalid CID version ${version9}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version9,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base3 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version9, code2, multihash) => {
  const codeOffset = encodingLength(version9);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version9, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version8 = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version8)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// node_modules/.pnpm/uint8arrays@3.1.0/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode6, decode6) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode6
    },
    decoder: { decode: decode6 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i5 = 0; i5 < buf.length; i5++) {
    string2 += String.fromCharCode(buf[i5]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i5 = 0; i5 < str.length; i5++) {
    buf[i5] = str.charCodeAt(i5);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/.pnpm/uint8arrays@3.1.0/node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(string2, "utf8");
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}

// node_modules/.pnpm/uint8arrays@3.1.0/node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}

// node_modules/.pnpm/@walletconnect+utils@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.7_ns66rv5a2qkg5opcug3atvw5u4/node_modules/@walletconnect/utils/dist/index.es.js
var import_elliptic2 = __toESM(require_elliptic());

// node_modules/.pnpm/@walletconnect+relay-api@1.0.11/node_modules/@walletconnect/relay-api/dist/index.es.js
var C5 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };

// node_modules/.pnpm/@walletconnect+utils@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.7_ns66rv5a2qkg5opcug3atvw5u4/node_modules/@walletconnect/utils/dist/index.es.js
var Pe2 = ":";
function Ye2(e4) {
  const [t3, n6] = e4.split(Pe2);
  return { namespace: t3, reference: n6 };
}
function Xe2(e4) {
  const [t3, n6, r5] = e4.split(Pe2);
  return { namespace: t3, reference: n6, address: r5 };
}
function Le2(e4, t3) {
  return e4.includes(":") ? [e4] : t3.chains || [];
}
var Ft2 = "ReactNative";
var H4 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var Gt2 = "js";
function et() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ne() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ft2;
}
function Wr2() {
  return ne() && typeof globalThis < "u" && typeof (globalThis == null ? void 0 : globalThis.Platform) < "u" && (globalThis == null ? void 0 : globalThis.Platform.OS) === "android";
}
function zr2() {
  return ne() && typeof globalThis < "u" && typeof (globalThis == null ? void 0 : globalThis.Platform) < "u" && (globalThis == null ? void 0 : globalThis.Platform.OS) === "ios";
}
function Ae2() {
  return !et() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function ue() {
  return ne() ? H4.reactNative : et() ? H4.node : Ae2() ? H4.browser : H4.unknown;
}
function Jr2() {
  var e4;
  try {
    return ne() && typeof globalThis < "u" && typeof (globalThis == null ? void 0 : globalThis.Application) < "u" ? (e4 = globalThis.Application) == null ? void 0 : e4.applicationId : void 0;
  } catch {
    return;
  }
}
function Wt2(e4, t3) {
  const n6 = new URLSearchParams(e4);
  for (const r5 of Object.keys(t3).sort())
    if (t3.hasOwnProperty(r5)) {
      const o6 = t3[r5];
      o6 !== void 0 && n6.set(r5, o6);
    }
  return n6.toString();
}
function Yr2() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function zt2() {
  if (ue() === H4.reactNative && typeof globalThis < "u" && typeof (globalThis == null ? void 0 : globalThis.Platform) < "u") {
    const { OS: n6, Version: r5 } = globalThis.Platform;
    return [n6, r5].join("-");
  }
  const e4 = detect2();
  if (e4 === null)
    return "unknown";
  const t3 = e4.os ? e4.os.replace(" ", "").toLowerCase() : "unknown";
  return e4.type === "browser" ? [t3, e4.name, e4.version].join("-") : [t3, e4.version].join("-");
}
function Jt2() {
  var e4;
  const t3 = ue();
  return t3 === H4.browser ? [t3, ((e4 = (0, import_window_getters.getLocation)()) == null ? void 0 : e4.host) || "unknown"].join(":") : t3;
}
function Yt2(e4, t3, n6) {
  const r5 = zt2(), o6 = Jt2();
  return [[e4, t3].join("-"), [Gt2, n6].join("-"), r5, o6].join("/");
}
function Zr2({ protocol: e4, version: t3, relayUrl: n6, sdkVersion: r5, auth: o6, projectId: s5, useOnCloseEvent: i5, bundleId: c5, packageName: u4 }) {
  const a4 = n6.split("?"), l6 = Yt2(e4, t3, r5), f5 = { auth: o6, ua: l6, projectId: s5, useOnCloseEvent: i5 || void 0, packageName: u4 || void 0, bundleId: c5 || void 0 }, d6 = Wt2(a4[1] || "", f5);
  return a4[0] + "?" + d6;
}
function re(e4, t3) {
  return e4.filter((n6) => t3.includes(n6)).length === e4.length;
}
function no2(e4) {
  return Object.fromEntries(e4.entries());
}
function ro2(e4) {
  return new Map(Object.entries(e4));
}
function co2(e4 = import_time3.FIVE_MINUTES, t3) {
  const n6 = (0, import_time3.toMiliseconds)(e4 || import_time3.FIVE_MINUTES);
  let r5, o6, s5, i5;
  return { resolve: (c5) => {
    s5 && r5 && (clearTimeout(s5), r5(c5), i5 = Promise.resolve(c5));
  }, reject: (c5) => {
    s5 && o6 && (clearTimeout(s5), o6(c5));
  }, done: () => new Promise((c5, u4) => {
    if (i5)
      return c5(i5);
    s5 = setTimeout(() => {
      const a4 = new Error(t3);
      i5 = Promise.reject(a4), u4(a4);
    }, n6), r5 = c5, o6 = u4;
  }) };
}
function ao2(e4, t3, n6) {
  return new Promise(async (r5, o6) => {
    const s5 = setTimeout(() => o6(new Error(n6)), t3);
    try {
      const i5 = await e4;
      r5(i5);
    } catch (i5) {
      o6(i5);
    }
    clearTimeout(s5);
  });
}
function tt(e4, t3) {
  if (typeof t3 == "string" && t3.startsWith(`${e4}:`))
    return t3;
  if (e4.toLowerCase() === "topic") {
    if (typeof t3 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t3}`;
  } else if (e4.toLowerCase() === "id") {
    if (typeof t3 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t3}`;
  }
  throw new Error(`Unknown expirer target type: ${e4}`);
}
function uo2(e4) {
  return tt("topic", e4);
}
function fo2(e4) {
  return tt("id", e4);
}
function lo2(e4) {
  const [t3, n6] = e4.split(":"), r5 = { id: void 0, topic: void 0 };
  if (t3 === "topic" && typeof n6 == "string")
    r5.topic = n6;
  else if (t3 === "id" && Number.isInteger(Number(n6)))
    r5.id = Number(n6);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${t3}:${n6}`);
  return r5;
}
function ho2(e4, t3) {
  return (0, import_time3.fromMiliseconds)((t3 || Date.now()) + (0, import_time3.toMiliseconds)(e4));
}
function po2(e4) {
  return Date.now() >= (0, import_time3.toMiliseconds)(e4);
}
function go2(e4, t3) {
  return `${e4}${t3 ? `:${t3}` : ""}`;
}
function Q3(e4 = [], t3 = []) {
  return [.../* @__PURE__ */ new Set([...e4, ...t3])];
}
async function yo2({ id: e4, topic: t3, wcDeepLink: n6 }) {
  var r5;
  try {
    if (!n6)
      return;
    const o6 = typeof n6 == "string" ? JSON.parse(n6) : n6, s5 = o6?.href;
    if (typeof s5 != "string")
      return;
    const i5 = en2(s5, e4, t3), c5 = ue();
    if (c5 === H4.browser) {
      if (!((r5 = (0, import_window_getters.getDocument)()) != null && r5.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      tn(i5);
    } else
      c5 === H4.reactNative && typeof (globalThis == null ? void 0 : globalThis.Linking) < "u" && await globalThis.Linking.openURL(i5);
  } catch (o6) {
    console.error(o6);
  }
}
function en2(e4, t3, n6) {
  const r5 = `requestId=${t3}&sessionTopic=${n6}`;
  e4.endsWith("/") && (e4 = e4.slice(0, -1));
  let o6 = `${e4}`;
  if (e4.startsWith("https://t.me")) {
    const s5 = e4.includes("?") ? "&startapp=" : "?startapp=";
    o6 = `${o6}${s5}${on2(r5, true)}`;
  } else
    o6 = `${o6}/wc?${r5}`;
  return o6;
}
function tn(e4) {
  let t3 = "_self";
  rn2() ? t3 = "_top" : (nn2() || e4.startsWith("https://") || e4.startsWith("http://")) && (t3 = "_blank"), window.open(e4, t3, "noreferrer noopener");
}
async function mo2(e4, t3) {
  let n6 = "";
  try {
    if (Ae2() && (n6 = localStorage.getItem(t3), n6))
      return n6;
    n6 = await e4.getItem(t3);
  } catch (r5) {
    console.error(r5);
  }
  return n6;
}
function bo2(e4, t3) {
  if (!e4.includes(t3))
    return null;
  const n6 = e4.split(/([&,?,=])/), r5 = n6.indexOf(t3);
  return n6[r5 + 2];
}
function wo2() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (e4) => {
    const t3 = Math.random() * 16 | 0;
    return (e4 === "x" ? t3 : t3 & 3 | 8).toString(16);
  });
}
function Eo2() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function nn2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function rn2() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function on2(e4, t3 = false) {
  const n6 = Buffer.from(e4).toString("base64");
  return t3 ? n6.replace(/[=]/g, "") : n6;
}
function rt2(e4) {
  return Buffer.from(e4, "base64").toString("utf-8");
}
function vo2(e4) {
  return new Promise((t3) => setTimeout(t3, e4));
}
function Ne2(e4) {
  if (!Number.isSafeInteger(e4) || e4 < 0)
    throw new Error("positive integer expected, got " + e4);
}
function xo2(e4) {
  return e4 instanceof Uint8Array || ArrayBuffer.isView(e4) && e4.constructor.name === "Uint8Array";
}
function je2(e4, ...t3) {
  if (!xo2(e4))
    throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e4.length))
    throw new Error("Uint8Array expected of length " + t3 + ", got length=" + e4.length);
}
function ot(e4) {
  if (typeof e4 != "function" || typeof e4.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne2(e4.outputLen), Ne2(e4.blockLen);
}
function me2(e4, t3 = true) {
  if (e4.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t3 && e4.finished)
    throw new Error("Hash#digest() has already been called");
}
function sn2(e4, t3) {
  je2(e4);
  const n6 = t3.outputLen;
  if (e4.length < n6)
    throw new Error("digestInto() expects output buffer of length at least " + n6);
}
var Ce2 = BigInt(2 ** 32 - 1);
var cn = BigInt(32);
function Oo2(e4, t3 = false) {
  return t3 ? { h: Number(e4 & Ce2), l: Number(e4 >> cn & Ce2) } : { h: Number(e4 >> cn & Ce2) | 0, l: Number(e4 & Ce2) | 0 };
}
function Io2(e4, t3 = false) {
  let n6 = new Uint32Array(e4.length), r5 = new Uint32Array(e4.length);
  for (let o6 = 0; o6 < e4.length; o6++) {
    const { h: s5, l: i5 } = Oo2(e4[o6], t3);
    [n6[o6], r5[o6]] = [s5, i5];
  }
  return [n6, r5];
}
var Ao2 = (e4, t3, n6) => e4 << n6 | t3 >>> 32 - n6;
var No2 = (e4, t3, n6) => t3 << n6 | e4 >>> 32 - n6;
var So2 = (e4, t3, n6) => t3 << n6 - 32 | e4 >>> 64 - n6;
var Uo2 = (e4, t3, n6) => e4 << n6 - 32 | t3 >>> 64 - n6;
var be2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function _o2(e4) {
  return new Uint32Array(e4.buffer, e4.byteOffset, Math.floor(e4.byteLength / 4));
}
function st(e4) {
  return new DataView(e4.buffer, e4.byteOffset, e4.byteLength);
}
function J3(e4, t3) {
  return e4 << 32 - t3 | e4 >>> t3;
}
var an = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function To2(e4) {
  return e4 << 24 & 4278190080 | e4 << 8 & 16711680 | e4 >>> 8 & 65280 | e4 >>> 24 & 255;
}
function un(e4) {
  for (let t3 = 0; t3 < e4.length; t3++)
    e4[t3] = To2(e4[t3]);
}
function $o2(e4) {
  if (typeof e4 != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof e4);
  return new Uint8Array(new TextEncoder().encode(e4));
}
function we2(e4) {
  return typeof e4 == "string" && (e4 = $o2(e4)), je2(e4), e4;
}
var it2 = class {
  clone() {
    return this._cloneInto();
  }
};
function fn(e4) {
  const t3 = (r5) => e4().update(we2(r5)).digest(), n6 = e4();
  return t3.outputLen = n6.outputLen, t3.blockLen = n6.blockLen, t3.create = () => e4(), t3;
}
function Se2(e4 = 32) {
  if (be2 && typeof be2.getRandomValues == "function")
    return be2.getRandomValues(new Uint8Array(e4));
  if (be2 && typeof be2.randomBytes == "function")
    return be2.randomBytes(e4);
  throw new Error("crypto.getRandomValues must be defined");
}
var ln = [];
var dn = [];
var hn = [];
var Ro2 = BigInt(0);
var Ue2 = BigInt(1);
var Po2 = BigInt(2);
var Lo2 = BigInt(7);
var Bo2 = BigInt(256);
var jo2 = BigInt(113);
for (let e4 = 0, t3 = Ue2, n6 = 1, r5 = 0; e4 < 24; e4++) {
  [n6, r5] = [r5, (2 * n6 + 3 * r5) % 5], ln.push(2 * (5 * r5 + n6)), dn.push((e4 + 1) * (e4 + 2) / 2 % 64);
  let o6 = Ro2;
  for (let s5 = 0; s5 < 7; s5++)
    t3 = (t3 << Ue2 ^ (t3 >> Lo2) * jo2) % Bo2, t3 & Po2 && (o6 ^= Ue2 << (Ue2 << BigInt(s5)) - Ue2);
  hn.push(o6);
}
var [Co2, ko2] = Io2(hn, true);
var pn = (e4, t3, n6) => n6 > 32 ? So2(e4, t3, n6) : Ao2(e4, t3, n6);
var gn2 = (e4, t3, n6) => n6 > 32 ? Uo2(e4, t3, n6) : No2(e4, t3, n6);
function Do2(e4, t3 = 24) {
  const n6 = new Uint32Array(10);
  for (let r5 = 24 - t3; r5 < 24; r5++) {
    for (let i5 = 0; i5 < 10; i5++)
      n6[i5] = e4[i5] ^ e4[i5 + 10] ^ e4[i5 + 20] ^ e4[i5 + 30] ^ e4[i5 + 40];
    for (let i5 = 0; i5 < 10; i5 += 2) {
      const c5 = (i5 + 8) % 10, u4 = (i5 + 2) % 10, a4 = n6[u4], l6 = n6[u4 + 1], f5 = pn(a4, l6, 1) ^ n6[c5], d6 = gn2(a4, l6, 1) ^ n6[c5 + 1];
      for (let g6 = 0; g6 < 50; g6 += 10)
        e4[i5 + g6] ^= f5, e4[i5 + g6 + 1] ^= d6;
    }
    let o6 = e4[2], s5 = e4[3];
    for (let i5 = 0; i5 < 24; i5++) {
      const c5 = dn[i5], u4 = pn(o6, s5, c5), a4 = gn2(o6, s5, c5), l6 = ln[i5];
      o6 = e4[l6], s5 = e4[l6 + 1], e4[l6] = u4, e4[l6 + 1] = a4;
    }
    for (let i5 = 0; i5 < 50; i5 += 10) {
      for (let c5 = 0; c5 < 10; c5++)
        n6[c5] = e4[i5 + c5];
      for (let c5 = 0; c5 < 10; c5++)
        e4[i5 + c5] ^= ~n6[(c5 + 2) % 10] & n6[(c5 + 4) % 10];
    }
    e4[0] ^= Co2[r5], e4[1] ^= ko2[r5];
  }
  n6.fill(0);
}
var Bt2 = class extends it2 {
  constructor(t3, n6, r5, o6 = false, s5 = 24) {
    if (super(), this.blockLen = t3, this.suffix = n6, this.outputLen = r5, this.enableXOF = o6, this.rounds = s5, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Ne2(r5), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = _o2(this.state);
  }
  keccak() {
    an || un(this.state32), Do2(this.state32, this.rounds), an || un(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t3) {
    me2(this);
    const { blockLen: n6, state: r5 } = this;
    t3 = we2(t3);
    const o6 = t3.length;
    for (let s5 = 0; s5 < o6; ) {
      const i5 = Math.min(n6 - this.pos, o6 - s5);
      for (let c5 = 0; c5 < i5; c5++)
        r5[this.pos++] ^= t3[s5++];
      this.pos === n6 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: t3, suffix: n6, pos: r5, blockLen: o6 } = this;
    t3[r5] ^= n6, n6 & 128 && r5 === o6 - 1 && this.keccak(), t3[o6 - 1] ^= 128, this.keccak();
  }
  writeInto(t3) {
    me2(this, false), je2(t3), this.finish();
    const n6 = this.state, { blockLen: r5 } = this;
    for (let o6 = 0, s5 = t3.length; o6 < s5; ) {
      this.posOut >= r5 && this.keccak();
      const i5 = Math.min(r5 - this.posOut, s5 - o6);
      t3.set(n6.subarray(this.posOut, this.posOut + i5), o6), this.posOut += i5, o6 += i5;
    }
    return t3;
  }
  xofInto(t3) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t3);
  }
  xof(t3) {
    return Ne2(t3), this.xofInto(new Uint8Array(t3));
  }
  digestInto(t3) {
    if (sn2(t3, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t3), this.destroy(), t3;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t3) {
    const { blockLen: n6, suffix: r5, outputLen: o6, rounds: s5, enableXOF: i5 } = this;
    return t3 || (t3 = new Bt2(n6, r5, o6, i5, s5)), t3.state32.set(this.state32), t3.pos = this.pos, t3.posOut = this.posOut, t3.finished = this.finished, t3.rounds = s5, t3.suffix = r5, t3.outputLen = o6, t3.enableXOF = i5, t3.destroyed = this.destroyed, t3;
  }
};
var Mo2 = (e4, t3, n6) => fn(() => new Bt2(t3, e4, n6));
var Vo2 = Mo2(1, 136, 256 / 8);
var Ho2 = "https://rpc.walletconnect.org/v1";
function ct2(e4) {
  const t3 = `Ethereum Signed Message:
${e4.length}`, n6 = new TextEncoder().encode(t3 + e4);
  return "0x" + Buffer.from(Vo2(n6)).toString("hex");
}
async function yn2(e4, t3, n6, r5, o6, s5) {
  switch (n6.t) {
    case "eip191":
      return mn2(e4, t3, n6.s);
    case "eip1271":
      return await bn2(e4, t3, n6.s, r5, o6, s5);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n6.t}`);
  }
}
function mn2(e4, t3, n6) {
  return recoverAddress(ct2(t3), n6).toLowerCase() === e4.toLowerCase();
}
async function bn2(e4, t3, n6, r5, o6, s5) {
  const i5 = Ye2(r5);
  if (!i5.namespace || !i5.reference)
    throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r5}`);
  try {
    const c5 = "0x1626ba7e", u4 = "0000000000000000000000000000000000000000000000000000000000000040", a4 = "0000000000000000000000000000000000000000000000000000000000000041", l6 = n6.substring(2), f5 = ct2(t3).substring(2), d6 = c5 + f5 + u4 + a4 + l6, g6 = await fetch(`${s5 || Ho2}/?chainId=${r5}&projectId=${o6}`, { method: "POST", body: JSON.stringify({ id: Ko2(), jsonrpc: "2.0", method: "eth_call", params: [{ to: e4, data: d6 }, "latest"] }) }), { result: y7 } = await g6.json();
    return y7 ? y7.slice(0, c5.length).toLowerCase() === c5.toLowerCase() : false;
  } catch (c5) {
    return console.error("isValidEip1271Signature: ", c5), false;
  }
}
function Ko2() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Fo2 = Object.defineProperty;
var qo2 = Object.defineProperties;
var Go2 = Object.getOwnPropertyDescriptors;
var wn = Object.getOwnPropertySymbols;
var Wo2 = Object.prototype.hasOwnProperty;
var zo2 = Object.prototype.propertyIsEnumerable;
var En2 = (e4, t3, n6) => t3 in e4 ? Fo2(e4, t3, { enumerable: true, configurable: true, writable: true, value: n6 }) : e4[t3] = n6;
var at = (e4, t3) => {
  for (var n6 in t3 || (t3 = {}))
    Wo2.call(t3, n6) && En2(e4, n6, t3[n6]);
  if (wn)
    for (var n6 of wn(t3))
      zo2.call(t3, n6) && En2(e4, n6, t3[n6]);
  return e4;
};
var vn2 = (e4, t3) => qo2(e4, Go2(t3));
var Jo2 = "did:pkh:";
var ke2 = (e4) => e4?.split(":");
var xn2 = (e4) => {
  const t3 = e4 && ke2(e4);
  if (t3)
    return e4.includes(Jo2) ? t3[3] : t3[1];
};
var On2 = (e4) => {
  const t3 = e4 && ke2(e4);
  if (t3)
    return t3[2] + ":" + t3[3];
};
var ut2 = (e4) => {
  const t3 = e4 && ke2(e4);
  if (t3)
    return t3.pop();
};
async function Yo2(e4) {
  const { cacao: t3, projectId: n6 } = e4, { s: r5, p: o6 } = t3, s5 = In2(o6, o6.iss), i5 = ut2(o6.iss);
  return await yn2(i5, s5, r5, On2(o6.iss), n6);
}
var In2 = (e4, t3) => {
  const n6 = `${e4.domain} wants you to sign in with your Ethereum account:`, r5 = ut2(t3);
  if (!e4.aud && !e4.uri)
    throw new Error("Either `aud` or `uri` is required to construct the message");
  let o6 = e4.statement || void 0;
  const s5 = `URI: ${e4.aud || e4.uri}`, i5 = `Version: ${e4.version}`, c5 = `Chain ID: ${xn2(t3)}`, u4 = `Nonce: ${e4.nonce}`, a4 = `Issued At: ${e4.iat}`, l6 = e4.exp ? `Expiration Time: ${e4.exp}` : void 0, f5 = e4.nbf ? `Not Before: ${e4.nbf}` : void 0, d6 = e4.requestId ? `Request ID: ${e4.requestId}` : void 0, g6 = e4.resources ? `Resources:${e4.resources.map((h7) => `
- ${h7}`).join("")}` : void 0, y7 = Me2(e4.resources);
  if (y7) {
    const h7 = oe(y7);
    o6 = dt2(o6, h7);
  }
  return [n6, r5, "", o6, "", s5, i5, c5, u4, a4, l6, f5, d6, g6].filter((h7) => h7 != null).join(`
`);
};
function Un2(e4) {
  return Buffer.from(JSON.stringify(e4)).toString("base64");
}
function _n2(e4) {
  return JSON.parse(Buffer.from(e4, "base64").toString("utf-8"));
}
function Y2(e4) {
  if (!e4)
    throw new Error("No recap provided, value is undefined");
  if (!e4.att)
    throw new Error("No `att` property found");
  const t3 = Object.keys(e4.att);
  if (!(t3 != null && t3.length))
    throw new Error("No resources found in `att` property");
  t3.forEach((n6) => {
    const r5 = e4.att[n6];
    if (Array.isArray(r5))
      throw new Error(`Resource must be an object: ${n6}`);
    if (typeof r5 != "object")
      throw new Error(`Resource must be an object: ${n6}`);
    if (!Object.keys(r5).length)
      throw new Error(`Resource object is empty: ${n6}`);
    Object.keys(r5).forEach((o6) => {
      const s5 = r5[o6];
      if (!Array.isArray(s5))
        throw new Error(`Ability limits ${o6} must be an array of objects, found: ${s5}`);
      if (!s5.length)
        throw new Error(`Value of ${o6} is empty array, must be an array with objects`);
      s5.forEach((i5) => {
        if (typeof i5 != "object")
          throw new Error(`Ability limits (${o6}) must be an array of objects, found: ${i5}`);
      });
    });
  });
}
function Tn2(e4, t3, n6, r5 = {}) {
  return n6?.sort((o6, s5) => o6.localeCompare(s5)), { att: { [e4]: ft2(t3, n6, r5) } };
}
function ft2(e4, t3, n6 = {}) {
  t3 = t3?.sort((o6, s5) => o6.localeCompare(s5));
  const r5 = t3.map((o6) => ({ [`${e4}/${o6}`]: [n6] }));
  return Object.assign({}, ...r5);
}
function De2(e4) {
  return Y2(e4), `urn:recap:${Un2(e4).replace(/=/g, "")}`;
}
function oe(e4) {
  const t3 = _n2(e4.replace("urn:recap:", ""));
  return Y2(t3), t3;
}
function ts(e4, t3, n6) {
  const r5 = Tn2(e4, t3, n6);
  return De2(r5);
}
function lt2(e4) {
  return e4 && e4.includes("urn:recap:");
}
function ns(e4, t3) {
  const n6 = oe(e4), r5 = oe(t3), o6 = Rn2(n6, r5);
  return De2(o6);
}
function Rn2(e4, t3) {
  Y2(e4), Y2(t3);
  const n6 = Object.keys(e4.att).concat(Object.keys(t3.att)).sort((o6, s5) => o6.localeCompare(s5)), r5 = { att: {} };
  return n6.forEach((o6) => {
    var s5, i5;
    Object.keys(((s5 = e4.att) == null ? void 0 : s5[o6]) || {}).concat(Object.keys(((i5 = t3.att) == null ? void 0 : i5[o6]) || {})).sort((c5, u4) => c5.localeCompare(u4)).forEach((c5) => {
      var u4, a4;
      r5.att[o6] = vn2(at({}, r5.att[o6]), { [c5]: ((u4 = e4.att[o6]) == null ? void 0 : u4[c5]) || ((a4 = t3.att[o6]) == null ? void 0 : a4[c5]) });
    });
  }), r5;
}
function dt2(e4 = "", t3) {
  Y2(t3);
  const n6 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (e4.includes(n6))
    return e4;
  const r5 = [];
  let o6 = 0;
  Object.keys(t3.att).forEach((c5) => {
    const u4 = Object.keys(t3.att[c5]).map((f5) => ({ ability: f5.split("/")[0], action: f5.split("/")[1] }));
    u4.sort((f5, d6) => f5.action.localeCompare(d6.action));
    const a4 = {};
    u4.forEach((f5) => {
      a4[f5.ability] || (a4[f5.ability] = []), a4[f5.ability].push(f5.action);
    });
    const l6 = Object.keys(a4).map((f5) => (o6++, `(${o6}) '${f5}': '${a4[f5].join("', '")}' for '${c5}'.`));
    r5.push(l6.join(", ").replace(".,", "."));
  });
  const s5 = r5.join(" "), i5 = `${n6}${s5}`;
  return `${e4 ? e4 + " " : ""}${i5}`;
}
function rs(e4) {
  var t3;
  const n6 = oe(e4);
  Y2(n6);
  const r5 = (t3 = n6.att) == null ? void 0 : t3.eip155;
  return r5 ? Object.keys(r5).map((o6) => o6.split("/")[1]) : [];
}
function os(e4) {
  const t3 = oe(e4);
  Y2(t3);
  const n6 = [];
  return Object.values(t3.att).forEach((r5) => {
    Object.values(r5).forEach((o6) => {
      var s5;
      (s5 = o6?.[0]) != null && s5.chains && n6.push(o6[0].chains);
    });
  }), [...new Set(n6.flat())];
}
function Me2(e4) {
  if (!e4)
    return;
  const t3 = e4?.[e4.length - 1];
  return lt2(t3) ? t3 : void 0;
}
function ht2(e4) {
  if (!Number.isSafeInteger(e4) || e4 < 0)
    throw new Error("positive integer expected, got " + e4);
}
function Ln2(e4) {
  return e4 instanceof Uint8Array || ArrayBuffer.isView(e4) && e4.constructor.name === "Uint8Array";
}
function F3(e4, ...t3) {
  if (!Ln2(e4))
    throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e4.length))
    throw new Error("Uint8Array expected of length " + t3 + ", got length=" + e4.length);
}
function Bn2(e4, t3 = true) {
  if (e4.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t3 && e4.finished)
    throw new Error("Hash#digest() has already been called");
}
function ss(e4, t3) {
  F3(e4);
  const n6 = t3.outputLen;
  if (e4.length < n6)
    throw new Error("digestInto() expects output buffer of length at least " + n6);
}
function jn2(e4) {
  if (typeof e4 != "boolean")
    throw new Error(`boolean expected, not ${e4}`);
}
var se = (e4) => new Uint32Array(e4.buffer, e4.byteOffset, Math.floor(e4.byteLength / 4));
var is = (e4) => new DataView(e4.buffer, e4.byteOffset, e4.byteLength);
var cs = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!cs)
  throw new Error("Non little-endian hardware is not supported");
function as(e4) {
  if (typeof e4 != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e4));
}
function pt(e4) {
  if (typeof e4 == "string")
    e4 = as(e4);
  else if (Ln2(e4))
    e4 = gt2(e4);
  else
    throw new Error("Uint8Array expected, got " + typeof e4);
  return e4;
}
function us(e4, t3) {
  if (t3 == null || typeof t3 != "object")
    throw new Error("options must be defined");
  return Object.assign(e4, t3);
}
function fs(e4, t3) {
  if (e4.length !== t3.length)
    return false;
  let n6 = 0;
  for (let r5 = 0; r5 < e4.length; r5++)
    n6 |= e4[r5] ^ t3[r5];
  return n6 === 0;
}
var ls = (e4, t3) => {
  function n6(r5, ...o6) {
    if (F3(r5), e4.nonceLength !== void 0) {
      const l6 = o6[0];
      if (!l6)
        throw new Error("nonce / iv required");
      e4.varSizeNonce ? F3(l6) : F3(l6, e4.nonceLength);
    }
    const s5 = e4.tagLength;
    s5 && o6[1] !== void 0 && F3(o6[1]);
    const i5 = t3(r5, ...o6), c5 = (l6, f5) => {
      if (f5 !== void 0) {
        if (l6 !== 2)
          throw new Error("cipher output not supported");
        F3(f5);
      }
    };
    let u4 = false;
    return { encrypt(l6, f5) {
      if (u4)
        throw new Error("cannot encrypt() twice with same key + nonce");
      return u4 = true, F3(l6), c5(i5.encrypt.length, f5), i5.encrypt(l6, f5);
    }, decrypt(l6, f5) {
      if (F3(l6), s5 && l6.length < s5)
        throw new Error("invalid ciphertext length: smaller than tagLength=" + s5);
      return c5(i5.decrypt.length, f5), i5.decrypt(l6, f5);
    } };
  }
  return Object.assign(n6, e4), n6;
};
function Cn2(e4, t3, n6 = true) {
  if (t3 === void 0)
    return new Uint8Array(e4);
  if (t3.length !== e4)
    throw new Error("invalid output length, expected " + e4 + ", got: " + t3.length);
  if (n6 && !ds(t3))
    throw new Error("invalid output, must be aligned");
  return t3;
}
function kn2(e4, t3, n6, r5) {
  if (typeof e4.setBigUint64 == "function")
    return e4.setBigUint64(t3, n6, r5);
  const o6 = BigInt(32), s5 = BigInt(4294967295), i5 = Number(n6 >> o6 & s5), c5 = Number(n6 & s5), u4 = r5 ? 4 : 0, a4 = r5 ? 0 : 4;
  e4.setUint32(t3 + u4, i5, r5), e4.setUint32(t3 + a4, c5, r5);
}
function ds(e4) {
  return e4.byteOffset % 4 === 0;
}
function gt2(e4) {
  return Uint8Array.from(e4);
}
function Ee2(...e4) {
  for (let t3 = 0; t3 < e4.length; t3++)
    e4[t3].fill(0);
}
var Dn = (e4) => Uint8Array.from(e4.split("").map((t3) => t3.charCodeAt(0)));
var hs = Dn("expand 16-byte k");
var ps = Dn("expand 32-byte k");
var gs = se(hs);
var ys = se(ps);
function x7(e4, t3) {
  return e4 << t3 | e4 >>> 32 - t3;
}
function yt2(e4) {
  return e4.byteOffset % 4 === 0;
}
var Ve2 = 64;
var ms = 16;
var Mn2 = 2 ** 32 - 1;
var Vn2 = new Uint32Array();
function bs(e4, t3, n6, r5, o6, s5, i5, c5) {
  const u4 = o6.length, a4 = new Uint8Array(Ve2), l6 = se(a4), f5 = yt2(o6) && yt2(s5), d6 = f5 ? se(o6) : Vn2, g6 = f5 ? se(s5) : Vn2;
  for (let y7 = 0; y7 < u4; i5++) {
    if (e4(t3, n6, r5, l6, i5, c5), i5 >= Mn2)
      throw new Error("arx: counter overflow");
    const h7 = Math.min(Ve2, u4 - y7);
    if (f5 && h7 === Ve2) {
      const m4 = y7 / 4;
      if (y7 % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let B4 = 0, b4; B4 < ms; B4++)
        b4 = m4 + B4, g6[b4] = d6[b4] ^ l6[B4];
      y7 += Ve2;
      continue;
    }
    for (let m4 = 0, B4; m4 < h7; m4++)
      B4 = y7 + m4, s5[B4] = o6[B4] ^ a4[m4];
    y7 += h7;
  }
}
function ws(e4, t3) {
  const { allowShortKeys: n6, extendNonceFn: r5, counterLength: o6, counterRight: s5, rounds: i5 } = us({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t3);
  if (typeof e4 != "function")
    throw new Error("core must be a function");
  return ht2(o6), ht2(i5), jn2(s5), jn2(n6), (c5, u4, a4, l6, f5 = 0) => {
    F3(c5), F3(u4), F3(a4);
    const d6 = a4.length;
    if (l6 === void 0 && (l6 = new Uint8Array(d6)), F3(l6), ht2(f5), f5 < 0 || f5 >= Mn2)
      throw new Error("arx: counter overflow");
    if (l6.length < d6)
      throw new Error(`arx: output (${l6.length}) is shorter than data (${d6})`);
    const g6 = [];
    let y7 = c5.length, h7, m4;
    if (y7 === 32)
      g6.push(h7 = gt2(c5)), m4 = ys;
    else if (y7 === 16 && n6)
      h7 = new Uint8Array(32), h7.set(c5), h7.set(c5, 16), m4 = gs, g6.push(h7);
    else
      throw new Error(`arx: invalid 32-byte key, got length=${y7}`);
    yt2(u4) || g6.push(u4 = gt2(u4));
    const B4 = se(h7);
    if (r5) {
      if (u4.length !== 24)
        throw new Error("arx: extended nonce must be 24 bytes");
      r5(m4, B4, se(u4.subarray(0, 16)), B4), u4 = u4.subarray(16);
    }
    const b4 = 16 - o6;
    if (b4 !== u4.length)
      throw new Error(`arx: nonce must be ${b4} or 16 bytes`);
    if (b4 !== 12) {
      const I5 = new Uint8Array(12);
      I5.set(u4, s5 ? 0 : 12 - u4.length), u4 = I5, g6.push(u4);
    }
    const _7 = se(u4);
    return bs(e4, m4, B4, _7, a4, l6, f5, i5), Ee2(...g6), l6;
  };
}
var M5 = (e4, t3) => e4[t3++] & 255 | (e4[t3++] & 255) << 8;
var Es = class {
  constructor(t3) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, t3 = pt(t3), F3(t3, 32);
    const n6 = M5(t3, 0), r5 = M5(t3, 2), o6 = M5(t3, 4), s5 = M5(t3, 6), i5 = M5(t3, 8), c5 = M5(t3, 10), u4 = M5(t3, 12), a4 = M5(t3, 14);
    this.r[0] = n6 & 8191, this.r[1] = (n6 >>> 13 | r5 << 3) & 8191, this.r[2] = (r5 >>> 10 | o6 << 6) & 7939, this.r[3] = (o6 >>> 7 | s5 << 9) & 8191, this.r[4] = (s5 >>> 4 | i5 << 12) & 255, this.r[5] = i5 >>> 1 & 8190, this.r[6] = (i5 >>> 14 | c5 << 2) & 8191, this.r[7] = (c5 >>> 11 | u4 << 5) & 8065, this.r[8] = (u4 >>> 8 | a4 << 8) & 8191, this.r[9] = a4 >>> 5 & 127;
    for (let l6 = 0; l6 < 8; l6++)
      this.pad[l6] = M5(t3, 16 + 2 * l6);
  }
  process(t3, n6, r5 = false) {
    const o6 = r5 ? 0 : 2048, { h: s5, r: i5 } = this, c5 = i5[0], u4 = i5[1], a4 = i5[2], l6 = i5[3], f5 = i5[4], d6 = i5[5], g6 = i5[6], y7 = i5[7], h7 = i5[8], m4 = i5[9], B4 = M5(t3, n6 + 0), b4 = M5(t3, n6 + 2), _7 = M5(t3, n6 + 4), I5 = M5(t3, n6 + 6), k7 = M5(t3, n6 + 8), E7 = M5(t3, n6 + 10), L5 = M5(t3, n6 + 12), j6 = M5(t3, n6 + 14);
    let v8 = s5[0] + (B4 & 8191), O4 = s5[1] + ((B4 >>> 13 | b4 << 3) & 8191), w6 = s5[2] + ((b4 >>> 10 | _7 << 6) & 8191), R3 = s5[3] + ((_7 >>> 7 | I5 << 9) & 8191), A7 = s5[4] + ((I5 >>> 4 | k7 << 12) & 8191), T6 = s5[5] + (k7 >>> 1 & 8191), N10 = s5[6] + ((k7 >>> 14 | E7 << 2) & 8191), S4 = s5[7] + ((E7 >>> 11 | L5 << 5) & 8191), U3 = s5[8] + ((L5 >>> 8 | j6 << 8) & 8191), $4 = s5[9] + (j6 >>> 5 | o6), p5 = 0, C7 = p5 + v8 * c5 + O4 * (5 * m4) + w6 * (5 * h7) + R3 * (5 * y7) + A7 * (5 * g6);
    p5 = C7 >>> 13, C7 &= 8191, C7 += T6 * (5 * d6) + N10 * (5 * f5) + S4 * (5 * l6) + U3 * (5 * a4) + $4 * (5 * u4), p5 += C7 >>> 13, C7 &= 8191;
    let D5 = p5 + v8 * u4 + O4 * c5 + w6 * (5 * m4) + R3 * (5 * h7) + A7 * (5 * y7);
    p5 = D5 >>> 13, D5 &= 8191, D5 += T6 * (5 * g6) + N10 * (5 * d6) + S4 * (5 * f5) + U3 * (5 * l6) + $4 * (5 * a4), p5 += D5 >>> 13, D5 &= 8191;
    let P4 = p5 + v8 * a4 + O4 * u4 + w6 * c5 + R3 * (5 * m4) + A7 * (5 * h7);
    p5 = P4 >>> 13, P4 &= 8191, P4 += T6 * (5 * y7) + N10 * (5 * g6) + S4 * (5 * d6) + U3 * (5 * f5) + $4 * (5 * l6), p5 += P4 >>> 13, P4 &= 8191;
    let G3 = p5 + v8 * l6 + O4 * a4 + w6 * u4 + R3 * c5 + A7 * (5 * m4);
    p5 = G3 >>> 13, G3 &= 8191, G3 += T6 * (5 * h7) + N10 * (5 * y7) + S4 * (5 * g6) + U3 * (5 * d6) + $4 * (5 * f5), p5 += G3 >>> 13, G3 &= 8191;
    let X3 = p5 + v8 * f5 + O4 * l6 + w6 * a4 + R3 * u4 + A7 * c5;
    p5 = X3 >>> 13, X3 &= 8191, X3 += T6 * (5 * m4) + N10 * (5 * h7) + S4 * (5 * y7) + U3 * (5 * g6) + $4 * (5 * d6), p5 += X3 >>> 13, X3 &= 8191;
    let Z3 = p5 + v8 * d6 + O4 * f5 + w6 * l6 + R3 * a4 + A7 * u4;
    p5 = Z3 >>> 13, Z3 &= 8191, Z3 += T6 * c5 + N10 * (5 * m4) + S4 * (5 * h7) + U3 * (5 * y7) + $4 * (5 * g6), p5 += Z3 >>> 13, Z3 &= 8191;
    let he3 = p5 + v8 * g6 + O4 * d6 + w6 * f5 + R3 * l6 + A7 * a4;
    p5 = he3 >>> 13, he3 &= 8191, he3 += T6 * u4 + N10 * c5 + S4 * (5 * m4) + U3 * (5 * h7) + $4 * (5 * y7), p5 += he3 >>> 13, he3 &= 8191;
    let pe2 = p5 + v8 * y7 + O4 * g6 + w6 * d6 + R3 * f5 + A7 * l6;
    p5 = pe2 >>> 13, pe2 &= 8191, pe2 += T6 * a4 + N10 * u4 + S4 * c5 + U3 * (5 * m4) + $4 * (5 * h7), p5 += pe2 >>> 13, pe2 &= 8191;
    let ge2 = p5 + v8 * h7 + O4 * y7 + w6 * g6 + R3 * d6 + A7 * f5;
    p5 = ge2 >>> 13, ge2 &= 8191, ge2 += T6 * l6 + N10 * a4 + S4 * u4 + U3 * c5 + $4 * (5 * m4), p5 += ge2 >>> 13, ge2 &= 8191;
    let ye4 = p5 + v8 * m4 + O4 * h7 + w6 * y7 + R3 * g6 + A7 * d6;
    p5 = ye4 >>> 13, ye4 &= 8191, ye4 += T6 * f5 + N10 * l6 + S4 * a4 + U3 * u4 + $4 * c5, p5 += ye4 >>> 13, ye4 &= 8191, p5 = (p5 << 2) + p5 | 0, p5 = p5 + C7 | 0, C7 = p5 & 8191, p5 = p5 >>> 13, D5 += p5, s5[0] = C7, s5[1] = D5, s5[2] = P4, s5[3] = G3, s5[4] = X3, s5[5] = Z3, s5[6] = he3, s5[7] = pe2, s5[8] = ge2, s5[9] = ye4;
  }
  finalize() {
    const { h: t3, pad: n6 } = this, r5 = new Uint16Array(10);
    let o6 = t3[1] >>> 13;
    t3[1] &= 8191;
    for (let c5 = 2; c5 < 10; c5++)
      t3[c5] += o6, o6 = t3[c5] >>> 13, t3[c5] &= 8191;
    t3[0] += o6 * 5, o6 = t3[0] >>> 13, t3[0] &= 8191, t3[1] += o6, o6 = t3[1] >>> 13, t3[1] &= 8191, t3[2] += o6, r5[0] = t3[0] + 5, o6 = r5[0] >>> 13, r5[0] &= 8191;
    for (let c5 = 1; c5 < 10; c5++)
      r5[c5] = t3[c5] + o6, o6 = r5[c5] >>> 13, r5[c5] &= 8191;
    r5[9] -= 8192;
    let s5 = (o6 ^ 1) - 1;
    for (let c5 = 0; c5 < 10; c5++)
      r5[c5] &= s5;
    s5 = ~s5;
    for (let c5 = 0; c5 < 10; c5++)
      t3[c5] = t3[c5] & s5 | r5[c5];
    t3[0] = (t3[0] | t3[1] << 13) & 65535, t3[1] = (t3[1] >>> 3 | t3[2] << 10) & 65535, t3[2] = (t3[2] >>> 6 | t3[3] << 7) & 65535, t3[3] = (t3[3] >>> 9 | t3[4] << 4) & 65535, t3[4] = (t3[4] >>> 12 | t3[5] << 1 | t3[6] << 14) & 65535, t3[5] = (t3[6] >>> 2 | t3[7] << 11) & 65535, t3[6] = (t3[7] >>> 5 | t3[8] << 8) & 65535, t3[7] = (t3[8] >>> 8 | t3[9] << 5) & 65535;
    let i5 = t3[0] + n6[0];
    t3[0] = i5 & 65535;
    for (let c5 = 1; c5 < 8; c5++)
      i5 = (t3[c5] + n6[c5] | 0) + (i5 >>> 16) | 0, t3[c5] = i5 & 65535;
    Ee2(r5);
  }
  update(t3) {
    Bn2(this);
    const { buffer: n6, blockLen: r5 } = this;
    t3 = pt(t3);
    const o6 = t3.length;
    for (let s5 = 0; s5 < o6; ) {
      const i5 = Math.min(r5 - this.pos, o6 - s5);
      if (i5 === r5) {
        for (; r5 <= o6 - s5; s5 += r5)
          this.process(t3, s5);
        continue;
      }
      n6.set(t3.subarray(s5, s5 + i5), this.pos), this.pos += i5, s5 += i5, this.pos === r5 && (this.process(n6, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Ee2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(t3) {
    Bn2(this), ss(t3, this), this.finished = true;
    const { buffer: n6, h: r5 } = this;
    let { pos: o6 } = this;
    if (o6) {
      for (n6[o6++] = 1; o6 < 16; o6++)
        n6[o6] = 0;
      this.process(n6, 0, true);
    }
    this.finalize();
    let s5 = 0;
    for (let i5 = 0; i5 < 8; i5++)
      t3[s5++] = r5[i5] >>> 0, t3[s5++] = r5[i5] >>> 8;
    return t3;
  }
  digest() {
    const { buffer: t3, outputLen: n6 } = this;
    this.digestInto(t3);
    const r5 = t3.slice(0, n6);
    return this.destroy(), r5;
  }
};
function vs(e4) {
  const t3 = (r5, o6) => e4(o6).update(pt(r5)).digest(), n6 = e4(new Uint8Array(32));
  return t3.outputLen = n6.outputLen, t3.blockLen = n6.blockLen, t3.create = (r5) => e4(r5), t3;
}
var xs = vs((e4) => new Es(e4));
function Os(e4, t3, n6, r5, o6, s5 = 20) {
  let i5 = e4[0], c5 = e4[1], u4 = e4[2], a4 = e4[3], l6 = t3[0], f5 = t3[1], d6 = t3[2], g6 = t3[3], y7 = t3[4], h7 = t3[5], m4 = t3[6], B4 = t3[7], b4 = o6, _7 = n6[0], I5 = n6[1], k7 = n6[2], E7 = i5, L5 = c5, j6 = u4, v8 = a4, O4 = l6, w6 = f5, R3 = d6, A7 = g6, T6 = y7, N10 = h7, S4 = m4, U3 = B4, $4 = b4, p5 = _7, C7 = I5, D5 = k7;
  for (let G3 = 0; G3 < s5; G3 += 2)
    E7 = E7 + O4 | 0, $4 = x7($4 ^ E7, 16), T6 = T6 + $4 | 0, O4 = x7(O4 ^ T6, 12), E7 = E7 + O4 | 0, $4 = x7($4 ^ E7, 8), T6 = T6 + $4 | 0, O4 = x7(O4 ^ T6, 7), L5 = L5 + w6 | 0, p5 = x7(p5 ^ L5, 16), N10 = N10 + p5 | 0, w6 = x7(w6 ^ N10, 12), L5 = L5 + w6 | 0, p5 = x7(p5 ^ L5, 8), N10 = N10 + p5 | 0, w6 = x7(w6 ^ N10, 7), j6 = j6 + R3 | 0, C7 = x7(C7 ^ j6, 16), S4 = S4 + C7 | 0, R3 = x7(R3 ^ S4, 12), j6 = j6 + R3 | 0, C7 = x7(C7 ^ j6, 8), S4 = S4 + C7 | 0, R3 = x7(R3 ^ S4, 7), v8 = v8 + A7 | 0, D5 = x7(D5 ^ v8, 16), U3 = U3 + D5 | 0, A7 = x7(A7 ^ U3, 12), v8 = v8 + A7 | 0, D5 = x7(D5 ^ v8, 8), U3 = U3 + D5 | 0, A7 = x7(A7 ^ U3, 7), E7 = E7 + w6 | 0, D5 = x7(D5 ^ E7, 16), S4 = S4 + D5 | 0, w6 = x7(w6 ^ S4, 12), E7 = E7 + w6 | 0, D5 = x7(D5 ^ E7, 8), S4 = S4 + D5 | 0, w6 = x7(w6 ^ S4, 7), L5 = L5 + R3 | 0, $4 = x7($4 ^ L5, 16), U3 = U3 + $4 | 0, R3 = x7(R3 ^ U3, 12), L5 = L5 + R3 | 0, $4 = x7($4 ^ L5, 8), U3 = U3 + $4 | 0, R3 = x7(R3 ^ U3, 7), j6 = j6 + A7 | 0, p5 = x7(p5 ^ j6, 16), T6 = T6 + p5 | 0, A7 = x7(A7 ^ T6, 12), j6 = j6 + A7 | 0, p5 = x7(p5 ^ j6, 8), T6 = T6 + p5 | 0, A7 = x7(A7 ^ T6, 7), v8 = v8 + O4 | 0, C7 = x7(C7 ^ v8, 16), N10 = N10 + C7 | 0, O4 = x7(O4 ^ N10, 12), v8 = v8 + O4 | 0, C7 = x7(C7 ^ v8, 8), N10 = N10 + C7 | 0, O4 = x7(O4 ^ N10, 7);
  let P4 = 0;
  r5[P4++] = i5 + E7 | 0, r5[P4++] = c5 + L5 | 0, r5[P4++] = u4 + j6 | 0, r5[P4++] = a4 + v8 | 0, r5[P4++] = l6 + O4 | 0, r5[P4++] = f5 + w6 | 0, r5[P4++] = d6 + R3 | 0, r5[P4++] = g6 + A7 | 0, r5[P4++] = y7 + T6 | 0, r5[P4++] = h7 + N10 | 0, r5[P4++] = m4 + S4 | 0, r5[P4++] = B4 + U3 | 0, r5[P4++] = b4 + $4 | 0, r5[P4++] = _7 + p5 | 0, r5[P4++] = I5 + C7 | 0, r5[P4++] = k7 + D5 | 0;
}
var Is = ws(Os, { counterRight: false, counterLength: 4, allowShortKeys: false });
var As = new Uint8Array(16);
var Hn2 = (e4, t3) => {
  e4.update(t3);
  const n6 = t3.length % 16;
  n6 && e4.update(As.subarray(n6));
};
var Ns = new Uint8Array(32);
function Kn2(e4, t3, n6, r5, o6) {
  const s5 = e4(t3, n6, Ns), i5 = xs.create(s5);
  o6 && Hn2(i5, o6), Hn2(i5, r5);
  const c5 = new Uint8Array(16), u4 = is(c5);
  kn2(u4, 0, BigInt(o6 ? o6.length : 0), true), kn2(u4, 8, BigInt(r5.length), true), i5.update(c5);
  const a4 = i5.digest();
  return Ee2(s5, c5), a4;
}
var Ss = (e4) => (t3, n6, r5) => ({ encrypt(s5, i5) {
  const c5 = s5.length;
  i5 = Cn2(c5 + 16, i5, false), i5.set(s5);
  const u4 = i5.subarray(0, -16);
  e4(t3, n6, u4, u4, 1);
  const a4 = Kn2(e4, t3, n6, u4, r5);
  return i5.set(a4, c5), Ee2(a4), i5;
}, decrypt(s5, i5) {
  i5 = Cn2(s5.length - 16, i5, false);
  const c5 = s5.subarray(0, -16), u4 = s5.subarray(-16), a4 = Kn2(e4, t3, n6, c5, r5);
  if (!fs(u4, a4))
    throw new Error("invalid tag");
  return i5.set(s5.subarray(0, -16)), e4(t3, n6, i5, i5, 1), Ee2(a4), i5;
} });
var Fn2 = ls({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Ss(Is));
var qn2 = class extends it2 {
  constructor(t3, n6) {
    super(), this.finished = false, this.destroyed = false, ot(t3);
    const r5 = we2(n6);
    if (this.iHash = t3.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o6 = this.blockLen, s5 = new Uint8Array(o6);
    s5.set(r5.length > o6 ? t3.create().update(r5).digest() : r5);
    for (let i5 = 0; i5 < s5.length; i5++)
      s5[i5] ^= 54;
    this.iHash.update(s5), this.oHash = t3.create();
    for (let i5 = 0; i5 < s5.length; i5++)
      s5[i5] ^= 106;
    this.oHash.update(s5), s5.fill(0);
  }
  update(t3) {
    return me2(this), this.iHash.update(t3), this;
  }
  digestInto(t3) {
    me2(this), je2(t3, this.outputLen), this.finished = true, this.iHash.digestInto(t3), this.oHash.update(t3), this.oHash.digestInto(t3), this.destroy();
  }
  digest() {
    const t3 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t3), t3;
  }
  _cloneInto(t3) {
    t3 || (t3 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n6, iHash: r5, finished: o6, destroyed: s5, blockLen: i5, outputLen: c5 } = this;
    return t3 = t3, t3.finished = o6, t3.destroyed = s5, t3.blockLen = i5, t3.outputLen = c5, t3.oHash = n6._cloneInto(t3.oHash), t3.iHash = r5._cloneInto(t3.iHash), t3;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var mt = (e4, t3, n6) => new qn2(e4, t3).update(n6).digest();
mt.create = (e4, t3) => new qn2(e4, t3);
function Us(e4, t3, n6) {
  return ot(e4), n6 === void 0 && (n6 = new Uint8Array(e4.outputLen)), mt(e4, we2(n6), we2(t3));
}
var bt2 = new Uint8Array([0]);
var Gn2 = new Uint8Array();
function _s(e4, t3, n6, r5 = 32) {
  if (ot(e4), Ne2(r5), r5 > 255 * e4.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const o6 = Math.ceil(r5 / e4.outputLen);
  n6 === void 0 && (n6 = Gn2);
  const s5 = new Uint8Array(o6 * e4.outputLen), i5 = mt.create(e4, t3), c5 = i5._cloneInto(), u4 = new Uint8Array(i5.outputLen);
  for (let a4 = 0; a4 < o6; a4++)
    bt2[0] = a4 + 1, c5.update(a4 === 0 ? Gn2 : u4).update(n6).update(bt2).digestInto(u4), s5.set(u4, e4.outputLen * a4), i5._cloneInto(c5);
  return i5.destroy(), c5.destroy(), u4.fill(0), bt2.fill(0), s5.slice(0, r5);
}
var Ts = (e4, t3, n6, r5, o6) => _s(e4, Us(e4, t3, n6), r5, o6);
function $s(e4, t3, n6, r5) {
  if (typeof e4.setBigUint64 == "function")
    return e4.setBigUint64(t3, n6, r5);
  const o6 = BigInt(32), s5 = BigInt(4294967295), i5 = Number(n6 >> o6 & s5), c5 = Number(n6 & s5), u4 = r5 ? 4 : 0, a4 = r5 ? 0 : 4;
  e4.setUint32(t3 + u4, i5, r5), e4.setUint32(t3 + a4, c5, r5);
}
function Rs(e4, t3, n6) {
  return e4 & t3 ^ ~e4 & n6;
}
function Ps(e4, t3, n6) {
  return e4 & t3 ^ e4 & n6 ^ t3 & n6;
}
var Ls = class extends it2 {
  constructor(t3, n6, r5, o6) {
    super(), this.blockLen = t3, this.outputLen = n6, this.padOffset = r5, this.isLE = o6, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t3), this.view = st(this.buffer);
  }
  update(t3) {
    me2(this);
    const { view: n6, buffer: r5, blockLen: o6 } = this;
    t3 = we2(t3);
    const s5 = t3.length;
    for (let i5 = 0; i5 < s5; ) {
      const c5 = Math.min(o6 - this.pos, s5 - i5);
      if (c5 === o6) {
        const u4 = st(t3);
        for (; o6 <= s5 - i5; i5 += o6)
          this.process(u4, i5);
        continue;
      }
      r5.set(t3.subarray(i5, i5 + c5), this.pos), this.pos += c5, i5 += c5, this.pos === o6 && (this.process(n6, 0), this.pos = 0);
    }
    return this.length += t3.length, this.roundClean(), this;
  }
  digestInto(t3) {
    me2(this), sn2(t3, this), this.finished = true;
    const { buffer: n6, view: r5, blockLen: o6, isLE: s5 } = this;
    let { pos: i5 } = this;
    n6[i5++] = 128, this.buffer.subarray(i5).fill(0), this.padOffset > o6 - i5 && (this.process(r5, 0), i5 = 0);
    for (let f5 = i5; f5 < o6; f5++)
      n6[f5] = 0;
    $s(r5, o6 - 8, BigInt(this.length * 8), s5), this.process(r5, 0);
    const c5 = st(t3), u4 = this.outputLen;
    if (u4 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const a4 = u4 / 4, l6 = this.get();
    if (a4 > l6.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f5 = 0; f5 < a4; f5++)
      c5.setUint32(4 * f5, l6[f5], s5);
  }
  digest() {
    const { buffer: t3, outputLen: n6 } = this;
    this.digestInto(t3);
    const r5 = t3.slice(0, n6);
    return this.destroy(), r5;
  }
  _cloneInto(t3) {
    t3 || (t3 = new this.constructor()), t3.set(...this.get());
    const { blockLen: n6, buffer: r5, length: o6, finished: s5, destroyed: i5, pos: c5 } = this;
    return t3.length = o6, t3.pos = c5, t3.finished = s5, t3.destroyed = i5, o6 % n6 && t3.buffer.set(r5), t3;
  }
};
var Bs = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var ie = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var ce = new Uint32Array(64);
var js = class extends Ls {
  constructor() {
    super(64, 32, 8, false), this.A = ie[0] | 0, this.B = ie[1] | 0, this.C = ie[2] | 0, this.D = ie[3] | 0, this.E = ie[4] | 0, this.F = ie[5] | 0, this.G = ie[6] | 0, this.H = ie[7] | 0;
  }
  get() {
    const { A: t3, B: n6, C: r5, D: o6, E: s5, F: i5, G: c5, H: u4 } = this;
    return [t3, n6, r5, o6, s5, i5, c5, u4];
  }
  set(t3, n6, r5, o6, s5, i5, c5, u4) {
    this.A = t3 | 0, this.B = n6 | 0, this.C = r5 | 0, this.D = o6 | 0, this.E = s5 | 0, this.F = i5 | 0, this.G = c5 | 0, this.H = u4 | 0;
  }
  process(t3, n6) {
    for (let f5 = 0; f5 < 16; f5++, n6 += 4)
      ce[f5] = t3.getUint32(n6, false);
    for (let f5 = 16; f5 < 64; f5++) {
      const d6 = ce[f5 - 15], g6 = ce[f5 - 2], y7 = J3(d6, 7) ^ J3(d6, 18) ^ d6 >>> 3, h7 = J3(g6, 17) ^ J3(g6, 19) ^ g6 >>> 10;
      ce[f5] = h7 + ce[f5 - 7] + y7 + ce[f5 - 16] | 0;
    }
    let { A: r5, B: o6, C: s5, D: i5, E: c5, F: u4, G: a4, H: l6 } = this;
    for (let f5 = 0; f5 < 64; f5++) {
      const d6 = J3(c5, 6) ^ J3(c5, 11) ^ J3(c5, 25), g6 = l6 + d6 + Rs(c5, u4, a4) + Bs[f5] + ce[f5] | 0, h7 = (J3(r5, 2) ^ J3(r5, 13) ^ J3(r5, 22)) + Ps(r5, o6, s5) | 0;
      l6 = a4, a4 = u4, u4 = c5, c5 = i5 + g6 | 0, i5 = s5, s5 = o6, o6 = r5, r5 = g6 + h7 | 0;
    }
    r5 = r5 + this.A | 0, o6 = o6 + this.B | 0, s5 = s5 + this.C | 0, i5 = i5 + this.D | 0, c5 = c5 + this.E | 0, u4 = u4 + this.F | 0, a4 = a4 + this.G | 0, l6 = l6 + this.H | 0, this.set(r5, o6, s5, i5, c5, u4, a4, l6);
  }
  roundClean() {
    ce.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var He2 = fn(() => new js());
var Wn2 = BigInt(0);
function wt2(e4) {
  return e4 instanceof Uint8Array || ArrayBuffer.isView(e4) && e4.constructor.name === "Uint8Array";
}
function zn2(e4) {
  if (!wt2(e4))
    throw new Error("Uint8Array expected");
}
var Cs = Array.from({ length: 256 }, (e4, t3) => t3.toString(16).padStart(2, "0"));
function ks(e4) {
  zn2(e4);
  let t3 = "";
  for (let n6 = 0; n6 < e4.length; n6++)
    t3 += Cs[e4[n6]];
  return t3;
}
function Ds(e4) {
  if (typeof e4 != "string")
    throw new Error("hex string expected, got " + typeof e4);
  return e4 === "" ? Wn2 : BigInt("0x" + e4);
}
var ee = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jn2(e4) {
  if (e4 >= ee._0 && e4 <= ee._9)
    return e4 - ee._0;
  if (e4 >= ee.A && e4 <= ee.F)
    return e4 - (ee.A - 10);
  if (e4 >= ee.a && e4 <= ee.f)
    return e4 - (ee.a - 10);
}
function Yn2(e4) {
  if (typeof e4 != "string")
    throw new Error("hex string expected, got " + typeof e4);
  const t3 = e4.length, n6 = t3 / 2;
  if (t3 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t3);
  const r5 = new Uint8Array(n6);
  for (let o6 = 0, s5 = 0; o6 < n6; o6++, s5 += 2) {
    const i5 = Jn2(e4.charCodeAt(s5)), c5 = Jn2(e4.charCodeAt(s5 + 1));
    if (i5 === void 0 || c5 === void 0) {
      const u4 = e4[s5] + e4[s5 + 1];
      throw new Error('hex string expected, got non-hex character "' + u4 + '" at index ' + s5);
    }
    r5[o6] = i5 * 16 + c5;
  }
  return r5;
}
function Xn2(e4) {
  return zn2(e4), Ds(ks(Uint8Array.from(e4).reverse()));
}
function Ms(e4, t3) {
  return Yn2(e4.toString(16).padStart(t3 * 2, "0"));
}
function Vs(e4, t3) {
  return Ms(e4, t3).reverse();
}
function Zn2(e4, t3, n6) {
  let r5;
  if (typeof t3 == "string")
    try {
      r5 = Yn2(t3);
    } catch (s5) {
      throw new Error(e4 + " must be hex string or Uint8Array, cause: " + s5);
    }
  else if (wt2(t3))
    r5 = Uint8Array.from(t3);
  else
    throw new Error(e4 + " must be hex string or Uint8Array");
  const o6 = r5.length;
  if (typeof n6 == "number" && o6 !== n6)
    throw new Error(e4 + " of length " + n6 + " expected, got " + o6);
  return r5;
}
var Et2 = (e4) => typeof e4 == "bigint" && Wn2 <= e4;
function Hs(e4, t3, n6) {
  return Et2(e4) && Et2(t3) && Et2(n6) && t3 <= e4 && e4 < n6;
}
function Qn2(e4, t3, n6, r5) {
  if (!Hs(t3, n6, r5))
    throw new Error("expected valid " + e4 + ": " + n6 + " <= n < " + r5 + ", got " + t3);
}
var Ks = { bigint: (e4) => typeof e4 == "bigint", function: (e4) => typeof e4 == "function", boolean: (e4) => typeof e4 == "boolean", string: (e4) => typeof e4 == "string", stringOrUint8Array: (e4) => typeof e4 == "string" || wt2(e4), isSafeInteger: (e4) => Number.isSafeInteger(e4), array: (e4) => Array.isArray(e4), field: (e4, t3) => t3.Fp.isValid(e4), hash: (e4) => typeof e4 == "function" && Number.isSafeInteger(e4.outputLen) };
function Fs(e4, t3, n6 = {}) {
  const r5 = (o6, s5, i5) => {
    const c5 = Ks[s5];
    if (typeof c5 != "function")
      throw new Error("invalid validator function");
    const u4 = e4[o6];
    if (!(i5 && u4 === void 0) && !c5(u4, e4))
      throw new Error("param " + String(o6) + " is invalid. Expected " + s5 + ", got " + u4);
  };
  for (const [o6, s5] of Object.entries(t3))
    r5(o6, s5, false);
  for (const [o6, s5] of Object.entries(n6))
    r5(o6, s5, true);
  return e4;
}
var ve2 = BigInt(0);
var Ke2 = BigInt(1);
function er2(e4, t3) {
  const n6 = e4 % t3;
  return n6 >= ve2 ? n6 : t3 + n6;
}
function qs(e4, t3, n6) {
  if (t3 < ve2)
    throw new Error("invalid exponent, negatives unsupported");
  if (n6 <= ve2)
    throw new Error("invalid modulus");
  if (n6 === Ke2)
    return ve2;
  let r5 = Ke2;
  for (; t3 > ve2; )
    t3 & Ke2 && (r5 = r5 * e4 % n6), e4 = e4 * e4 % n6, t3 >>= Ke2;
  return r5;
}
function z5(e4, t3, n6) {
  let r5 = e4;
  for (; t3-- > ve2; )
    r5 *= r5, r5 %= n6;
  return r5;
}
BigInt(0), BigInt(1), BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var xe2 = BigInt(0);
var vt2 = BigInt(1);
function Gs(e4) {
  return Fs(e4, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e4 });
}
function Ws(e4) {
  const t3 = Gs(e4), { P: n6 } = t3, r5 = (b4) => er2(b4, n6), o6 = t3.montgomeryBits, s5 = Math.ceil(o6 / 8), i5 = t3.nByteLength, c5 = t3.adjustScalarBytes || ((b4) => b4), u4 = t3.powPminus2 || ((b4) => qs(b4, n6 - BigInt(2), n6));
  function a4(b4, _7, I5) {
    const k7 = r5(b4 * (_7 - I5));
    return _7 = r5(_7 - k7), I5 = r5(I5 + k7), [_7, I5];
  }
  const l6 = (t3.a - BigInt(2)) / BigInt(4);
  function f5(b4, _7) {
    Qn2("u", b4, xe2, n6), Qn2("scalar", _7, xe2, n6);
    const I5 = _7, k7 = b4;
    let E7 = vt2, L5 = xe2, j6 = b4, v8 = vt2, O4 = xe2, w6;
    for (let A7 = BigInt(o6 - 1); A7 >= xe2; A7--) {
      const T6 = I5 >> A7 & vt2;
      O4 ^= T6, w6 = a4(O4, E7, j6), E7 = w6[0], j6 = w6[1], w6 = a4(O4, L5, v8), L5 = w6[0], v8 = w6[1], O4 = T6;
      const N10 = E7 + L5, S4 = r5(N10 * N10), U3 = E7 - L5, $4 = r5(U3 * U3), p5 = S4 - $4, C7 = j6 + v8, D5 = j6 - v8, P4 = r5(D5 * N10), G3 = r5(C7 * U3), X3 = P4 + G3, Z3 = P4 - G3;
      j6 = r5(X3 * X3), v8 = r5(k7 * r5(Z3 * Z3)), E7 = r5(S4 * $4), L5 = r5(p5 * (S4 + r5(l6 * p5)));
    }
    w6 = a4(O4, E7, j6), E7 = w6[0], j6 = w6[1], w6 = a4(O4, L5, v8), L5 = w6[0], v8 = w6[1];
    const R3 = u4(L5);
    return r5(E7 * R3);
  }
  function d6(b4) {
    return Vs(r5(b4), s5);
  }
  function g6(b4) {
    const _7 = Zn2("u coordinate", b4, s5);
    return i5 === 32 && (_7[31] &= 127), Xn2(_7);
  }
  function y7(b4) {
    const _7 = Zn2("scalar", b4), I5 = _7.length;
    if (I5 !== s5 && I5 !== i5) {
      let k7 = "" + s5 + " or " + i5;
      throw new Error("invalid scalar, expected " + k7 + " bytes, got " + I5);
    }
    return Xn2(c5(_7));
  }
  function h7(b4, _7) {
    const I5 = g6(_7), k7 = y7(b4), E7 = f5(I5, k7);
    if (E7 === xe2)
      throw new Error("invalid private or public key received");
    return d6(E7);
  }
  const m4 = d6(t3.Gu);
  function B4(b4) {
    return h7(b4, m4);
  }
  return { scalarMult: h7, scalarMultBase: B4, getSharedSecret: (b4, _7) => h7(b4, _7), getPublicKey: (b4) => B4(b4), utils: { randomPrivateKey: () => t3.randomBytes(t3.nByteLength) }, GuBytes: m4 };
}
var xt2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var zs = BigInt(1);
var tr2 = BigInt(2);
var Js = BigInt(3);
var Ys = BigInt(5);
BigInt(8);
function Xs(e4) {
  const t3 = BigInt(10), n6 = BigInt(20), r5 = BigInt(40), o6 = BigInt(80), s5 = xt2, c5 = e4 * e4 % s5 * e4 % s5, u4 = z5(c5, tr2, s5) * c5 % s5, a4 = z5(u4, zs, s5) * e4 % s5, l6 = z5(a4, Ys, s5) * a4 % s5, f5 = z5(l6, t3, s5) * l6 % s5, d6 = z5(f5, n6, s5) * f5 % s5, g6 = z5(d6, r5, s5) * d6 % s5, y7 = z5(g6, o6, s5) * g6 % s5, h7 = z5(y7, o6, s5) * g6 % s5, m4 = z5(h7, t3, s5) * l6 % s5;
  return { pow_p_5_8: z5(m4, tr2, s5) * e4 % s5, b2: c5 };
}
function Zs(e4) {
  return e4[0] &= 248, e4[31] &= 127, e4[31] |= 64, e4;
}
var Ot2 = (() => Ws({ P: xt2, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e4) => {
  const t3 = xt2, { pow_p_5_8: n6, b2: r5 } = Xs(e4);
  return er2(z5(n6, Js, t3) * r5, t3);
}, adjustScalarBytes: Zs, randomBytes: Se2 }))();
var It2 = "base10";
var V2 = "base16";
var At = "base64pad";
var Qs = "base64url";
var Oe2 = "utf8";
var Nt2 = 0;
var Ie2 = 1;
var _e2 = 2;
var ei = 0;
var nr2 = 1;
var Te2 = 12;
var St2 = 32;
function ti() {
  const e4 = Ot2.utils.randomPrivateKey(), t3 = Ot2.getPublicKey(e4);
  return { privateKey: toString2(e4, V2), publicKey: toString2(t3, V2) };
}
function ni() {
  const e4 = Se2(St2);
  return toString2(e4, V2);
}
function ri(e4, t3) {
  const n6 = Ot2.getSharedSecret(fromString2(e4, V2), fromString2(t3, V2)), r5 = Ts(He2, n6, void 0, void 0, St2);
  return toString2(r5, V2);
}
function oi(e4) {
  const t3 = He2(fromString2(e4, V2));
  return toString2(t3, V2);
}
function si(e4) {
  const t3 = He2(fromString2(e4, Oe2));
  return toString2(t3, V2);
}
function Ut2(e4) {
  return fromString2(`${e4}`, It2);
}
function fe2(e4) {
  return Number(toString2(e4, It2));
}
function ii(e4) {
  const t3 = Ut2(typeof e4.type < "u" ? e4.type : Nt2);
  if (fe2(t3) === Ie2 && typeof e4.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const n6 = typeof e4.senderPublicKey < "u" ? fromString2(e4.senderPublicKey, V2) : void 0, r5 = typeof e4.iv < "u" ? fromString2(e4.iv, V2) : Se2(Te2), o6 = fromString2(e4.symKey, V2), s5 = Fn2(o6, r5).encrypt(fromString2(e4.message, Oe2));
  return _t2({ type: t3, sealed: s5, iv: r5, senderPublicKey: n6, encoding: e4.encoding });
}
function ci(e4) {
  const t3 = fromString2(e4.symKey, V2), { sealed: n6, iv: r5 } = Fe(e4), o6 = Fn2(t3, r5).decrypt(n6);
  if (o6 === null)
    throw new Error("Failed to decrypt");
  return toString2(o6, Oe2);
}
function ai(e4, t3) {
  const n6 = Ut2(_e2), r5 = Se2(Te2), o6 = fromString2(e4, Oe2);
  return _t2({ type: n6, sealed: o6, iv: r5, encoding: t3 });
}
function ui(e4, t3) {
  const { sealed: n6 } = Fe({ encoded: e4, encoding: t3 });
  return toString2(n6, Oe2);
}
function _t2(e4) {
  const { encoding: t3 = At } = e4;
  if (fe2(e4.type) === _e2)
    return toString2(concat2([e4.type, e4.sealed]), t3);
  if (fe2(e4.type) === Ie2) {
    if (typeof e4.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat2([e4.type, e4.senderPublicKey, e4.iv, e4.sealed]), t3);
  }
  return toString2(concat2([e4.type, e4.iv, e4.sealed]), t3);
}
function Fe(e4) {
  const { encoded: t3, encoding: n6 = At } = e4, r5 = fromString2(t3, n6), o6 = r5.slice(ei, nr2), s5 = nr2;
  if (fe2(o6) === Ie2) {
    const a4 = s5 + St2, l6 = a4 + Te2, f5 = r5.slice(s5, a4), d6 = r5.slice(a4, l6), g6 = r5.slice(l6);
    return { type: o6, sealed: g6, iv: d6, senderPublicKey: f5 };
  }
  if (fe2(o6) === _e2) {
    const a4 = r5.slice(s5), l6 = Se2(Te2);
    return { type: o6, sealed: a4, iv: l6 };
  }
  const i5 = s5 + Te2, c5 = r5.slice(s5, i5), u4 = r5.slice(i5);
  return { type: o6, sealed: u4, iv: c5 };
}
function fi(e4, t3) {
  const n6 = Fe({ encoded: e4, encoding: t3?.encoding });
  return rr2({ type: fe2(n6.type), senderPublicKey: typeof n6.senderPublicKey < "u" ? toString2(n6.senderPublicKey, V2) : void 0, receiverPublicKey: t3?.receiverPublicKey });
}
function rr2(e4) {
  const t3 = e4?.type || Nt2;
  if (t3 === Ie2) {
    if (typeof e4?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e4?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: t3, senderPublicKey: e4?.senderPublicKey, receiverPublicKey: e4?.receiverPublicKey };
}
function li(e4) {
  return e4.type === Ie2 && typeof e4.senderPublicKey == "string" && typeof e4.receiverPublicKey == "string";
}
function di(e4) {
  return e4.type === _e2;
}
function or3(e4) {
  return new import_elliptic2.ec("p256").keyFromPublic({ x: Buffer.from(e4.x, "base64").toString("hex"), y: Buffer.from(e4.y, "base64").toString("hex") }, "hex");
}
function hi(e4) {
  let t3 = e4.replace(/-/g, "+").replace(/_/g, "/");
  const n6 = t3.length % 4;
  return n6 > 0 && (t3 += "=".repeat(4 - n6)), t3;
}
function pi(e4) {
  return Buffer.from(hi(e4), "base64");
}
function gi(e4, t3) {
  const [n6, r5, o6] = e4.split("."), s5 = pi(o6);
  if (s5.length !== 64)
    throw new Error("Invalid signature length");
  const i5 = s5.slice(0, 32).toString("hex"), c5 = s5.slice(32, 64).toString("hex"), u4 = `${n6}.${r5}`, a4 = He2(u4), l6 = or3(t3), f5 = toString2(a4, V2);
  if (!l6.verify(f5, { r: i5, s: c5 }))
    throw new Error("Invalid signature");
  return sn(e4).payload;
}
var sr2 = "irn";
function yi(e4) {
  return e4?.relay || { protocol: sr2 };
}
function mi(e4) {
  const t3 = C5[e4];
  if (typeof t3 > "u")
    throw new Error(`Relay Protocol not supported: ${e4}`);
  return t3;
}
function ir2(e4, t3 = "-") {
  const n6 = {}, r5 = "relay" + t3;
  return Object.keys(e4).forEach((o6) => {
    if (o6.startsWith(r5)) {
      const s5 = o6.replace(r5, ""), i5 = e4[o6];
      n6[s5] = i5;
    }
  }), n6;
}
function bi(e4) {
  if (!e4.includes("wc:")) {
    const a4 = rt2(e4);
    a4 != null && a4.includes("wc:") && (e4 = a4);
  }
  e4 = e4.includes("wc://") ? e4.replace("wc://", "") : e4, e4 = e4.includes("wc:") ? e4.replace("wc:", "") : e4;
  const t3 = e4.indexOf(":"), n6 = e4.indexOf("?") !== -1 ? e4.indexOf("?") : void 0, r5 = e4.substring(0, t3), o6 = e4.substring(t3 + 1, n6).split("@"), s5 = typeof n6 < "u" ? e4.substring(n6) : "", i5 = new URLSearchParams(s5), c5 = {};
  i5.forEach((a4, l6) => {
    c5[l6] = a4;
  });
  const u4 = typeof c5.methods == "string" ? c5.methods.split(",") : void 0;
  return { protocol: r5, topic: cr2(o6[0]), version: parseInt(o6[1], 10), symKey: c5.symKey, relay: ir2(c5), methods: u4, expiryTimestamp: c5.expiryTimestamp ? parseInt(c5.expiryTimestamp, 10) : void 0 };
}
function cr2(e4) {
  return e4.startsWith("//") ? e4.substring(2) : e4;
}
function ar2(e4, t3 = "-") {
  const n6 = "relay", r5 = {};
  return Object.keys(e4).forEach((o6) => {
    const s5 = n6 + t3 + o6;
    e4[o6] && (r5[s5] = e4[o6]);
  }), r5;
}
function wi(e4) {
  const t3 = new URLSearchParams(), n6 = ar2(e4.relay);
  Object.keys(n6).sort().forEach((o6) => {
    t3.set(o6, n6[o6]);
  }), t3.set("symKey", e4.symKey), e4.expiryTimestamp && t3.set("expiryTimestamp", e4.expiryTimestamp.toString()), e4.methods && t3.set("methods", e4.methods.join(","));
  const r5 = t3.toString();
  return `${e4.protocol}:${e4.topic}@${e4.version}?${r5}`;
}
function Ei(e4, t3, n6) {
  return `${e4}?wc_ev=${n6}&topic=${t3}`;
}
function le2(e4) {
  const t3 = [];
  return e4.forEach((n6) => {
    const [r5, o6] = n6.split(":");
    t3.push(`${r5}:${o6}`);
  }), t3;
}
function lr2(e4) {
  const t3 = [];
  return Object.values(e4).forEach((n6) => {
    t3.push(...le2(n6.accounts));
  }), t3;
}
function dr2(e4, t3) {
  const n6 = [];
  return Object.values(e4).forEach((r5) => {
    le2(r5.accounts).includes(t3) && n6.push(...r5.methods);
  }), n6;
}
function hr2(e4, t3) {
  const n6 = [];
  return Object.values(e4).forEach((r5) => {
    le2(r5.accounts).includes(t3) && n6.push(...r5.events);
  }), n6;
}
function gr2(e4) {
  const t3 = {};
  return e4?.forEach((n6) => {
    const [r5, o6] = n6.split(":");
    t3[r5] || (t3[r5] = { accounts: [], chains: [], events: [] }), t3[r5].accounts.push(n6), t3[r5].chains.push(`${r5}:${o6}`);
  }), t3;
}
function Ti(e4, t3) {
  t3 = t3.map((r5) => r5.replace("did:pkh:", ""));
  const n6 = gr2(t3);
  for (const [r5, o6] of Object.entries(n6))
    o6.methods ? o6.methods = Q3(o6.methods, e4) : o6.methods = e4, o6.events = ["chainChanged", "accountsChanged"];
  return n6;
}
var yr2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var mr2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function te2(e4, t3) {
  const { message: n6, code: r5 } = mr2[e4];
  return { message: t3 ? `${n6} ${t3}` : n6, code: r5 };
}
function de2(e4, t3) {
  const { message: n6, code: r5 } = yr2[e4];
  return { message: t3 ? `${n6} ${t3}` : n6, code: r5 };
}
function $e2(e4, t3) {
  return Array.isArray(e4) ? typeof t3 < "u" && e4.length ? e4.every(t3) : true : false;
}
function qe2(e4) {
  return Object.getPrototypeOf(e4) === Object.prototype && Object.keys(e4).length;
}
function ae(e4) {
  return typeof e4 > "u";
}
function q3(e4, t3) {
  return t3 && ae(e4) ? true : typeof e4 == "string" && !!e4.trim().length;
}
function Ge2(e4, t3) {
  return t3 && ae(e4) ? true : typeof e4 == "number" && !isNaN(e4);
}
function $i(e4, t3) {
  const { requiredNamespaces: n6 } = t3, r5 = Object.keys(e4.namespaces), o6 = Object.keys(n6);
  let s5 = true;
  return re(o6, r5) ? (r5.forEach((i5) => {
    const { accounts: c5, methods: u4, events: a4 } = e4.namespaces[i5], l6 = le2(c5), f5 = n6[i5];
    (!re(Le2(i5, f5), l6) || !re(f5.methods, u4) || !re(f5.events, a4)) && (s5 = false);
  }), s5) : false;
}
function Re2(e4) {
  return q3(e4, false) && e4.includes(":") ? e4.split(":").length === 2 : false;
}
function br2(e4) {
  if (q3(e4, false) && e4.includes(":")) {
    const t3 = e4.split(":");
    if (t3.length === 3) {
      const n6 = t3[0] + ":" + t3[1];
      return !!t3[2] && Re2(n6);
    }
  }
  return false;
}
function Ri(e4) {
  function t3(n6) {
    try {
      return typeof new URL(n6) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (q3(e4, false)) {
      if (t3(e4))
        return true;
      const n6 = rt2(e4);
      return t3(n6);
    }
  } catch {
  }
  return false;
}
function Pi(e4) {
  var t3;
  return (t3 = e4?.proposer) == null ? void 0 : t3.publicKey;
}
function Li(e4) {
  return e4?.topic;
}
function Bi(e4, t3) {
  let n6 = null;
  return q3(e4?.publicKey, false) || (n6 = te2("MISSING_OR_INVALID", `${t3} controller public key should be a string`)), n6;
}
function Rt2(e4) {
  let t3 = true;
  return $e2(e4) ? e4.length && (t3 = e4.every((n6) => q3(n6, false))) : t3 = false, t3;
}
function wr2(e4, t3, n6) {
  let r5 = null;
  return $e2(t3) && t3.length ? t3.forEach((o6) => {
    r5 || Re2(o6) || (r5 = de2("UNSUPPORTED_CHAINS", `${n6}, chain ${o6} should be a string and conform to "namespace:chainId" format`));
  }) : Re2(e4) || (r5 = de2("UNSUPPORTED_CHAINS", `${n6}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r5;
}
function Er2(e4, t3, n6) {
  let r5 = null;
  return Object.entries(e4).forEach(([o6, s5]) => {
    if (r5)
      return;
    const i5 = wr2(o6, Le2(o6, s5), `${t3} ${n6}`);
    i5 && (r5 = i5);
  }), r5;
}
function vr2(e4, t3) {
  let n6 = null;
  return $e2(e4) ? e4.forEach((r5) => {
    n6 || br2(r5) || (n6 = de2("UNSUPPORTED_ACCOUNTS", `${t3}, account ${r5} should be a string and conform to "namespace:chainId:address" format`));
  }) : n6 = de2("UNSUPPORTED_ACCOUNTS", `${t3}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n6;
}
function xr2(e4, t3) {
  let n6 = null;
  return Object.values(e4).forEach((r5) => {
    if (n6)
      return;
    const o6 = vr2(r5?.accounts, `${t3} namespace`);
    o6 && (n6 = o6);
  }), n6;
}
function Or2(e4, t3) {
  let n6 = null;
  return Rt2(e4?.methods) ? Rt2(e4?.events) || (n6 = de2("UNSUPPORTED_EVENTS", `${t3}, events should be an array of strings or empty array for no events`)) : n6 = de2("UNSUPPORTED_METHODS", `${t3}, methods should be an array of strings or empty array for no methods`), n6;
}
function Pt2(e4, t3) {
  let n6 = null;
  return Object.values(e4).forEach((r5) => {
    if (n6)
      return;
    const o6 = Or2(r5, `${t3}, namespace`);
    o6 && (n6 = o6);
  }), n6;
}
function ji(e4, t3, n6) {
  let r5 = null;
  if (e4 && qe2(e4)) {
    const o6 = Pt2(e4, t3);
    o6 && (r5 = o6);
    const s5 = Er2(e4, t3, n6);
    s5 && (r5 = s5);
  } else
    r5 = te2("MISSING_OR_INVALID", `${t3}, ${n6} should be an object with data`);
  return r5;
}
function Ir2(e4, t3) {
  let n6 = null;
  if (e4 && qe2(e4)) {
    const r5 = Pt2(e4, t3);
    r5 && (n6 = r5);
    const o6 = xr2(e4, t3);
    o6 && (n6 = o6);
  } else
    n6 = te2("MISSING_OR_INVALID", `${t3}, namespaces should be an object with data`);
  return n6;
}
function Ar2(e4) {
  return q3(e4.protocol, true);
}
function Ci(e4, t3) {
  let n6 = false;
  return t3 && !e4 ? n6 = true : e4 && $e2(e4) && e4.length && e4.forEach((r5) => {
    n6 = Ar2(r5);
  }), n6;
}
function ki(e4) {
  return typeof e4 == "number";
}
function Di(e4) {
  return typeof e4 < "u" && typeof e4 !== null;
}
function Mi(e4) {
  return !(!e4 || typeof e4 != "object" || !e4.code || !Ge2(e4.code, false) || !e4.message || !q3(e4.message, false));
}
function Vi(e4) {
  return !(ae(e4) || !q3(e4.method, false));
}
function Hi(e4) {
  return !(ae(e4) || ae(e4.result) && ae(e4.error) || !Ge2(e4.id, false) || !q3(e4.jsonrpc, false));
}
function Ki(e4) {
  return !(ae(e4) || !q3(e4.name, false));
}
function Fi(e4, t3) {
  return !(!Re2(t3) || !lr2(e4).includes(t3));
}
function qi(e4, t3, n6) {
  return q3(n6, false) ? dr2(e4, t3).includes(n6) : false;
}
function Gi(e4, t3, n6) {
  return q3(n6, false) ? hr2(e4, t3).includes(n6) : false;
}
function Nr2(e4, t3, n6) {
  let r5 = null;
  const o6 = Wi(e4), s5 = zi(t3), i5 = Object.keys(o6), c5 = Object.keys(s5), u4 = Sr2(Object.keys(e4)), a4 = Sr2(Object.keys(t3)), l6 = u4.filter((f5) => !a4.includes(f5));
  return l6.length && (r5 = te2("NON_CONFORMING_NAMESPACES", `${n6} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l6.toString()}
      Received: ${Object.keys(t3).toString()}`)), re(i5, c5) || (r5 = te2("NON_CONFORMING_NAMESPACES", `${n6} namespaces chains don't satisfy required namespaces.
      Required: ${i5.toString()}
      Approved: ${c5.toString()}`)), Object.keys(t3).forEach((f5) => {
    if (!f5.includes(":") || r5)
      return;
    const d6 = le2(t3[f5].accounts);
    d6.includes(f5) || (r5 = te2("NON_CONFORMING_NAMESPACES", `${n6} namespaces accounts don't satisfy namespace accounts for ${f5}
        Required: ${f5}
        Approved: ${d6.toString()}`));
  }), i5.forEach((f5) => {
    r5 || (re(o6[f5].methods, s5[f5].methods) ? re(o6[f5].events, s5[f5].events) || (r5 = te2("NON_CONFORMING_NAMESPACES", `${n6} namespaces events don't satisfy namespace events for ${f5}`)) : r5 = te2("NON_CONFORMING_NAMESPACES", `${n6} namespaces methods don't satisfy namespace methods for ${f5}`));
  }), r5;
}
function Wi(e4) {
  const t3 = {};
  return Object.keys(e4).forEach((n6) => {
    var r5;
    n6.includes(":") ? t3[n6] = e4[n6] : (r5 = e4[n6].chains) == null || r5.forEach((o6) => {
      t3[o6] = { methods: e4[n6].methods, events: e4[n6].events };
    });
  }), t3;
}
function Sr2(e4) {
  return [...new Set(e4.map((t3) => t3.includes(":") ? t3.split(":")[0] : t3))];
}
function zi(e4) {
  const t3 = {};
  return Object.keys(e4).forEach((n6) => {
    if (n6.includes(":"))
      t3[n6] = e4[n6];
    else {
      const r5 = le2(e4[n6].accounts);
      r5?.forEach((o6) => {
        t3[o6] = { accounts: e4[n6].accounts.filter((s5) => s5.includes(`${o6}:`)), methods: e4[n6].methods, events: e4[n6].events };
      });
    }
  }), t3;
}
function Ji(e4, t3) {
  return Ge2(e4, false) && e4 <= t3.max && e4 >= t3.min;
}
function Yi() {
  const e4 = ue();
  return new Promise((t3) => {
    switch (e4) {
      case H4.browser:
        t3(Ur2());
        break;
      case H4.reactNative:
        t3(_r2());
        break;
      case H4.node:
        t3(Tr2());
        break;
      default:
        t3(true);
    }
  });
}
function Ur2() {
  return Ae2() && navigator?.onLine;
}
async function _r2() {
  if (ne() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo) {
    const e4 = await (globalThis == null ? void 0 : globalThis.NetInfo.fetch());
    return e4?.isConnected;
  }
  return true;
}
function Tr2() {
  return true;
}
function Xi(e4) {
  switch (ue()) {
    case H4.browser:
      $r2(e4);
      break;
    case H4.reactNative:
      Rr2(e4);
      break;
    case H4.node:
      break;
  }
}
function $r2(e4) {
  !ne() && Ae2() && (window.addEventListener("online", () => e4(true)), window.addEventListener("offline", () => e4(false)));
}
function Rr2(e4) {
  ne() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo && globalThis?.NetInfo.addEventListener((t3) => e4(t3?.isConnected));
}
var Lt2 = {};
var Zi = class {
  static get(t3) {
    return Lt2[t3];
  }
  static set(t3, n6) {
    Lt2[t3] = n6;
  }
  static delete(t3) {
    delete Lt2[t3];
  }
};

// node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.14/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
init_events();

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n5,
  IEvents: () => e3,
  IJsonRpcConnection: () => o4,
  IJsonRpcProvider: () => r4,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e4) => e4.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e4, url, type) {
  return e4.message.includes("getaddrinfo ENOTFOUND") || e4.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e4;
}

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs7());
__reExport(env_exports, __toESM(require_cjs7()));
var isNodeJs = import_environment.isNode;

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports3, env_exports);

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x9) => x9.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/.pnpm/@walletconnect+jsonrpc-types@1.0.4/node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e3 = class {
};
var o4 = class extends e3 {
  constructor(c5) {
    super();
  }
};
var n5 = class extends e3 {
  constructor() {
    super();
  }
};
var r4 = class extends n5 {
  constructor(c5) {
    super();
  }
};

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/.pnpm/@walletconnect+jsonrpc-utils@1.0.8/node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/.pnpm/@walletconnect+jsonrpc-provider@1.0.14/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o5 = class extends r4 {
  constructor(t3) {
    super(t3), this.events = new EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t3), this.connection.connected && this.registerEventListeners();
  }
  async connect(t3 = this.connection) {
    await this.open(t3);
  }
  async disconnect() {
    await this.close();
  }
  on(t3, e4) {
    this.events.on(t3, e4);
  }
  once(t3, e4) {
    this.events.once(t3, e4);
  }
  off(t3, e4) {
    this.events.off(t3, e4);
  }
  removeListener(t3, e4) {
    this.events.removeListener(t3, e4);
  }
  async request(t3, e4) {
    return this.requestStrict(formatJsonRpcRequest(t3.method, t3.params || [], t3.id || getBigIntRpcId().toString()), e4);
  }
  async requestStrict(t3, e4) {
    return new Promise(async (i5, s5) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (n6) {
          s5(n6);
        }
      this.events.on(`${t3.id}`, (n6) => {
        isJsonRpcError(n6) ? s5(n6.error) : i5(n6.result);
      });
      try {
        await this.connection.send(t3, e4);
      } catch (n6) {
        s5(n6);
      }
    });
  }
  setConnection(t3 = this.connection) {
    return t3;
  }
  onPayload(t3) {
    this.events.emit("payload", t3), isJsonRpcResponse(t3) ? this.events.emit(`${t3.id}`, t3) : this.events.emit("message", { type: t3.method, data: t3.params });
  }
  onClose(t3) {
    t3 && t3.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t3.code} ${t3.reason ? `(${t3.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t3 = this.connection) {
    this.connection === t3 && this.connection.connected || (this.connection.connected && this.close(), typeof t3 == "string" && (await this.connection.open(t3), t3 = this.connection), this.connection = this.setConnection(t3), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t3) => this.onPayload(t3)), this.connection.on("close", (t3) => this.onClose(t3)), this.connection.on("error", (t3) => this.events.emit("error", t3)), this.connection.on("register_error", (t3) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/.pnpm/@walletconnect+jsonrpc-ws-connection@1.0.16_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
init_events();
var v5 = () => typeof WebSocket < "u" ? WebSocket : typeof globalThis < "u" && typeof globalThis.WebSocket < "u" ? globalThis.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
var w5 = () => typeof WebSocket < "u" || typeof globalThis < "u" && typeof globalThis.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d5 = (r5) => r5.split("?")[0];
var h6 = 10;
var b3 = v5();
var f4 = class {
  constructor(e4) {
    if (this.url = e4, this.events = new EventEmitter(), this.registering = false, !isWsUrl(e4))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e4}`);
    this.url = e4;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e4, t3) {
    this.events.on(e4, t3);
  }
  once(e4, t3) {
    this.events.once(e4, t3);
  }
  off(e4, t3) {
    this.events.off(e4, t3);
  }
  removeListener(e4, t3) {
    this.events.removeListener(e4, t3);
  }
  async open(e4 = this.url) {
    await this.register(e4);
  }
  async close() {
    return new Promise((e4, t3) => {
      if (typeof this.socket > "u") {
        t3(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n6) => {
        this.onClose(n6), e4();
      }, this.socket.close();
    });
  }
  async send(e4) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify3(e4));
    } catch (t3) {
      this.onError(e4.id, t3);
    }
  }
  register(e4 = this.url) {
    if (!isWsUrl(e4))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e4}`);
    if (this.registering) {
      const t3 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t3 || this.events.listenerCount("open") >= t3) && this.events.setMaxListeners(t3 + 1), new Promise((n6, s5) => {
        this.events.once("register_error", (o6) => {
          this.resetMaxListeners(), s5(o6);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return s5(new Error("WebSocket connection is missing or invalid"));
          n6(this.socket);
        });
      });
    }
    return this.url = e4, this.registering = true, new Promise((t3, n6) => {
      const s5 = (0, esm_exports3.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e4) }, o6 = new b3(e4, [], s5);
      w5() ? o6.onerror = (i5) => {
        const a4 = i5;
        n6(this.emitError(a4.error));
      } : o6.on("error", (i5) => {
        n6(this.emitError(i5));
      }), o6.onopen = () => {
        this.onOpen(o6), t3(o6);
      };
    });
  }
  onOpen(e4) {
    e4.onmessage = (t3) => this.onPayload(t3), e4.onclose = (t3) => this.onClose(t3), this.socket = e4, this.registering = false, this.events.emit("open");
  }
  onClose(e4) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e4);
  }
  onPayload(e4) {
    if (typeof e4.data > "u")
      return;
    const t3 = typeof e4.data == "string" ? safeJsonParse3(e4.data) : e4.data;
    this.events.emit("payload", t3);
  }
  onError(e4, t3) {
    const n6 = this.parseError(t3), s5 = n6.message || n6.toString(), o6 = formatJsonRpcError(e4, s5);
    this.events.emit("payload", o6);
  }
  parseError(e4, t3 = this.url) {
    return parseConnectionError(e4, d5(t3), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h6 && this.events.setMaxListeners(h6);
  }
  emitError(e4) {
    const t3 = this.parseError(new Error(e4?.message || `WebSocket connection failed for host: ${d5(this.url)}`));
    return this.events.emit("register_error", t3), t3;
  }
};

// node_modules/.pnpm/@walletconnect+core@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-native@0.77_rzhbh6h45w5w3zg6quyi3j7toq/node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var import_window_getters2 = __toESM(require_cjs5());
var ye2 = "wc";
var De3 = 2;
var J4 = "core";
var A5 = `${ye2}@2:${J4}:`;
var Xe3 = { name: J4, logger: "error" };
var We3 = { database: ":memory:" };
var Ze2 = "crypto";
var me3 = "client_ed25519_seed";
var Qe2 = import_time4.ONE_DAY;
var et2 = "keychain";
var tt2 = "0.3";
var it3 = "messages";
var st2 = "0.3";
var be3 = import_time4.SIX_HOURS;
var rt3 = "publisher";
var nt2 = "irn";
var ot2 = "error";
var fe3 = "wss://relay.walletconnect.org";
var at2 = "relayer";
var v6 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ct3 = "_subscription";
var C6 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ht3 = 0.1;
var re2 = "2.18.0";
var M6 = { link_mode: "link_mode", relay: "relay" };
var lt3 = "0.3";
var ut3 = "WALLETCONNECT_CLIENT_ID";
var ve3 = "WALLETCONNECT_LINK_MODE_APPS";
var T5 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var dt3 = "subscription";
var pt2 = "0.3";
var gt3 = import_time4.FIVE_SECONDS * 1e3;
var yt3 = "pairing";
var Dt2 = "0.3";
var V3 = { wc_pairingDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 } } };
var j5 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var mt2 = "history";
var bt3 = "0.3";
var ft3 = "expirer";
var x8 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var vt3 = "0.3";
var _t3 = "verify-api";
var Ss2 = "https://verify.walletconnect.com";
var Et3 = "https://verify.walletconnect.org";
var X2 = Et3;
var wt3 = `${X2}/v3`;
var It3 = [Ss2, Et3];
var Tt2 = "echo";
var Ct2 = "https://echo.walletconnect.com";
var z6 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $3 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var xs2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Os2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var As2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Ns2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Pt3 = 0.1;
var St3 = "event-client";
var Rt3 = 86400;
var xt3 = "https://pulse.walletconnect.org/batch";
function zs2(o6, e4) {
  if (o6.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t3 = new Uint8Array(256), s5 = 0; s5 < t3.length; s5++)
    t3[s5] = 255;
  for (var i5 = 0; i5 < o6.length; i5++) {
    var r5 = o6.charAt(i5), n6 = r5.charCodeAt(0);
    if (t3[n6] !== 255)
      throw new TypeError(r5 + " is ambiguous");
    t3[n6] = i5;
  }
  var a4 = o6.length, c5 = o6.charAt(0), h7 = Math.log(a4) / Math.log(256), u4 = Math.log(256) / Math.log(a4);
  function d6(l6) {
    if (l6 instanceof Uint8Array || (ArrayBuffer.isView(l6) ? l6 = new Uint8Array(l6.buffer, l6.byteOffset, l6.byteLength) : Array.isArray(l6) && (l6 = Uint8Array.from(l6))), !(l6 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l6.length === 0)
      return "";
    for (var g6 = 0, w6 = 0, b4 = 0, D5 = l6.length; b4 !== D5 && l6[b4] === 0; )
      b4++, g6++;
    for (var P4 = (D5 - b4) * u4 + 1 >>> 0, f5 = new Uint8Array(P4); b4 !== D5; ) {
      for (var N10 = l6[b4], k7 = 0, O4 = P4 - 1; (N10 !== 0 || k7 < w6) && O4 !== -1; O4--, k7++)
        N10 += 256 * f5[O4] >>> 0, f5[O4] = N10 % a4 >>> 0, N10 = N10 / a4 >>> 0;
      if (N10 !== 0)
        throw new Error("Non-zero carry");
      w6 = k7, b4++;
    }
    for (var L5 = P4 - w6; L5 !== P4 && f5[L5] === 0; )
      L5++;
    for (var ee2 = c5.repeat(g6); L5 < P4; ++L5)
      ee2 += o6.charAt(f5[L5]);
    return ee2;
  }
  function y7(l6) {
    if (typeof l6 != "string")
      throw new TypeError("Expected String");
    if (l6.length === 0)
      return new Uint8Array();
    var g6 = 0;
    if (l6[g6] !== " ") {
      for (var w6 = 0, b4 = 0; l6[g6] === c5; )
        w6++, g6++;
      for (var D5 = (l6.length - g6) * h7 + 1 >>> 0, P4 = new Uint8Array(D5); l6[g6]; ) {
        var f5 = t3[l6.charCodeAt(g6)];
        if (f5 === 255)
          return;
        for (var N10 = 0, k7 = D5 - 1; (f5 !== 0 || N10 < b4) && k7 !== -1; k7--, N10++)
          f5 += a4 * P4[k7] >>> 0, P4[k7] = f5 % 256 >>> 0, f5 = f5 / 256 >>> 0;
        if (f5 !== 0)
          throw new Error("Non-zero carry");
        b4 = N10, g6++;
      }
      if (l6[g6] !== " ") {
        for (var O4 = D5 - b4; O4 !== D5 && P4[O4] === 0; )
          O4++;
        for (var L5 = new Uint8Array(w6 + (D5 - O4)), ee2 = w6; O4 !== D5; )
          L5[ee2++] = P4[O4++];
        return L5;
      }
    }
  }
  function m4(l6) {
    var g6 = y7(l6);
    if (g6)
      return g6;
    throw new Error(`Non-${e4} character`);
  }
  return { encode: d6, decodeUnsafe: y7, decode: m4 };
}
var Ls2 = zs2;
var $s2 = Ls2;
var Ot3 = (o6) => {
  if (o6 instanceof Uint8Array && o6.constructor.name === "Uint8Array")
    return o6;
  if (o6 instanceof ArrayBuffer)
    return new Uint8Array(o6);
  if (ArrayBuffer.isView(o6))
    return new Uint8Array(o6.buffer, o6.byteOffset, o6.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ks2 = (o6) => new TextEncoder().encode(o6);
var Us2 = (o6) => new TextDecoder().decode(o6);
var Fs2 = class {
  constructor(e4, t3, s5) {
    this.name = e4, this.prefix = t3, this.baseEncode = s5;
  }
  encode(e4) {
    if (e4 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e4)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Ms2 = class {
  constructor(e4, t3, s5) {
    if (this.name = e4, this.prefix = t3, t3.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t3.codePointAt(0), this.baseDecode = s5;
  }
  decode(e4) {
    if (typeof e4 == "string") {
      if (e4.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e4)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e4.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e4) {
    return At2(this, e4);
  }
};
var Ks2 = class {
  constructor(e4) {
    this.decoders = e4;
  }
  or(e4) {
    return At2(this, e4);
  }
  decode(e4) {
    const t3 = e4[0], s5 = this.decoders[t3];
    if (s5)
      return s5.decode(e4);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e4)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var At2 = (o6, e4) => new Ks2({ ...o6.decoders || { [o6.prefix]: o6 }, ...e4.decoders || { [e4.prefix]: e4 } });
var Bs2 = class {
  constructor(e4, t3, s5, i5) {
    this.name = e4, this.prefix = t3, this.baseEncode = s5, this.baseDecode = i5, this.encoder = new Fs2(e4, t3, s5), this.decoder = new Ms2(e4, t3, i5);
  }
  encode(e4) {
    return this.encoder.encode(e4);
  }
  decode(e4) {
    return this.decoder.decode(e4);
  }
};
var ne2 = ({ name: o6, prefix: e4, encode: t3, decode: s5 }) => new Bs2(o6, e4, t3, s5);
var W3 = ({ prefix: o6, name: e4, alphabet: t3 }) => {
  const { encode: s5, decode: i5 } = $s2(t3, e4);
  return ne2({ prefix: o6, name: e4, encode: s5, decode: (r5) => Ot3(i5(r5)) });
};
var Vs2 = (o6, e4, t3, s5) => {
  const i5 = {};
  for (let u4 = 0; u4 < e4.length; ++u4)
    i5[e4[u4]] = u4;
  let r5 = o6.length;
  for (; o6[r5 - 1] === "="; )
    --r5;
  const n6 = new Uint8Array(r5 * t3 / 8 | 0);
  let a4 = 0, c5 = 0, h7 = 0;
  for (let u4 = 0; u4 < r5; ++u4) {
    const d6 = i5[o6[u4]];
    if (d6 === void 0)
      throw new SyntaxError(`Non-${s5} character`);
    c5 = c5 << t3 | d6, a4 += t3, a4 >= 8 && (a4 -= 8, n6[h7++] = 255 & c5 >> a4);
  }
  if (a4 >= t3 || 255 & c5 << 8 - a4)
    throw new SyntaxError("Unexpected end of data");
  return n6;
};
var js2 = (o6, e4, t3) => {
  const s5 = e4[e4.length - 1] === "=", i5 = (1 << t3) - 1;
  let r5 = "", n6 = 0, a4 = 0;
  for (let c5 = 0; c5 < o6.length; ++c5)
    for (a4 = a4 << 8 | o6[c5], n6 += 8; n6 > t3; )
      n6 -= t3, r5 += e4[i5 & a4 >> n6];
  if (n6 && (r5 += e4[i5 & a4 << t3 - n6]), s5)
    for (; r5.length * t3 & 7; )
      r5 += "=";
  return r5;
};
var _6 = ({ name: o6, prefix: e4, bitsPerChar: t3, alphabet: s5 }) => ne2({ prefix: e4, name: o6, encode(i5) {
  return js2(i5, s5, t3);
}, decode(i5) {
  return Vs2(i5, s5, t3, o6);
} });
var qs2 = ne2({ prefix: "\0", name: "identity", encode: (o6) => Us2(o6), decode: (o6) => ks2(o6) });
var Gs2 = Object.freeze({ __proto__: null, identity: qs2 });
var Hs2 = _6({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ys2 = Object.freeze({ __proto__: null, base2: Hs2 });
var Js2 = _6({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Xs2 = Object.freeze({ __proto__: null, base8: Js2 });
var Ws2 = W3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Zs2 = Object.freeze({ __proto__: null, base10: Ws2 });
var Qs2 = _6({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var er3 = _6({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var tr3 = Object.freeze({ __proto__: null, base16: Qs2, base16upper: er3 });
var ir3 = _6({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var sr3 = _6({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var rr3 = _6({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var nr3 = _6({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var or4 = _6({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ar3 = _6({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var cr3 = _6({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var hr3 = _6({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var lr3 = _6({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ur2 = Object.freeze({ __proto__: null, base32: ir3, base32upper: sr3, base32pad: rr3, base32padupper: nr3, base32hex: or4, base32hexupper: ar3, base32hexpad: cr3, base32hexpadupper: hr3, base32z: lr3 });
var dr3 = W3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var pr2 = W3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var gr3 = Object.freeze({ __proto__: null, base36: dr3, base36upper: pr2 });
var yr3 = W3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Dr2 = W3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var mr3 = Object.freeze({ __proto__: null, base58btc: yr3, base58flickr: Dr2 });
var br3 = _6({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var fr2 = _6({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var vr3 = _6({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var _r3 = _6({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Er3 = Object.freeze({ __proto__: null, base64: br3, base64pad: fr2, base64url: vr3, base64urlpad: _r3 });
var Nt3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var wr3 = Nt3.reduce((o6, e4, t3) => (o6[t3] = e4, o6), []);
var Ir3 = Nt3.reduce((o6, e4, t3) => (o6[e4.codePointAt(0)] = t3, o6), []);
function Tr3(o6) {
  return o6.reduce((e4, t3) => (e4 += wr3[t3], e4), "");
}
function Cr2(o6) {
  const e4 = [];
  for (const t3 of o6) {
    const s5 = Ir3[t3.codePointAt(0)];
    if (s5 === void 0)
      throw new Error(`Non-base256emoji character: ${t3}`);
    e4.push(s5);
  }
  return new Uint8Array(e4);
}
var Pr2 = ne2({ prefix: "\u{1F680}", name: "base256emoji", encode: Tr3, decode: Cr2 });
var Sr3 = Object.freeze({ __proto__: null, base256emoji: Pr2 });
var Rr3 = Lt3;
var zt3 = 128;
var xr3 = 127;
var Or3 = ~xr3;
var Ar3 = Math.pow(2, 31);
function Lt3(o6, e4, t3) {
  e4 = e4 || [], t3 = t3 || 0;
  for (var s5 = t3; o6 >= Ar3; )
    e4[t3++] = o6 & 255 | zt3, o6 /= 128;
  for (; o6 & Or3; )
    e4[t3++] = o6 & 255 | zt3, o6 >>>= 7;
  return e4[t3] = o6 | 0, Lt3.bytes = t3 - s5 + 1, e4;
}
var Nr3 = _e3;
var zr3 = 128;
var $t2 = 127;
function _e3(o6, s5) {
  var t3 = 0, s5 = s5 || 0, i5 = 0, r5 = s5, n6, a4 = o6.length;
  do {
    if (r5 >= a4)
      throw _e3.bytes = 0, new RangeError("Could not decode varint");
    n6 = o6[r5++], t3 += i5 < 28 ? (n6 & $t2) << i5 : (n6 & $t2) * Math.pow(2, i5), i5 += 7;
  } while (n6 >= zr3);
  return _e3.bytes = r5 - s5, t3;
}
var Lr3 = Math.pow(2, 7);
var $r3 = Math.pow(2, 14);
var kr3 = Math.pow(2, 21);
var Ur3 = Math.pow(2, 28);
var Fr2 = Math.pow(2, 35);
var Mr2 = Math.pow(2, 42);
var Kr2 = Math.pow(2, 49);
var Br3 = Math.pow(2, 56);
var Vr2 = Math.pow(2, 63);
var jr2 = function(o6) {
  return o6 < Lr3 ? 1 : o6 < $r3 ? 2 : o6 < kr3 ? 3 : o6 < Ur3 ? 4 : o6 < Fr2 ? 5 : o6 < Mr2 ? 6 : o6 < Kr2 ? 7 : o6 < Br3 ? 8 : o6 < Vr2 ? 9 : 10;
};
var qr2 = { encode: Rr3, decode: Nr3, encodingLength: jr2 };
var kt3 = qr2;
var Ut3 = (o6, e4, t3 = 0) => (kt3.encode(o6, e4, t3), e4);
var Ft3 = (o6) => kt3.encodingLength(o6);
var Ee3 = (o6, e4) => {
  const t3 = e4.byteLength, s5 = Ft3(o6), i5 = s5 + Ft3(t3), r5 = new Uint8Array(i5 + t3);
  return Ut3(o6, r5, 0), Ut3(t3, r5, s5), r5.set(e4, i5), new Gr2(o6, t3, e4, r5);
};
var Gr2 = class {
  constructor(e4, t3, s5, i5) {
    this.code = e4, this.size = t3, this.digest = s5, this.bytes = i5;
  }
};
var Mt2 = ({ name: o6, code: e4, encode: t3 }) => new Hr2(o6, e4, t3);
var Hr2 = class {
  constructor(e4, t3, s5) {
    this.name = e4, this.code = t3, this.encode = s5;
  }
  digest(e4) {
    if (e4 instanceof Uint8Array) {
      const t3 = this.encode(e4);
      return t3 instanceof Uint8Array ? Ee3(this.code, t3) : t3.then((s5) => Ee3(this.code, s5));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Kt2 = (o6) => async (e4) => new Uint8Array(await crypto.subtle.digest(o6, e4));
var Yr3 = Mt2({ name: "sha2-256", code: 18, encode: Kt2("SHA-256") });
var Jr3 = Mt2({ name: "sha2-512", code: 19, encode: Kt2("SHA-512") });
var Xr2 = Object.freeze({ __proto__: null, sha256: Yr3, sha512: Jr3 });
var Bt3 = 0;
var Wr3 = "identity";
var Vt2 = Ot3;
var Zr3 = (o6) => Ee3(Bt3, Vt2(o6));
var Qr2 = { code: Bt3, name: Wr3, encode: Vt2, digest: Zr3 };
var en3 = Object.freeze({ __proto__: null, identity: Qr2 });
new TextEncoder(), new TextDecoder();
var jt3 = { ...Gs2, ...Ys2, ...Xs2, ...Zs2, ...tr3, ...ur2, ...gr3, ...mr3, ...Er3, ...Sr3 };
({ ...Xr2, ...en3 });
function tn2(o6 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o6) : new Uint8Array(o6);
}
function qt2(o6, e4, t3, s5) {
  return { name: o6, prefix: e4, encoder: { name: o6, prefix: e4, encode: t3 }, decoder: { decode: s5 } };
}
var Gt3 = qt2("utf8", "u", (o6) => "u" + new TextDecoder("utf8").decode(o6), (o6) => new TextEncoder().encode(o6.substring(1)));
var we3 = qt2("ascii", "a", (o6) => {
  let e4 = "a";
  for (let t3 = 0; t3 < o6.length; t3++)
    e4 += String.fromCharCode(o6[t3]);
  return e4;
}, (o6) => {
  o6 = o6.substring(1);
  const e4 = tn2(o6.length);
  for (let t3 = 0; t3 < o6.length; t3++)
    e4[t3] = o6.charCodeAt(t3);
  return e4;
});
var sn3 = { utf8: Gt3, "utf-8": Gt3, hex: jt3.base16, latin1: we3, ascii: we3, binary: we3, ...jt3 };
function rn3(o6, e4 = "utf8") {
  const t3 = sn3[e4];
  if (!t3)
    throw new Error(`Unsupported encoding "${e4}"`);
  return (e4 === "utf8" || e4 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o6, "utf8") : t3.decoder.decode(`${t3.prefix}${o6}`);
}
var Ht2 = class {
  constructor(e4, t3) {
    this.core = e4, this.logger = t3, this.keychain = /* @__PURE__ */ new Map(), this.name = et2, this.version = tt2, this.initialized = false, this.storagePrefix = A5, this.init = async () => {
      if (!this.initialized) {
        const s5 = await this.getKeyChain();
        typeof s5 < "u" && (this.keychain = s5), this.initialized = true;
      }
    }, this.has = (s5) => (this.isInitialized(), this.keychain.has(s5)), this.set = async (s5, i5) => {
      this.isInitialized(), this.keychain.set(s5, i5), await this.persist();
    }, this.get = (s5) => {
      this.isInitialized();
      const i5 = this.keychain.get(s5);
      if (typeof i5 > "u") {
        const { message: r5 } = te2("NO_MATCHING_KEY", `${this.name}: ${s5}`);
        throw new Error(r5);
      }
      return i5;
    }, this.del = async (s5) => {
      this.isInitialized(), this.keychain.delete(s5), await this.persist();
    }, this.core = e4, this.logger = E5(t3, this.name);
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e4) {
    await this.core.storage.setItem(this.storageKey, no2(e4));
  }
  async getKeyChain() {
    const e4 = await this.core.storage.getItem(this.storageKey);
    return typeof e4 < "u" ? ro2(e4) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var Yt3 = class {
  constructor(e4, t3, s5) {
    this.core = e4, this.logger = t3, this.name = Ze2, this.randomSessionIdentifier = ni(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i5) => (this.isInitialized(), this.keychain.has(i5)), this.getClientId = async () => {
      this.isInitialized();
      const i5 = await this.getClientSeed(), r5 = Po(i5);
      return Qe(r5.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i5 = ti();
      return this.setPrivateKey(i5.publicKey, i5.privateKey);
    }, this.signJWT = async (i5) => {
      this.isInitialized();
      const r5 = await this.getClientSeed(), n6 = Po(r5), a4 = this.randomSessionIdentifier, c5 = Qe2;
      return await Qo(a4, i5, c5, n6);
    }, this.generateSharedKey = (i5, r5, n6) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(i5), c5 = ri(a4, r5);
      return this.setSymKey(c5, n6);
    }, this.setSymKey = async (i5, r5) => {
      this.isInitialized();
      const n6 = r5 || oi(i5);
      return await this.keychain.set(n6, i5), n6;
    }, this.deleteKeyPair = async (i5) => {
      this.isInitialized(), await this.keychain.del(i5);
    }, this.deleteSymKey = async (i5) => {
      this.isInitialized(), await this.keychain.del(i5);
    }, this.encode = async (i5, r5, n6) => {
      this.isInitialized();
      const a4 = rr2(n6), c5 = safeJsonStringify3(r5);
      if (di(a4))
        return ai(c5, n6?.encoding);
      if (li(a4)) {
        const y7 = a4.senderPublicKey, m4 = a4.receiverPublicKey;
        i5 = await this.generateSharedKey(y7, m4);
      }
      const h7 = this.getSymKey(i5), { type: u4, senderPublicKey: d6 } = a4;
      return ii({ type: u4, symKey: h7, message: c5, senderPublicKey: d6, encoding: n6?.encoding });
    }, this.decode = async (i5, r5, n6) => {
      this.isInitialized();
      const a4 = fi(r5, n6);
      if (di(a4)) {
        const c5 = ui(r5, n6?.encoding);
        return safeJsonParse3(c5);
      }
      if (li(a4)) {
        const c5 = a4.receiverPublicKey, h7 = a4.senderPublicKey;
        i5 = await this.generateSharedKey(c5, h7);
      }
      try {
        const c5 = this.getSymKey(i5), h7 = ci({ symKey: c5, encoded: r5, encoding: n6?.encoding });
        return safeJsonParse3(h7);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${i5}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }, this.getPayloadType = (i5, r5 = At) => {
      const n6 = Fe({ encoded: i5, encoding: r5 });
      return fe2(n6.type);
    }, this.getPayloadSenderPublicKey = (i5, r5 = At) => {
      const n6 = Fe({ encoded: i5, encoding: r5 });
      return n6.senderPublicKey ? toString2(n6.senderPublicKey, V2) : void 0;
    }, this.core = e4, this.logger = E5(t3, this.name), this.keychain = s5 || new Ht2(this.core, this.logger);
  }
  get context() {
    return y5(this.logger);
  }
  async setPrivateKey(e4, t3) {
    return await this.keychain.set(e4, t3), e4;
  }
  getPrivateKey(e4) {
    return this.keychain.get(e4);
  }
  async getClientSeed() {
    let e4 = "";
    try {
      e4 = this.keychain.get(me3);
    } catch {
      e4 = ni(), await this.keychain.set(me3, e4);
    }
    return rn3(e4, "base16");
  }
  getSymKey(e4) {
    return this.keychain.get(e4);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var Jt3 = class extends a3 {
  constructor(e4, t3) {
    super(e4, t3), this.logger = e4, this.core = t3, this.messages = /* @__PURE__ */ new Map(), this.name = it3, this.version = st2, this.initialized = false, this.storagePrefix = A5, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s5 = await this.getRelayerMessages();
          typeof s5 < "u" && (this.messages = s5), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s5) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s5);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s5, i5) => {
      this.isInitialized();
      const r5 = si(i5);
      let n6 = this.messages.get(s5);
      return typeof n6 > "u" && (n6 = {}), typeof n6[r5] < "u" || (n6[r5] = i5, this.messages.set(s5, n6), await this.persist()), r5;
    }, this.get = (s5) => {
      this.isInitialized();
      let i5 = this.messages.get(s5);
      return typeof i5 > "u" && (i5 = {}), i5;
    }, this.has = (s5, i5) => {
      this.isInitialized();
      const r5 = this.get(s5), n6 = si(i5);
      return typeof r5[n6] < "u";
    }, this.del = async (s5) => {
      this.isInitialized(), this.messages.delete(s5), await this.persist();
    }, this.logger = E5(e4, this.name), this.core = t3;
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e4) {
    await this.core.storage.setItem(this.storageKey, no2(e4));
  }
  async getRelayerMessages() {
    const e4 = await this.core.storage.getItem(this.storageKey);
    return typeof e4 < "u" ? ro2(e4) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var nn3 = Object.defineProperty;
var on3 = Object.defineProperties;
var an2 = Object.getOwnPropertyDescriptors;
var Xt2 = Object.getOwnPropertySymbols;
var cn2 = Object.prototype.hasOwnProperty;
var hn2 = Object.prototype.propertyIsEnumerable;
var Wt3 = (o6, e4, t3) => e4 in o6 ? nn3(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var Zt2 = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    cn2.call(e4, t3) && Wt3(o6, t3, e4[t3]);
  if (Xt2)
    for (var t3 of Xt2(e4))
      hn2.call(e4, t3) && Wt3(o6, t3, e4[t3]);
  return o6;
};
var Qt2 = (o6, e4) => on3(o6, an2(e4));
var ln2 = class extends g4 {
  constructor(e4, t3) {
    super(e4, t3), this.relayer = e4, this.logger = t3, this.events = new EventEmitter(), this.name = rt3, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time4.toMiliseconds)(import_time4.ONE_MINUTE), this.initialPublishTimeout = (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15), this.needsTransportRestart = false, this.publish = async (s5, i5, r5) => {
      var n6;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s5, message: i5, opts: r5 } });
      const a4 = r5?.ttl || be3, c5 = yi(r5), h7 = r5?.prompt || false, u4 = r5?.tag || 0, d6 = r5?.id || getBigIntRpcId().toString(), y7 = { topic: s5, message: i5, opts: { ttl: a4, relay: c5, prompt: h7, tag: u4, id: d6, attestation: r5?.attestation } }, m4 = `Failed to publish payload, please try again. id:${d6} tag:${u4}`;
      try {
        const l6 = new Promise(async (g6) => {
          const w6 = ({ id: D5 }) => {
            y7.opts.id === D5 && (this.removeRequestFromQueue(D5), this.relayer.events.removeListener(v6.publish, w6), g6(y7));
          };
          this.relayer.events.on(v6.publish, w6);
          const b4 = ao2(new Promise((D5, P4) => {
            this.rpcPublish({ topic: s5, message: i5, ttl: a4, prompt: h7, tag: u4, id: d6, attestation: r5?.attestation }).then(D5).catch((f5) => {
              this.logger.warn(f5, f5?.message), P4(f5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d6} tag:${u4}`);
          try {
            await b4, this.events.removeListener(v6.publish, w6);
          } catch (D5) {
            this.queue.set(d6, Qt2(Zt2({}, y7), { attempt: 1 })), this.logger.warn(D5, D5?.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d6, topic: s5, message: i5, opts: r5 } }), await ao2(l6, this.publishTimeout, m4);
      } catch (l6) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l6), (n6 = r5?.internal) != null && n6.throwOnFailedPublish)
          throw l6;
      } finally {
        this.queue.delete(d6);
      }
    }, this.on = (s5, i5) => {
      this.events.on(s5, i5);
    }, this.once = (s5, i5) => {
      this.events.once(s5, i5);
    }, this.off = (s5, i5) => {
      this.events.off(s5, i5);
    }, this.removeListener = (s5, i5) => {
      this.events.removeListener(s5, i5);
    }, this.relayer = e4, this.logger = E5(t3, this.name), this.registerEventListeners();
  }
  get context() {
    return y5(this.logger);
  }
  async rpcPublish(e4) {
    var t3, s5, i5, r5;
    const { topic: n6, message: a4, ttl: c5 = be3, prompt: h7, tag: u4, id: d6, attestation: y7 } = e4, m4 = { method: mi(yi().protocol).publish, params: { topic: n6, message: a4, ttl: c5, prompt: h7, tag: u4, attestation: y7 }, id: d6 };
    ae((t3 = m4.params) == null ? void 0 : t3.prompt) && ((s5 = m4.params) == null || delete s5.prompt), ae((i5 = m4.params) == null ? void 0 : i5.tag) && ((r5 = m4.params) == null || delete r5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: m4 });
    const l6 = await this.relayer.request(m4);
    return this.relayer.events.emit(v6.publish, e4), this.logger.debug("Successfully Published Payload"), l6;
  }
  removeRequestFromQueue(e4) {
    this.queue.delete(e4);
  }
  checkQueue() {
    this.queue.forEach(async (e4, t3) => {
      const s5 = e4.attempt + 1;
      this.queue.set(t3, Qt2(Zt2({}, e4), { attempt: s5 }));
      const { topic: i5, message: r5, opts: n6, attestation: a4 } = e4;
      this.logger.warn({}, `Publisher: queue->publishing: ${e4.opts.id}, tag: ${e4.opts.tag}, attempt: ${s5}`), await this.rpcPublish({ topic: i5, message: r5, ttl: n6.ttl, prompt: n6.prompt, tag: n6.tag, id: n6.id, attestation: a4 }), this.logger.warn({}, `Publisher: queue->published: ${e4.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r3.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(v6.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(v6.message_ack, (e4) => {
      this.removeRequestFromQueue(e4.id.toString());
    });
  }
};
var un2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e4, t3) => {
      const s5 = this.get(e4);
      this.exists(e4, t3) || this.map.set(e4, [...s5, t3]);
    }, this.get = (e4) => this.map.get(e4) || [], this.exists = (e4, t3) => this.get(e4).includes(t3), this.delete = (e4, t3) => {
      if (typeof t3 > "u") {
        this.map.delete(e4);
        return;
      }
      if (!this.map.has(e4))
        return;
      const s5 = this.get(e4);
      if (!this.exists(e4, t3))
        return;
      const i5 = s5.filter((r5) => r5 !== t3);
      if (!i5.length) {
        this.map.delete(e4);
        return;
      }
      this.map.set(e4, i5);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var dn2 = Object.defineProperty;
var pn2 = Object.defineProperties;
var gn3 = Object.getOwnPropertyDescriptors;
var ei2 = Object.getOwnPropertySymbols;
var yn3 = Object.prototype.hasOwnProperty;
var Dn2 = Object.prototype.propertyIsEnumerable;
var ti2 = (o6, e4, t3) => e4 in o6 ? dn2(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var Z2 = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    yn3.call(e4, t3) && ti2(o6, t3, e4[t3]);
  if (ei2)
    for (var t3 of ei2(e4))
      Dn2.call(e4, t3) && ti2(o6, t3, e4[t3]);
  return o6;
};
var Ie3 = (o6, e4) => pn2(o6, gn3(e4));
var ii2 = class extends d4 {
  constructor(e4, t3) {
    super(e4, t3), this.relayer = e4, this.logger = t3, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new un2(), this.events = new EventEmitter(), this.name = dt3, this.version = pt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = A5, this.subscribeTimeout = (0, import_time4.toMiliseconds)(import_time4.ONE_MINUTE), this.initialSubscribeTimeout = (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15), this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s5, i5) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s5, opts: i5 } });
      try {
        const r5 = yi(i5), n6 = { topic: s5, relay: r5, transportType: i5?.transportType };
        this.pending.set(s5, n6);
        const a4 = await this.rpcSubscribe(s5, r5, i5);
        return typeof a4 == "string" && (this.onSubscribe(a4, n6), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s5, opts: i5 } })), a4;
      } catch (r5) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r5), r5;
      }
    }, this.unsubscribe = async (s5, i5) => {
      await this.restartToComplete(), this.isInitialized(), typeof i5?.id < "u" ? await this.unsubscribeById(s5, i5.id, i5) : await this.unsubscribeByTopic(s5, i5);
    }, this.isSubscribed = async (s5) => {
      if (this.topics.includes(s5))
        return true;
      const i5 = `${this.pendingSubscriptionWatchLabel}_${s5}`;
      return await new Promise((r5, n6) => {
        const a4 = new import_time4.Watch();
        a4.start(i5);
        const c5 = setInterval(() => {
          (!this.pending.has(s5) && this.topics.includes(s5) || this.cached.some((h7) => h7.topic === s5)) && (clearInterval(c5), a4.stop(i5), r5(true)), a4.elapsed(i5) >= gt3 && (clearInterval(c5), a4.stop(i5), n6(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s5, i5) => {
      this.events.on(s5, i5);
    }, this.once = (s5, i5) => {
      this.events.once(s5, i5);
    }, this.off = (s5, i5) => {
      this.events.off(s5, i5);
    }, this.removeListener = (s5, i5) => {
      this.events.removeListener(s5, i5);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      await this.restore(), await this.onRestart();
    }, this.checkPending = async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
        return;
      const s5 = [];
      this.pending.forEach((i5) => {
        s5.push(i5);
      }), await this.batchSubscribe(s5);
    }, this.registerEventListeners = () => {
      this.relayer.core.heartbeat.on(r3.pulse, async () => {
        await this.checkPending();
      }), this.events.on(T5.created, async (s5) => {
        const i5 = T5.created;
        this.logger.info(`Emitting ${i5}`), this.logger.debug({ type: "event", event: i5, data: s5 }), await this.persist();
      }), this.events.on(T5.deleted, async (s5) => {
        const i5 = T5.deleted;
        this.logger.info(`Emitting ${i5}`), this.logger.debug({ type: "event", event: i5, data: s5 }), await this.persist();
      });
    }, this.relayer = e4, this.logger = E5(t3, this.name), this.clientId = "";
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e4, t3) {
    let s5 = false;
    try {
      s5 = this.getSubscription(e4).topic === t3;
    } catch {
    }
    return s5;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e4, t3) {
    const s5 = this.topicMap.get(e4);
    await Promise.all(s5.map(async (i5) => await this.unsubscribeById(e4, i5, t3)));
  }
  async unsubscribeById(e4, t3, s5) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e4, id: t3, opts: s5 } });
    try {
      const i5 = yi(s5);
      await this.rpcUnsubscribe(e4, t3, i5);
      const r5 = de2("USER_DISCONNECTED", `${this.name}, ${e4}`);
      await this.onUnsubscribe(e4, t3, r5), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e4, id: t3, opts: s5 } });
    } catch (i5) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i5), i5;
    }
  }
  async rpcSubscribe(e4, t3, s5) {
    var i5;
    s5?.transportType === M6.relay && await this.restartToComplete();
    const r5 = { method: mi(t3.protocol).subscribe, params: { topic: e4 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r5 });
    const n6 = (i5 = s5?.internal) == null ? void 0 : i5.throwOnFailedPublish;
    try {
      const a4 = this.getSubscriptionId(e4);
      if (s5?.transportType === M6.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(r5).catch((u4) => this.logger.warn(u4));
        }, (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND)), a4;
      const c5 = new Promise(async (u4) => {
        const d6 = (y7) => {
          y7.topic === e4 && (this.events.removeListener(T5.created, d6), u4(y7.id));
        };
        this.events.on(T5.created, d6);
        try {
          const y7 = await ao2(new Promise((m4, l6) => {
            this.relayer.request(r5).catch((g6) => {
              this.logger.warn(g6, g6?.message), l6(g6);
            }).then(m4);
          }), this.initialSubscribeTimeout, `Subscribing to ${e4} failed, please try again`);
          this.events.removeListener(T5.created, d6), u4(y7);
        } catch {
        }
      }), h7 = await ao2(c5, this.subscribeTimeout, `Subscribing to ${e4} failed, please try again`);
      if (!h7 && n6)
        throw new Error(`Subscribing to ${e4} failed, please try again`);
      return h7 ? a4 : null;
    } catch (a4) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(v6.connection_stalled), n6)
        throw a4;
    }
    return null;
  }
  async rpcBatchSubscribe(e4) {
    if (!e4.length)
      return;
    const t3 = e4[0].relay, s5 = { method: mi(t3.protocol).batchSubscribe, params: { topics: e4.map((i5) => i5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s5 });
    try {
      await await ao2(new Promise((i5) => {
        this.relayer.request(s5).catch((r5) => this.logger.warn(r5)).then(i5);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(v6.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e4) {
    if (!e4.length)
      return;
    const t3 = e4[0].relay, s5 = { method: mi(t3.protocol).batchFetchMessages, params: { topics: e4.map((r5) => r5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s5 });
    let i5;
    try {
      i5 = await await ao2(new Promise((r5, n6) => {
        this.relayer.request(s5).catch((a4) => {
          this.logger.warn(a4), n6(a4);
        }).then(r5);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(v6.connection_stalled);
    }
    return i5;
  }
  rpcUnsubscribe(e4, t3, s5) {
    const i5 = { method: mi(s5.protocol).unsubscribe, params: { topic: e4, id: t3 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i5 }), this.relayer.request(i5);
  }
  onSubscribe(e4, t3) {
    this.setSubscription(e4, Ie3(Z2({}, t3), { id: e4 })), this.pending.delete(t3.topic);
  }
  onBatchSubscribe(e4) {
    e4.length && e4.forEach((t3) => {
      this.setSubscription(t3.id, Z2({}, t3)), this.pending.delete(t3.topic);
    });
  }
  async onUnsubscribe(e4, t3, s5) {
    this.events.removeAllListeners(t3), this.hasSubscription(t3, e4) && this.deleteSubscription(t3, s5), await this.relayer.messages.del(e4);
  }
  async setRelayerSubscriptions(e4) {
    await this.relayer.core.storage.setItem(this.storageKey, e4);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e4, t3) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e4, subscription: t3 }), this.addSubscription(e4, t3);
  }
  addSubscription(e4, t3) {
    this.subscriptions.set(e4, Z2({}, t3)), this.topicMap.set(t3.topic, e4), this.events.emit(T5.created, t3);
  }
  getSubscription(e4) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e4 });
    const t3 = this.subscriptions.get(e4);
    if (!t3) {
      const { message: s5 } = te2("NO_MATCHING_KEY", `${this.name}: ${e4}`);
      throw new Error(s5);
    }
    return t3;
  }
  deleteSubscription(e4, t3) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e4, reason: t3 });
    const s5 = this.getSubscription(e4);
    this.subscriptions.delete(e4), this.topicMap.delete(s5.topic, e4), this.events.emit(T5.deleted, Ie3(Z2({}, s5), { reason: t3 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(T5.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e4 = [...this.cached], t3 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let s5 = 0; s5 < t3; s5++) {
        const i5 = e4.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i5);
      }
    }
    this.events.emit(T5.resubscribed);
  }
  async restore() {
    try {
      const e4 = await this.getRelayerSubscriptions();
      if (typeof e4 > "u" || !e4.length)
        return;
      if (this.subscriptions.size) {
        const { message: t3 } = te2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t3);
      }
      this.cached = e4, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e4) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e4);
    }
  }
  async batchSubscribe(e4) {
    e4.length && (await this.rpcBatchSubscribe(e4), this.onBatchSubscribe(e4.map((t3) => Ie3(Z2({}, t3), { id: this.getSubscriptionId(t3.topic) }))));
  }
  async batchFetchMessages(e4) {
    if (!e4.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e4.length} subscriptions`);
    const t3 = await this.rpcBatchFetchMessages(e4);
    t3 && t3.messages && (await vo2((0, import_time4.toMiliseconds)(import_time4.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t3.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen();
  }
  getSubscriptionId(e4) {
    return si(e4 + this.clientId);
  }
};
var mn3 = Object.defineProperty;
var si2 = Object.getOwnPropertySymbols;
var bn3 = Object.prototype.hasOwnProperty;
var fn2 = Object.prototype.propertyIsEnumerable;
var ri2 = (o6, e4, t3) => e4 in o6 ? mn3(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var ni2 = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    bn3.call(e4, t3) && ri2(o6, t3, e4[t3]);
  if (si2)
    for (var t3 of si2(e4))
      fn2.call(e4, t3) && ri2(o6, t3, e4[t3]);
  return o6;
};
var oi2 = class extends u3 {
  constructor(e4) {
    super(e4), this.protocol = "wc", this.version = 2, this.events = new EventEmitter(), this.name = at2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false, this.heartBeatTimeout = (0, import_time4.toMiliseconds)(import_time4.THIRTY_SECONDS + import_time4.FIVE_SECONDS), this.requestsInFlight = [], this.connectTimeout = (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15), this.request = async (t3) => {
      var s5, i5;
      this.logger.debug("Publishing Request Payload");
      const r5 = t3.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: r5, method: t3.method, topic: (s5 = t3.params) == null ? void 0 : s5.topic }, "relayer.request - publishing...");
        const n6 = `${r5}:${((i5 = t3.params) == null ? void 0 : i5.tag) || ""}`;
        this.requestsInFlight.push(n6);
        const a4 = await this.provider.request(t3);
        return this.requestsInFlight = this.requestsInFlight.filter((c5) => c5 !== n6), a4;
      } catch (n6) {
        throw this.logger.debug(`Failed to Publish Request: ${r5}`), n6;
      }
    }, this.resetPingTimeout = () => {
      if (et())
        try {
          clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var t3, s5, i5;
            this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (i5 = (s5 = (t3 = this.provider) == null ? void 0 : t3.connection) == null ? void 0 : s5.socket) == null || i5.terminate();
          }, this.heartBeatTimeout);
        } catch (t3) {
          this.logger.warn(t3, t3?.message);
        }
    }, this.onPayloadHandler = (t3) => {
      this.onProviderPayload(t3), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.warn({}, "Relayer connected \u{1F6DC}"), this.startPingTimeout(), this.events.emit(v6.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.warn({}, "Relayer disconnected \u{1F6D1}"), this.requestsInFlight = [], this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t3) => {
      this.logger.fatal(t3, `Fatal socket error: ${t3?.message}`), this.events.emit(v6.error, t3), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(C6.payload, this.onPayloadHandler), this.provider.on(C6.connect, this.onConnectHandler), this.provider.on(C6.disconnect, this.onDisconnectHandler), this.provider.on(C6.error, this.onProviderErrorHandler);
    }, this.core = e4.core, this.logger = typeof e4.logger < "u" && typeof e4.logger != "string" ? E5(e4.logger, this.name) : (0, import_pino2.default)(k4({ level: e4.logger || ot2 })), this.messages = new Jt3(this.logger, e4.core), this.subscriber = new ii2(this, this.logger), this.publisher = new ln2(this, this.logger), this.relayUrl = e4?.relayUrl || fe3, this.projectId = e4.projectId, Wr2() ? this.packageName = Jr2() : zr2() && (this.bundleId = Jr2()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0)
      try {
        await this.transportOpen();
      } catch (e4) {
        this.logger.warn(e4, e4?.message);
      }
  }
  get context() {
    return y5(this.logger);
  }
  get connected() {
    var e4, t3, s5;
    return ((s5 = (t3 = (e4 = this.provider) == null ? void 0 : e4.connection) == null ? void 0 : t3.socket) == null ? void 0 : s5.readyState) === 1;
  }
  get connecting() {
    var e4, t3, s5;
    return ((s5 = (t3 = (e4 = this.provider) == null ? void 0 : e4.connection) == null ? void 0 : t3.socket) == null ? void 0 : s5.readyState) === 0;
  }
  async publish(e4, t3, s5) {
    this.isInitialized(), await this.publisher.publish(e4, t3, s5), await this.recordMessageEvent({ topic: e4, message: t3, publishedAt: Date.now(), transportType: M6.relay });
  }
  async subscribe(e4, t3) {
    var s5, i5, r5;
    this.isInitialized(), (!(t3 != null && t3.transportType) || t3?.transportType === "relay") && await this.toEstablishConnection();
    const n6 = typeof ((s5 = t3?.internal) == null ? void 0 : s5.throwOnFailedPublish) > "u" ? true : (i5 = t3?.internal) == null ? void 0 : i5.throwOnFailedPublish;
    let a4 = ((r5 = this.subscriber.topicMap.get(e4)) == null ? void 0 : r5[0]) || "", c5;
    const h7 = (u4) => {
      u4.topic === e4 && (this.subscriber.off(T5.created, h7), c5());
    };
    return await Promise.all([new Promise((u4) => {
      c5 = u4, this.subscriber.on(T5.created, h7);
    }), new Promise(async (u4, d6) => {
      a4 = await this.subscriber.subscribe(e4, ni2({ internal: { throwOnFailedPublish: n6 } }, t3)).catch((y7) => {
        n6 && d6(y7);
      }) || a4, u4();
    })]), a4;
  }
  async unsubscribe(e4, t3) {
    this.isInitialized(), await this.subscriber.unsubscribe(e4, t3);
  }
  on(e4, t3) {
    this.events.on(e4, t3);
  }
  once(e4, t3) {
    this.events.once(e4, t3);
  }
  off(e4, t3) {
    this.events.off(e4, t3);
  }
  removeListener(e4, t3) {
    this.events.removeListener(e4, t3);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ao2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e4) {
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t3, s5) => {
      await this.connect(e4).then(t3).catch(s5).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected)
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e4) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e4 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Yi())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e4) {
    if (e4?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t3 = e4.sort((s5, i5) => s5.publishedAt - i5.publishedAt);
    this.logger.debug(`Batch of ${t3.length} message events sorted`);
    for (const s5 of t3)
      try {
        await this.onMessageEvent(s5);
      } catch (i5) {
        this.logger.warn(i5, "Error while processing batch message event: " + i5?.message);
      }
    this.logger.trace(`Batch of ${t3.length} message events processed`);
  }
  async onLinkMessageEvent(e4, t3) {
    const { topic: s5 } = e4;
    if (!t3.sessionExists) {
      const i5 = ho2(import_time4.FIVE_MINUTES), r5 = { topic: s5, expiry: i5, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s5, r5);
    }
    this.events.emit(v6.message, e4), await this.recordMessageEvent(e4);
  }
  async connect(e4) {
    await this.confirmOnlineStateOrThrow(), e4 && e4 !== this.relayUrl && (this.relayUrl = e4, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t3 = 1;
    for (; t3 < 6; ) {
      try {
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t3}...`), await this.createProvider(), await new Promise(async (s5, i5) => {
          const r5 = () => {
            i5(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(C6.disconnect, r5), await ao2(new Promise((n6, a4) => {
            this.provider.connect().then(n6).catch(a4);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((n6) => {
            i5(n6);
          }).finally(() => {
            this.provider.off(C6.disconnect, r5), clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
          }), await new Promise(async (n6, a4) => {
            const c5 = () => {
              a4(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(C6.disconnect, c5), await this.subscriber.start().then(n6).catch(a4).finally(() => {
              this.provider.off(C6.disconnect, c5);
            });
          }), this.hasExperiencedNetworkDisruption = false, s5();
        });
      } catch (s5) {
        await this.subscriber.stop();
        const i5 = s5;
        this.logger.warn({}, i5.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t3}`);
        break;
      }
      await new Promise((s5) => setTimeout(s5, (0, import_time4.toMiliseconds)(t3 * 1))), t3++;
    }
  }
  startPingTimeout() {
    var e4, t3, s5, i5, r5;
    if (et())
      try {
        (t3 = (e4 = this.provider) == null ? void 0 : e4.connection) != null && t3.socket && ((r5 = (i5 = (s5 = this.provider) == null ? void 0 : s5.connection) == null ? void 0 : i5.socket) == null || r5.on("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (n6) {
        this.logger.warn(n6, n6?.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e4 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o5(new f4(Zr2({ sdkVersion: re2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e4, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e4) {
    const { topic: t3, message: s5 } = e4;
    await this.messages.set(t3, s5);
  }
  async shouldIgnoreMessageEvent(e4) {
    const { topic: t3, message: s5 } = e4;
    if (!s5 || s5.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${s5}`), true;
    if (!await this.subscriber.isSubscribed(t3))
      return this.logger.warn(`Ignoring message for non-subscribed topic ${t3}`), true;
    const i5 = this.messages.has(t3, s5);
    return i5 && this.logger.warn(`Ignoring duplicate message: ${s5}`), i5;
  }
  async onProviderPayload(e4) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e4 }), isJsonRpcRequest(e4)) {
      if (!e4.method.endsWith(ct3))
        return;
      const t3 = e4.params, { topic: s5, message: i5, publishedAt: r5, attestation: n6 } = t3.data, a4 = { topic: s5, message: i5, publishedAt: r5, transportType: M6.relay, attestation: n6 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(ni2({ type: "event", event: t3.id }, a4)), this.events.emit(t3.id, a4), await this.acknowledgePayload(e4), await this.onMessageEvent(a4);
    } else
      isJsonRpcResponse(e4) && this.events.emit(v6.message_ack, e4);
  }
  async onMessageEvent(e4) {
    await this.shouldIgnoreMessageEvent(e4) || (this.events.emit(v6.message, e4), await this.recordMessageEvent(e4));
  }
  async acknowledgePayload(e4) {
    const t3 = formatJsonRpcResult(e4.id, true);
    await this.provider.connection.send(t3);
  }
  unregisterProviderListeners() {
    this.provider.off(C6.payload, this.onPayloadHandler), this.provider.off(C6.connect, this.onConnectHandler), this.provider.off(C6.disconnect, this.onDisconnectHandler), this.provider.off(C6.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e4 = await Yi();
    Xi(async (t3) => {
      e4 !== t3 && (e4 = t3, t3 ? await this.transportOpen().catch((s5) => this.logger.error(s5, s5?.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), clearTimeout(this.pingTimeout), this.events.emit(v6.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || this.connectPromise || (this.reconnectTimeout = setTimeout(async () => {
      clearTimeout(this.reconnectTimeout), await this.transportOpen().catch((e4) => this.logger.error(e4, e4?.message));
    }, (0, import_time4.toMiliseconds)(ht3))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && await this.transportOpen();
  }
};
var vn3 = Object.defineProperty;
var ai2 = Object.getOwnPropertySymbols;
var _n3 = Object.prototype.hasOwnProperty;
var En3 = Object.prototype.propertyIsEnumerable;
var ci2 = (o6, e4, t3) => e4 in o6 ? vn3(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var hi2 = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    _n3.call(e4, t3) && ci2(o6, t3, e4[t3]);
  if (ai2)
    for (var t3 of ai2(e4))
      En3.call(e4, t3) && ci2(o6, t3, e4[t3]);
  return o6;
};
var li2 = class extends p4 {
  constructor(e4, t3, s5, i5 = A5, r5 = void 0) {
    super(e4, t3, s5, i5), this.core = e4, this.logger = t3, this.name = s5, this.map = /* @__PURE__ */ new Map(), this.version = lt3, this.cached = [], this.initialized = false, this.storagePrefix = A5, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n6) => {
        this.getKey && n6 !== null && !ae(n6) ? this.map.set(this.getKey(n6), n6) : Pi(n6) ? this.map.set(n6.id, n6) : Li(n6) && this.map.set(n6.topic, n6);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n6, a4) => {
      this.isInitialized(), this.map.has(n6) ? await this.update(n6, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n6, value: a4 }), this.map.set(n6, a4), await this.persist());
    }, this.get = (n6) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n6 }), this.getData(n6)), this.getAll = (n6) => (this.isInitialized(), n6 ? this.values.filter((a4) => Object.keys(n6).every((c5) => (0, import_lodash.default)(a4[c5], n6[c5]))) : this.values), this.update = async (n6, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n6, update: a4 });
      const c5 = hi2(hi2({}, this.getData(n6)), a4);
      this.map.set(n6, c5), await this.persist();
    }, this.delete = async (n6, a4) => {
      this.isInitialized(), this.map.has(n6) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n6, reason: a4 }), this.map.delete(n6), this.addToRecentlyDeleted(n6), await this.persist());
    }, this.logger = E5(t3, this.name), this.storagePrefix = i5, this.getKey = r5;
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e4) {
    this.recentlyDeleted.push(e4), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e4) {
    await this.core.storage.setItem(this.storageKey, e4);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e4) {
    const t3 = this.map.get(e4);
    if (!t3) {
      if (this.recentlyDeleted.includes(e4)) {
        const { message: i5 } = te2("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e4}`);
        throw this.logger.error(i5), new Error(i5);
      }
      const { message: s5 } = te2("NO_MATCHING_KEY", `${this.name}: ${e4}`);
      throw this.logger.error(s5), new Error(s5);
    }
    return t3;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e4 = await this.getDataStore();
      if (typeof e4 > "u" || !e4.length)
        return;
      if (this.map.size) {
        const { message: t3 } = te2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e4, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e4) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var ui2 = class {
  constructor(e4, t3) {
    this.core = e4, this.logger = t3, this.name = yt3, this.version = Dt2, this.events = new y(), this.initialized = false, this.storagePrefix = A5, this.ignoredPayloadTypes = [Ie2], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s5 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s5])];
    }, this.create = async (s5) => {
      this.isInitialized();
      const i5 = ni(), r5 = await this.core.crypto.setSymKey(i5), n6 = ho2(import_time4.FIVE_MINUTES), a4 = { protocol: nt2 }, c5 = { topic: r5, expiry: n6, relay: a4, active: false, methods: s5?.methods }, h7 = wi({ protocol: this.core.protocol, version: this.core.version, topic: r5, symKey: i5, relay: a4, expiryTimestamp: n6, methods: s5?.methods });
      return this.events.emit(j5.create, c5), this.core.expirer.set(r5, n6), await this.pairings.set(r5, c5), await this.core.relayer.subscribe(r5, { transportType: s5?.transportType }), { topic: r5, uri: h7 };
    }, this.pair = async (s5) => {
      this.isInitialized();
      const i5 = this.core.eventClient.createEvent({ properties: { topic: s5?.uri, trace: [z6.pairing_started] } });
      this.isValidPair(s5, i5);
      const { topic: r5, symKey: n6, relay: a4, expiryTimestamp: c5, methods: h7 } = bi(s5.uri);
      i5.props.properties.topic = r5, i5.addTrace(z6.pairing_uri_validation_success), i5.addTrace(z6.pairing_uri_not_expired);
      let u4;
      if (this.pairings.keys.includes(r5)) {
        if (u4 = this.pairings.get(r5), i5.addTrace(z6.existing_pairing), u4.active)
          throw i5.setError($3.active_pairing_already_exists), new Error(`Pairing already exists: ${r5}. Please try again with a new connection URI.`);
        i5.addTrace(z6.pairing_not_expired);
      }
      const d6 = c5 || ho2(import_time4.FIVE_MINUTES), y7 = { topic: r5, relay: a4, expiry: d6, active: false, methods: h7 };
      this.core.expirer.set(r5, d6), await this.pairings.set(r5, y7), i5.addTrace(z6.store_new_pairing), s5.activatePairing && await this.activate({ topic: r5 }), this.events.emit(j5.create, y7), i5.addTrace(z6.emit_inactive_pairing), this.core.crypto.keychain.has(r5) || await this.core.crypto.setSymKey(n6, r5), i5.addTrace(z6.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i5.setError($3.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r5, { relay: a4 });
      } catch (m4) {
        throw i5.setError($3.subscribe_pairing_topic_failure), m4;
      }
      return i5.addTrace(z6.subscribe_pairing_topic_success), y7;
    }, this.activate = async ({ topic: s5 }) => {
      this.isInitialized();
      const i5 = ho2(import_time4.FIVE_MINUTES);
      this.core.expirer.set(s5, i5), await this.pairings.update(s5, { active: true, expiry: i5 });
    }, this.ping = async (s5) => {
      this.isInitialized(), await this.isValidPing(s5), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: i5 } = s5;
      if (this.pairings.keys.includes(i5)) {
        const r5 = await this.sendRequest(i5, "wc_pairingPing", {}), { done: n6, resolve: a4, reject: c5 } = co2();
        this.events.once(go2("pairing_ping", r5), ({ error: h7 }) => {
          h7 ? c5(h7) : a4();
        }), await n6();
      }
    }, this.updateExpiry = async ({ topic: s5, expiry: i5 }) => {
      this.isInitialized(), await this.pairings.update(s5, { expiry: i5 });
    }, this.updateMetadata = async ({ topic: s5, metadata: i5 }) => {
      this.isInitialized(), await this.pairings.update(s5, { peerMetadata: i5 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s5) => {
      this.isInitialized(), await this.isValidDisconnect(s5);
      const { topic: i5 } = s5;
      this.pairings.keys.includes(i5) && (await this.sendRequest(i5, "wc_pairingDelete", de2("USER_DISCONNECTED")), await this.deletePairing(i5));
    }, this.formatUriFromPairing = (s5) => {
      this.isInitialized();
      const { topic: i5, relay: r5, expiry: n6, methods: a4 } = s5, c5 = this.core.crypto.keychain.get(i5);
      return wi({ protocol: this.core.protocol, version: this.core.version, topic: i5, symKey: c5, relay: r5, expiryTimestamp: n6, methods: a4 });
    }, this.sendRequest = async (s5, i5, r5) => {
      const n6 = formatJsonRpcRequest(i5, r5), a4 = await this.core.crypto.encode(s5, n6), c5 = V3[i5].req;
      return this.core.history.set(s5, n6), this.core.relayer.publish(s5, a4, c5), n6.id;
    }, this.sendResult = async (s5, i5, r5) => {
      const n6 = formatJsonRpcResult(s5, r5), a4 = await this.core.crypto.encode(i5, n6), c5 = await this.core.history.get(i5, s5), h7 = V3[c5.request.method].res;
      await this.core.relayer.publish(i5, a4, h7), await this.core.history.resolve(n6);
    }, this.sendError = async (s5, i5, r5) => {
      const n6 = formatJsonRpcError(s5, r5), a4 = await this.core.crypto.encode(i5, n6), c5 = await this.core.history.get(i5, s5), h7 = V3[c5.request.method] ? V3[c5.request.method].res : V3.unregistered_method.res;
      await this.core.relayer.publish(i5, a4, h7), await this.core.history.resolve(n6);
    }, this.deletePairing = async (s5, i5) => {
      await this.core.relayer.unsubscribe(s5), await Promise.all([this.pairings.delete(s5, de2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s5), i5 ? Promise.resolve() : this.core.expirer.del(s5)]);
    }, this.cleanup = async () => {
      const s5 = this.pairings.getAll().filter((i5) => po2(i5.expiry));
      await Promise.all(s5.map((i5) => this.deletePairing(i5.topic)));
    }, this.onRelayEventRequest = (s5) => {
      const { topic: i5, payload: r5 } = s5;
      switch (r5.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i5, r5);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i5, r5);
        default:
          return this.onUnknownRpcMethodRequest(i5, r5);
      }
    }, this.onRelayEventResponse = async (s5) => {
      const { topic: i5, payload: r5 } = s5, n6 = (await this.core.history.get(i5, r5.id)).request.method;
      switch (n6) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i5, r5);
        default:
          return this.onUnknownRpcMethodResponse(n6);
      }
    }, this.onPairingPingRequest = async (s5, i5) => {
      const { id: r5 } = i5;
      try {
        this.isValidPing({ topic: s5 }), await this.sendResult(r5, s5, true), this.events.emit(j5.ping, { id: r5, topic: s5 });
      } catch (n6) {
        await this.sendError(r5, s5, n6), this.logger.error(n6);
      }
    }, this.onPairingPingResponse = (s5, i5) => {
      const { id: r5 } = i5;
      setTimeout(() => {
        isJsonRpcResult(i5) ? this.events.emit(go2("pairing_ping", r5), {}) : isJsonRpcError(i5) && this.events.emit(go2("pairing_ping", r5), { error: i5.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s5, i5) => {
      const { id: r5 } = i5;
      try {
        this.isValidDisconnect({ topic: s5 }), await this.deletePairing(s5), this.events.emit(j5.delete, { id: r5, topic: s5 });
      } catch (n6) {
        await this.sendError(r5, s5, n6), this.logger.error(n6);
      }
    }, this.onUnknownRpcMethodRequest = async (s5, i5) => {
      const { id: r5, method: n6 } = i5;
      try {
        if (this.registeredMethods.includes(n6))
          return;
        const a4 = de2("WC_METHOD_UNSUPPORTED", n6);
        await this.sendError(r5, s5, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(r5, s5, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodResponse = (s5) => {
      this.registeredMethods.includes(s5) || this.logger.error(de2("WC_METHOD_UNSUPPORTED", s5));
    }, this.isValidPair = (s5, i5) => {
      var r5;
      if (!Di(s5)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `pair() params: ${s5}`);
        throw i5.setError($3.malformed_pairing_uri), new Error(a4);
      }
      if (!Ri(s5.uri)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `pair() uri: ${s5.uri}`);
        throw i5.setError($3.malformed_pairing_uri), new Error(a4);
      }
      const n6 = bi(s5?.uri);
      if (!((r5 = n6?.relay) != null && r5.protocol)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i5.setError($3.malformed_pairing_uri), new Error(a4);
      }
      if (!(n6 != null && n6.symKey)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i5.setError($3.malformed_pairing_uri), new Error(a4);
      }
      if (n6 != null && n6.expiryTimestamp && (0, import_time4.toMiliseconds)(n6?.expiryTimestamp) < Date.now()) {
        i5.setError($3.pairing_expired);
        const { message: a4 } = te2("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }, this.isValidPing = async (s5) => {
      if (!Di(s5)) {
        const { message: r5 } = te2("MISSING_OR_INVALID", `ping() params: ${s5}`);
        throw new Error(r5);
      }
      const { topic: i5 } = s5;
      await this.isValidPairingTopic(i5);
    }, this.isValidDisconnect = async (s5) => {
      if (!Di(s5)) {
        const { message: r5 } = te2("MISSING_OR_INVALID", `disconnect() params: ${s5}`);
        throw new Error(r5);
      }
      const { topic: i5 } = s5;
      await this.isValidPairingTopic(i5);
    }, this.isValidPairingTopic = async (s5) => {
      if (!q3(s5, false)) {
        const { message: i5 } = te2("MISSING_OR_INVALID", `pairing topic should be a string: ${s5}`);
        throw new Error(i5);
      }
      if (!this.pairings.keys.includes(s5)) {
        const { message: i5 } = te2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s5}`);
        throw new Error(i5);
      }
      if (po2(this.pairings.get(s5).expiry)) {
        await this.deletePairing(s5);
        const { message: i5 } = te2("EXPIRED", `pairing topic: ${s5}`);
        throw new Error(i5);
      }
    }, this.core = e4, this.logger = E5(t3, this.name), this.pairings = new li2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y5(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(v6.message, async (e4) => {
      const { topic: t3, message: s5, transportType: i5 } = e4;
      if (!this.pairings.keys.includes(t3) || i5 === M6.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s5)))
        return;
      const r5 = await this.core.crypto.decode(t3, s5);
      try {
        isJsonRpcRequest(r5) ? (this.core.history.set(t3, r5), this.onRelayEventRequest({ topic: t3, payload: r5 })) : isJsonRpcResponse(r5) && (await this.core.history.resolve(r5), await this.onRelayEventResponse({ topic: t3, payload: r5 }), this.core.history.delete(t3, r5.id));
      } catch (n6) {
        this.logger.error(n6);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(x8.expired, async (e4) => {
      const { topic: t3 } = lo2(e4.target);
      t3 && this.pairings.keys.includes(t3) && (await this.deletePairing(t3, true), this.events.emit(j5.expire, { topic: t3 }));
    });
  }
};
var di2 = class extends h5 {
  constructor(e4, t3) {
    super(e4, t3), this.core = e4, this.logger = t3, this.records = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = mt2, this.version = bt3, this.cached = [], this.initialized = false, this.storagePrefix = A5, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s5) => this.records.set(s5.id, s5)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s5, i5, r5) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s5, request: i5, chainId: r5 }), this.records.has(i5.id))
        return;
      const n6 = { id: i5.id, topic: s5, request: { method: i5.method, params: i5.params || null }, chainId: r5, expiry: ho2(import_time4.THIRTY_DAYS) };
      this.records.set(n6.id, n6), this.persist(), this.events.emit(R2.created, n6);
    }, this.resolve = async (s5) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s5 }), !this.records.has(s5.id))
        return;
      const i5 = await this.getRecord(s5.id);
      typeof i5.response > "u" && (i5.response = isJsonRpcError(s5) ? { error: s5.error } : { result: s5.result }, this.records.set(i5.id, i5), this.persist(), this.events.emit(R2.updated, i5));
    }, this.get = async (s5, i5) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s5, id: i5 }), await this.getRecord(i5)), this.delete = (s5, i5) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i5 }), this.values.forEach((r5) => {
        if (r5.topic === s5) {
          if (typeof i5 < "u" && r5.id !== i5)
            return;
          this.records.delete(r5.id), this.events.emit(R2.deleted, r5);
        }
      }), this.persist();
    }, this.exists = async (s5, i5) => (this.isInitialized(), this.records.has(i5) ? (await this.getRecord(i5)).topic === s5 : false), this.on = (s5, i5) => {
      this.events.on(s5, i5);
    }, this.once = (s5, i5) => {
      this.events.once(s5, i5);
    }, this.off = (s5, i5) => {
      this.events.off(s5, i5);
    }, this.removeListener = (s5, i5) => {
      this.events.removeListener(s5, i5);
    }, this.logger = E5(t3, this.name);
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e4 = [];
    return this.values.forEach((t3) => {
      if (typeof t3.response < "u")
        return;
      const s5 = { topic: t3.topic, request: formatJsonRpcRequest(t3.request.method, t3.request.params, t3.id), chainId: t3.chainId };
      return e4.push(s5);
    }), e4;
  }
  async setJsonRpcRecords(e4) {
    await this.core.storage.setItem(this.storageKey, e4);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e4) {
    this.isInitialized();
    const t3 = this.records.get(e4);
    if (!t3) {
      const { message: s5 } = te2("NO_MATCHING_KEY", `${this.name}: ${e4}`);
      throw new Error(s5);
    }
    return t3;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e4 = await this.getJsonRpcRecords();
      if (typeof e4 > "u" || !e4.length)
        return;
      if (this.records.size) {
        const { message: t3 } = te2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e4, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e4) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e4);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e4) => {
      const t3 = R2.created;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e4 });
    }), this.events.on(R2.updated, (e4) => {
      const t3 = R2.updated;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e4 });
    }), this.events.on(R2.deleted, (e4) => {
      const t3 = R2.deleted;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e4 });
    }), this.core.heartbeat.on(r3.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e4 = false;
      this.records.forEach((t3) => {
        (0, import_time4.toMiliseconds)(t3.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t3.id}`), this.records.delete(t3.id), this.events.emit(R2.deleted, t3, false), e4 = true);
      }), e4 && this.persist();
    } catch (e4) {
      this.logger.warn(e4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var pi2 = class extends x5 {
  constructor(e4, t3) {
    super(e4, t3), this.core = e4, this.logger = t3, this.expirations = /* @__PURE__ */ new Map(), this.events = new EventEmitter(), this.name = ft3, this.version = vt3, this.cached = [], this.initialized = false, this.storagePrefix = A5, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s5) => this.expirations.set(s5.target, s5)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s5) => {
      try {
        const i5 = this.formatTarget(s5);
        return typeof this.getExpiration(i5) < "u";
      } catch {
        return false;
      }
    }, this.set = (s5, i5) => {
      this.isInitialized();
      const r5 = this.formatTarget(s5), n6 = { target: r5, expiry: i5 };
      this.expirations.set(r5, n6), this.checkExpiry(r5, n6), this.events.emit(x8.created, { target: r5, expiration: n6 });
    }, this.get = (s5) => {
      this.isInitialized();
      const i5 = this.formatTarget(s5);
      return this.getExpiration(i5);
    }, this.del = (s5) => {
      if (this.isInitialized(), this.has(s5)) {
        const i5 = this.formatTarget(s5), r5 = this.getExpiration(i5);
        this.expirations.delete(i5), this.events.emit(x8.deleted, { target: i5, expiration: r5 });
      }
    }, this.on = (s5, i5) => {
      this.events.on(s5, i5);
    }, this.once = (s5, i5) => {
      this.events.once(s5, i5);
    }, this.off = (s5, i5) => {
      this.events.off(s5, i5);
    }, this.removeListener = (s5, i5) => {
      this.events.removeListener(s5, i5);
    }, this.logger = E5(t3, this.name);
  }
  get context() {
    return y5(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e4) {
    if (typeof e4 == "string")
      return uo2(e4);
    if (typeof e4 == "number")
      return fo2(e4);
    const { message: t3 } = te2("UNKNOWN_TYPE", `Target type: ${typeof e4}`);
    throw new Error(t3);
  }
  async setExpirations(e4) {
    await this.core.storage.setItem(this.storageKey, e4);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(x8.sync);
  }
  async restore() {
    try {
      const e4 = await this.getExpirations();
      if (typeof e4 > "u" || !e4.length)
        return;
      if (this.expirations.size) {
        const { message: t3 } = te2("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e4, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e4) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e4);
    }
  }
  getExpiration(e4) {
    const t3 = this.expirations.get(e4);
    if (!t3) {
      const { message: s5 } = te2("NO_MATCHING_KEY", `${this.name}: ${e4}`);
      throw this.logger.warn(s5), new Error(s5);
    }
    return t3;
  }
  checkExpiry(e4, t3) {
    const { expiry: s5 } = t3;
    (0, import_time4.toMiliseconds)(s5) - Date.now() <= 0 && this.expire(e4, t3);
  }
  expire(e4, t3) {
    this.expirations.delete(e4), this.events.emit(x8.expired, { target: e4, expiration: t3 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e4, t3) => this.checkExpiry(t3, e4));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r3.pulse, () => this.checkExpirations()), this.events.on(x8.created, (e4) => {
      const t3 = x8.created;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e4 }), this.persist();
    }), this.events.on(x8.expired, (e4) => {
      const t3 = x8.expired;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e4 }), this.persist();
    }), this.events.on(x8.deleted, (e4) => {
      const t3 = x8.deleted;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e4 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e4 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(e4);
    }
  }
};
var gi2 = class extends y6 {
  constructor(e4, t3, s5) {
    super(e4, t3, s5), this.core = e4, this.logger = t3, this.store = s5, this.name = _t3, this.verifyUrlV3 = wt3, this.storagePrefix = A5, this.version = De3, this.init = async () => {
      var i5;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time4.toMiliseconds)((i5 = this.publicKey) == null ? void 0 : i5.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i5) => {
      if (!Ae2() || this.isDevEnv)
        return;
      const r5 = window.location.origin, { id: n6, decryptedId: a4 } = i5, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r5}&id=${n6}&decryptedId=${a4}`;
      try {
        const h7 = (0, import_window_getters2.getDocument)(), u4 = this.startAbortTimer(import_time4.ONE_SECOND * 5), d6 = await new Promise((y7, m4) => {
          const l6 = () => {
            window.removeEventListener("message", w6), h7.body.removeChild(g6), m4("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l6);
          const g6 = h7.createElement("iframe");
          g6.src = c5, g6.style.display = "none", g6.addEventListener("error", l6, { signal: this.abortController.signal });
          const w6 = (b4) => {
            if (b4.data && typeof b4.data == "string")
              try {
                const D5 = JSON.parse(b4.data);
                if (D5.type === "verify_attestation") {
                  if (sn(D5.attestation).payload.id !== n6)
                    return;
                  clearInterval(u4), h7.body.removeChild(g6), this.abortController.signal.removeEventListener("abort", l6), window.removeEventListener("message", w6), y7(D5.attestation === null ? "" : D5.attestation);
                }
              } catch (D5) {
                this.logger.warn(D5);
              }
          };
          h7.body.appendChild(g6), window.addEventListener("message", w6, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d6), d6;
      } catch (h7) {
        this.logger.warn(h7);
      }
      return "";
    }, this.resolve = async (i5) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: r5, hash: n6, encryptedId: a4 } = i5;
      if (r5 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r5) {
        if (sn(r5).payload.id !== a4)
          return;
        const h7 = await this.isValidJwtAttestation(r5);
        if (h7) {
          if (!h7.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h7;
        }
      }
      if (!n6)
        return;
      const c5 = this.getVerifyUrl(i5?.verifyUrl);
      return this.fetchAttestation(n6, c5);
    }, this.fetchAttestation = async (i5, r5) => {
      this.logger.debug(`resolving attestation: ${i5} from url: ${r5}`);
      const n6 = this.startAbortTimer(import_time4.ONE_SECOND * 5), a4 = await fetch(`${r5}/attestation/${i5}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n6), a4.status === 200 ? await a4.json() : void 0;
    }, this.getVerifyUrl = (i5) => {
      let r5 = i5 || X2;
      return It3.includes(r5) || (this.logger.info(`verify url: ${r5}, not included in trusted list, assigning default: ${X2}`), r5 = X2), r5;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i5 = this.startAbortTimer(import_time4.FIVE_SECONDS), r5 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i5), await r5.json();
      } catch (i5) {
        this.logger.warn(i5);
      }
    }, this.persistPublicKey = async (i5) => {
      this.logger.debug("persisting public key to local storage", i5), await this.store.setItem(this.storeKey, i5), this.publicKey = i5;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i5) => {
      const r5 = await this.getPublicKey();
      try {
        if (r5)
          return this.validateAttestation(i5, r5);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const n6 = await this.fetchAndPersistPublicKey();
      try {
        if (n6)
          return this.validateAttestation(i5, n6);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r5) => {
        const n6 = await this.fetchPublicKey();
        n6 && (await this.persistPublicKey(n6), r5(n6));
      });
      const i5 = await this.fetchPromise;
      return this.fetchPromise = void 0, i5;
    }, this.validateAttestation = (i5, r5) => {
      const n6 = gi(i5, r5.publicKey), a4 = { hasExpired: (0, import_time4.toMiliseconds)(n6.exp) < Date.now(), payload: n6 };
      if (a4.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }, this.logger = E5(t3, this.name), this.abortController = new AbortController(), this.isDevEnv = Eo2(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y5(this.logger);
  }
  startAbortTimer(e4) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time4.toMiliseconds)(e4));
  }
};
var yi2 = class extends v4 {
  constructor(e4, t3) {
    super(e4, t3), this.projectId = e4, this.logger = t3, this.context = Tt2, this.registerDeviceToken = async (s5) => {
      const { clientId: i5, token: r5, notificationType: n6, enableEncrypted: a4 = false } = s5, c5 = `${Ct2}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i5, type: n6, token: r5, always_raw: a4 }) });
    }, this.logger = E5(t3, this.context);
  }
};
var wn2 = Object.defineProperty;
var Di2 = Object.getOwnPropertySymbols;
var In3 = Object.prototype.hasOwnProperty;
var Tn3 = Object.prototype.propertyIsEnumerable;
var mi2 = (o6, e4, t3) => e4 in o6 ? wn2(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var Q4 = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    In3.call(e4, t3) && mi2(o6, t3, e4[t3]);
  if (Di2)
    for (var t3 of Di2(e4))
      Tn3.call(e4, t3) && mi2(o6, t3, e4[t3]);
  return o6;
};
var bi2 = class extends C4 {
  constructor(e4, t3, s5 = true) {
    super(e4, t3, s5), this.core = e4, this.logger = t3, this.context = St3, this.storagePrefix = A5, this.storageVersion = Pt3, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!Eo2())
        try {
          const i5 = { eventId: wo2(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Yt2(this.core.relayer.protocol, this.core.relayer.version, re2) } } };
          await this.sendEvent([i5]);
        } catch (i5) {
          this.logger.warn(i5);
        }
    }, this.createEvent = (i5) => {
      const { event: r5 = "ERROR", type: n6 = "", properties: { topic: a4, trace: c5 } } = i5, h7 = wo2(), u4 = this.core.projectId || "", d6 = Date.now(), y7 = Q4({ eventId: h7, timestamp: d6, props: { event: r5, type: n6, properties: { topic: a4, trace: c5 } }, bundleId: u4, domain: this.getAppDomain() }, this.setMethods(h7));
      return this.telemetryEnabled && (this.events.set(h7, y7), this.shouldPersist = true), y7;
    }, this.getEvent = (i5) => {
      const { eventId: r5, topic: n6 } = i5;
      if (r5)
        return this.events.get(r5);
      const a4 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === n6);
      if (a4)
        return Q4(Q4({}, a4), this.setMethods(a4.eventId));
    }, this.deleteEvent = (i5) => {
      const { eventId: r5 } = i5;
      this.events.delete(r5), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r3.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i5) => {
          (0, import_time4.fromMiliseconds)(Date.now()) - (0, import_time4.fromMiliseconds)(i5.timestamp) > Rt3 && (this.events.delete(i5.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i5) => ({ addTrace: (r5) => this.addTrace(i5, r5), setError: (r5) => this.setError(i5, r5) }), this.addTrace = (i5, r5) => {
      const n6 = this.events.get(i5);
      n6 && (n6.props.properties.trace.push(r5), this.events.set(i5, n6), this.shouldPersist = true);
    }, this.setError = (i5, r5) => {
      const n6 = this.events.get(i5);
      n6 && (n6.props.type = r5, n6.timestamp = Date.now(), this.events.set(i5, n6), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i5 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i5.length)
          return;
        i5.forEach((r5) => {
          this.events.set(r5.eventId, Q4(Q4({}, r5), this.setMethods(r5.eventId)));
        });
      } catch (i5) {
        this.logger.warn(i5);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const i5 = [];
      for (const [r5, n6] of this.events)
        n6.props.type && i5.push(n6);
      if (i5.length !== 0)
        try {
          if ((await this.sendEvent(i5)).ok)
            for (const r5 of i5)
              this.events.delete(r5.eventId), this.shouldPersist = true;
        } catch (r5) {
          this.logger.warn(r5);
        }
    }, this.sendEvent = async (i5) => {
      const r5 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${xt3}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${re2}${r5}`, { method: "POST", body: JSON.stringify(i5) });
    }, this.getAppDomain = () => Yr2().url, this.logger = E5(t3, this.context), this.telemetryEnabled = s5, s5 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Cn3 = Object.defineProperty;
var fi2 = Object.getOwnPropertySymbols;
var Pn2 = Object.prototype.hasOwnProperty;
var Sn2 = Object.prototype.propertyIsEnumerable;
var vi = (o6, e4, t3) => e4 in o6 ? Cn3(o6, e4, { enumerable: true, configurable: true, writable: true, value: t3 }) : o6[e4] = t3;
var _i = (o6, e4) => {
  for (var t3 in e4 || (e4 = {}))
    Pn2.call(e4, t3) && vi(o6, t3, e4[t3]);
  if (fi2)
    for (var t3 of fi2(e4))
      Sn2.call(e4, t3) && vi(o6, t3, e4[t3]);
  return o6;
};
var oe2 = class extends n4 {
  constructor(e4) {
    var t3;
    super(e4), this.protocol = ye2, this.version = De3, this.name = J4, this.events = new EventEmitter(), this.initialized = false, this.on = (n6, a4) => this.events.on(n6, a4), this.once = (n6, a4) => this.events.once(n6, a4), this.off = (n6, a4) => this.events.off(n6, a4), this.removeListener = (n6, a4) => this.events.removeListener(n6, a4), this.dispatchEnvelope = ({ topic: n6, message: a4, sessionExists: c5 }) => {
      if (!n6 || !a4)
        return;
      const h7 = { topic: n6, message: a4, publishedAt: Date.now(), transportType: M6.link_mode };
      this.relayer.onLinkMessageEvent(h7, { sessionExists: c5 });
    }, this.projectId = e4?.projectId, this.relayUrl = e4?.relayUrl || fe3, this.customStoragePrefix = e4 != null && e4.customStoragePrefix ? `:${e4.customStoragePrefix}` : "";
    const s5 = k4({ level: typeof e4?.logger == "string" && e4.logger ? e4.logger : Xe3.logger, name: J4 }), { logger: i5, chunkLoggerController: r5 } = A4({ opts: s5, maxSizeInBytes: e4?.maxLogBlobSizeInBytes, loggerOverride: e4?.logger });
    this.logChunkController = r5, (t3 = this.logChunkController) != null && t3.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n6, a4;
      (n6 = this.logChunkController) != null && n6.downloadLogsBlobInBrowser && ((a4 = this.logChunkController) == null || a4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E5(i5, this.name), this.heartbeat = new i3(), this.crypto = new Yt3(this, this.logger, e4?.keychain), this.history = new di2(this, this.logger), this.expirer = new pi2(this, this.logger), this.storage = e4 != null && e4.storage ? e4.storage : new h3(_i(_i({}, We3), e4?.storageOptions)), this.relayer = new oi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ui2(this, this.logger), this.verify = new gi2(this, this.logger, this.storage), this.echoClient = new yi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new bi2(this, this.logger, e4?.telemetryEnabled);
  }
  static async init(e4) {
    const t3 = new oe2(e4);
    await t3.initialize();
    const s5 = await t3.crypto.getClientId();
    return await t3.storage.setItem(ut3, s5), t3;
  }
  get context() {
    return y5(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e4;
    return (e4 = this.logChunkController) == null ? void 0 : e4.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e4) {
    this.linkModeSupportedApps.includes(e4) || (this.linkModeSupportedApps.push(e4), await this.storage.setItem(ve3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(ve3) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e4) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e4), this.logger.error(e4.message), e4;
    }
  }
};
var Rn3 = oe2;

// node_modules/.pnpm/@walletconnect+sign-client@2.18.0_@react-native-async-storage+async-storage@1.24.0_react-nati_kf5avlojmkzqi2ysx6j6liu7my/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time5 = __toESM(require_cjs4());
init_events();
var Ce4 = "wc";
var xe3 = 2;
var Le3 = "client";
var ye3 = `${Ce4}@${xe3}:${Le3}:`;
var we4 = { name: Le3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var De4 = "WALLETCONNECT_DEEPLINK_CHOICE";
var it4 = "proposal";
var rt4 = "Proposal expired";
var nt3 = "session";
var H5 = import_time5.SEVEN_DAYS;
var ot3 = "engine";
var v7 = { wc_sessionPropose: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time5.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time5.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me4 = { min: import_time5.FIVE_MINUTES, max: import_time5.SEVEN_DAYS };
var L4 = { idle: "IDLE", active: "ACTIVE" };
var at3 = "request";
var ct4 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var lt4 = "wc";
var pt3 = "auth";
var ht4 = "authKeys";
var dt4 = "pairingTopics";
var ut4 = "requests";
var oe3 = `${lt4}@${1.5}:${pt3}:`;
var ae3 = `${oe3}:PUB_KEY`;
var ys2 = Object.defineProperty;
var ws2 = Object.defineProperties;
var ms2 = Object.getOwnPropertyDescriptors;
var gt4 = Object.getOwnPropertySymbols;
var _s3 = Object.prototype.hasOwnProperty;
var Es3 = Object.prototype.propertyIsEnumerable;
var yt4 = (q4, o6, e4) => o6 in q4 ? ys2(q4, o6, { enumerable: true, configurable: true, writable: true, value: e4 }) : q4[o6] = e4;
var I4 = (q4, o6) => {
  for (var e4 in o6 || (o6 = {}))
    _s3.call(o6, e4) && yt4(q4, e4, o6[e4]);
  if (gt4)
    for (var e4 of gt4(o6))
      Es3.call(o6, e4) && yt4(q4, e4, o6[e4]);
  return q4;
};
var D4 = (q4, o6) => ws2(q4, ms2(o6));
var Rs2 = class extends M3 {
  constructor(o6) {
    super(o6), this.name = ot3, this.events = new y(), this.initialized = false, this.requestQueue = { state: L4.idle, queue: [] }, this.sessionRequestQueue = { state: L4.idle, queue: [] }, this.requestQueueDelay = import_time5.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v7) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time5.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t3 = D4(I4({}, e4), { requiredNamespaces: e4.requiredNamespaces || {}, optionalNamespaces: e4.optionalNamespaces || {} });
      await this.isValidConnect(t3);
      const { pairingTopic: s5, requiredNamespaces: i5, optionalNamespaces: r5, sessionProperties: n6, relays: a4 } = t3;
      let c5 = s5, h7, p5 = false;
      try {
        if (c5) {
          const E7 = this.client.core.pairing.pairings.get(c5);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), p5 = E7.active;
        }
      } catch (E7) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E7;
      }
      if (!c5 || !p5) {
        const { topic: E7, uri: S4 } = await this.client.core.pairing.create();
        c5 = E7, h7 = S4;
      }
      if (!c5) {
        const { message: E7 } = te2("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E7);
      }
      const d6 = await this.client.core.crypto.generateKeyPair(), l6 = v7.wc_sessionPropose.req.ttl || import_time5.FIVE_MINUTES, w6 = ho2(l6), m4 = I4({ requiredNamespaces: i5, optionalNamespaces: r5, relays: a4 ?? [{ protocol: nt2 }], proposer: { publicKey: d6, metadata: this.client.metadata }, expiryTimestamp: w6, pairingTopic: c5 }, n6 && { sessionProperties: n6 }), { reject: y7, resolve: _7, done: R3 } = co2(l6, rt4);
      this.events.once(go2("session_connect"), async ({ error: E7, session: S4 }) => {
        if (E7)
          y7(E7);
        else if (S4) {
          S4.self.publicKey = d6;
          const M7 = D4(I4({}, S4), { pairingTopic: m4.pairingTopic, requiredNamespaces: m4.requiredNamespaces, optionalNamespaces: m4.optionalNamespaces, transportType: M6.relay });
          await this.client.session.set(S4.topic, M7), await this.setExpiry(S4.topic, S4.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S4.peer.metadata }), this.cleanupDuplicatePairings(M7), _7(M7);
        }
      });
      const V4 = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m4, throwOnFailedPublish: true });
      return await this.setProposal(V4, I4({ id: V4 }, m4)), { uri: h7, approval: R3 };
    }, this.pair = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e4);
      } catch (t3) {
        throw this.client.logger.error("pair() failed"), t3;
      }
    }, this.approve = async (e4) => {
      var t3, s5, i5;
      const r5 = this.client.core.eventClient.createEvent({ properties: { topic: (t3 = e4?.id) == null ? void 0 : t3.toString(), trace: [xs2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N10) {
        throw r5.setError(Os2.no_internet_connection), N10;
      }
      try {
        await this.isValidProposalId(e4?.id);
      } catch (N10) {
        throw this.client.logger.error(`approve() -> proposal.get(${e4?.id}) failed`), r5.setError(Os2.proposal_not_found), N10;
      }
      try {
        await this.isValidApprove(e4);
      } catch (N10) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r5.setError(Os2.session_approve_namespace_validation_failure), N10;
      }
      const { id: n6, relayProtocol: a4, namespaces: c5, sessionProperties: h7, sessionConfig: p5 } = e4, d6 = this.client.proposal.get(n6);
      this.client.core.eventClient.deleteEvent({ eventId: r5.eventId });
      const { pairingTopic: l6, proposer: w6, requiredNamespaces: m4, optionalNamespaces: y7 } = d6;
      let _7 = (s5 = this.client.core.eventClient) == null ? void 0 : s5.getEvent({ topic: l6 });
      _7 || (_7 = (i5 = this.client.core.eventClient) == null ? void 0 : i5.createEvent({ type: xs2.session_approve_started, properties: { topic: l6, trace: [xs2.session_approve_started, xs2.session_namespaces_validation_success] } }));
      const R3 = await this.client.core.crypto.generateKeyPair(), V4 = w6.publicKey, E7 = await this.client.core.crypto.generateSharedKey(R3, V4), S4 = I4(I4({ relay: { protocol: a4 ?? "irn" }, namespaces: c5, controller: { publicKey: R3, metadata: this.client.metadata }, expiry: ho2(H5) }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), M7 = M6.relay;
      _7.addTrace(xs2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E7, { transportType: M7 });
      } catch (N10) {
        throw _7.setError(Os2.subscribe_session_topic_failure), N10;
      }
      _7.addTrace(xs2.subscribe_session_topic_success);
      const W4 = D4(I4({}, S4), { topic: E7, requiredNamespaces: m4, optionalNamespaces: y7, pairingTopic: l6, acknowledged: false, self: S4.controller, peer: { publicKey: w6.publicKey, metadata: w6.metadata }, controller: R3, transportType: M6.relay });
      await this.client.session.set(E7, W4), _7.addTrace(xs2.store_session);
      try {
        _7.addTrace(xs2.publishing_session_settle), await this.sendRequest({ topic: E7, method: "wc_sessionSettle", params: S4, throwOnFailedPublish: true }).catch((N10) => {
          throw _7?.setError(Os2.session_settle_publish_failure), N10;
        }), _7.addTrace(xs2.session_settle_publish_success), _7.addTrace(xs2.publishing_session_approve), await this.sendResult({ id: n6, topic: l6, result: { relay: { protocol: a4 ?? "irn" }, responderPublicKey: R3 }, throwOnFailedPublish: true }).catch((N10) => {
          throw _7?.setError(Os2.session_approve_publish_failure), N10;
        }), _7.addTrace(xs2.session_approve_publish_success);
      } catch (N10) {
        throw this.client.logger.error(N10), this.client.session.delete(E7, de2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E7), N10;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _7.eventId }), await this.client.core.pairing.updateMetadata({ topic: l6, metadata: w6.metadata }), await this.client.proposal.delete(n6, de2("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l6 }), await this.setExpiry(E7, ho2(H5)), { topic: E7, acknowledged: () => Promise.resolve(this.client.session.get(E7)) };
    }, this.reject = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e4);
      } catch (r5) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r5;
      }
      const { id: t3, reason: s5 } = e4;
      let i5;
      try {
        i5 = this.client.proposal.get(t3).pairingTopic;
      } catch (r5) {
        throw this.client.logger.error(`reject() -> proposal.get(${t3}) failed`), r5;
      }
      i5 && (await this.sendError({ id: t3, topic: i5, error: s5, rpcOpts: v7.wc_sessionPropose.reject }), await this.client.proposal.delete(t3, de2("USER_DISCONNECTED")));
    }, this.update = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e4);
      } catch (p5) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p5;
      }
      const { topic: t3, namespaces: s5 } = e4, { done: i5, resolve: r5, reject: n6 } = co2(), a4 = payloadId(), c5 = getBigIntRpcId().toString(), h7 = this.client.session.get(t3).namespaces;
      return this.events.once(go2("session_update", a4), ({ error: p5 }) => {
        p5 ? n6(p5) : r5();
      }), await this.client.session.update(t3, { namespaces: s5 }), await this.sendRequest({ topic: t3, method: "wc_sessionUpdate", params: { namespaces: s5 }, throwOnFailedPublish: true, clientRpcId: a4, relayRpcId: c5 }).catch((p5) => {
        this.client.logger.error(p5), this.client.session.update(t3, { namespaces: h7 }), n6(p5);
      }), { acknowledged: i5 };
    }, this.extend = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e4);
      } catch (a4) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a4;
      }
      const { topic: t3 } = e4, s5 = payloadId(), { done: i5, resolve: r5, reject: n6 } = co2();
      return this.events.once(go2("session_extend", s5), ({ error: a4 }) => {
        a4 ? n6(a4) : r5();
      }), await this.setExpiry(t3, ho2(H5)), this.sendRequest({ topic: t3, method: "wc_sessionExtend", params: {}, clientRpcId: s5, throwOnFailedPublish: true }).catch((a4) => {
        n6(a4);
      }), { acknowledged: i5 };
    }, this.request = async (e4) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e4);
      } catch (w6) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w6;
      }
      const { chainId: t3, request: s5, topic: i5, expiry: r5 = v7.wc_sessionRequest.req.ttl } = e4, n6 = this.client.session.get(i5);
      n6?.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const a4 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h7, resolve: p5, reject: d6 } = co2(r5, "Request expired. Please try again.");
      this.events.once(go2("session_request", a4), ({ error: w6, result: m4 }) => {
        w6 ? d6(w6) : p5(m4);
      });
      const l6 = this.getAppLinkIfEnabled(n6.peer.metadata, n6.transportType);
      return l6 ? (await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i5, method: "wc_sessionRequest", params: { request: D4(I4({}, s5), { expiryTimestamp: ho2(r5) }), chainId: t3 }, expiry: r5, throwOnFailedPublish: true, appLink: l6 }).catch((w6) => d6(w6)), this.client.events.emit("session_request_sent", { topic: i5, request: s5, chainId: t3, id: a4 }), await h7()) : await Promise.all([new Promise(async (w6) => {
        await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i5, method: "wc_sessionRequest", params: { request: D4(I4({}, s5), { expiryTimestamp: ho2(r5) }), chainId: t3 }, expiry: r5, throwOnFailedPublish: true }).catch((m4) => d6(m4)), this.client.events.emit("session_request_sent", { topic: i5, request: s5, chainId: t3, id: a4 }), w6();
      }), new Promise(async (w6) => {
        var m4;
        if (!((m4 = n6.sessionConfig) != null && m4.disableDeepLink)) {
          const y7 = await mo2(this.client.core.storage, De4);
          await yo2({ id: a4, topic: i5, wcDeepLink: y7 });
        }
        w6();
      }), h7()]).then((w6) => w6[2]);
    }, this.respond = async (e4) => {
      this.isInitialized(), await this.isValidRespond(e4);
      const { topic: t3, response: s5 } = e4, { id: i5 } = s5, r5 = this.client.session.get(t3);
      r5.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const n6 = this.getAppLinkIfEnabled(r5.peer.metadata, r5.transportType);
      isJsonRpcResult(s5) ? await this.sendResult({ id: i5, topic: t3, result: s5.result, throwOnFailedPublish: true, appLink: n6 }) : isJsonRpcError(s5) && await this.sendError({ id: i5, topic: t3, error: s5.error, appLink: n6 }), this.cleanupAfterResponse(e4);
    }, this.ping = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e4);
      } catch (s5) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s5;
      }
      const { topic: t3 } = e4;
      if (this.client.session.keys.includes(t3)) {
        const s5 = payloadId(), i5 = getBigIntRpcId().toString(), { done: r5, resolve: n6, reject: a4 } = co2();
        this.events.once(go2("session_ping", s5), ({ error: c5 }) => {
          c5 ? a4(c5) : n6();
        }), await Promise.all([this.sendRequest({ topic: t3, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s5, relayRpcId: i5 }), r5()]);
      } else
        this.client.core.pairing.pairings.keys.includes(t3) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t3 }));
    }, this.emit = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e4);
      const { topic: t3, event: s5, chainId: i5 } = e4, r5 = getBigIntRpcId().toString(), n6 = payloadId();
      await this.sendRequest({ topic: t3, method: "wc_sessionEvent", params: { event: s5, chainId: i5 }, throwOnFailedPublish: true, relayRpcId: r5, clientRpcId: n6 });
    }, this.disconnect = async (e4) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e4);
      const { topic: t3 } = e4;
      if (this.client.session.keys.includes(t3))
        await this.sendRequest({ topic: t3, method: "wc_sessionDelete", params: de2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t3, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t3))
        await this.client.core.pairing.disconnect({ topic: t3 });
      else {
        const { message: s5 } = te2("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t3}`);
        throw new Error(s5);
      }
    }, this.find = (e4) => (this.isInitialized(), this.client.session.getAll().filter((t3) => $i(t3, e4))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e4, t3) => {
      var s5;
      this.isInitialized(), this.isValidAuthenticate(e4);
      const i5 = t3 && this.client.core.linkModeSupportedApps.includes(t3) && ((s5 = this.client.metadata.redirect) == null ? void 0 : s5.linkMode), r5 = i5 ? M6.link_mode : M6.relay;
      r5 === M6.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n6, statement: a4 = "", uri: c5, domain: h7, nonce: p5, type: d6, exp: l6, nbf: w6, methods: m4 = [], expiry: y7 } = e4, _7 = [...e4.resources || []], { topic: R3, uri: V4 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r5 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R3, uri: V4 } });
      const E7 = await this.client.core.crypto.generateKeyPair(), S4 = oi(E7);
      if (await Promise.all([this.client.auth.authKeys.set(ae3, { responseTopic: S4, publicKey: E7 }), this.client.auth.pairingTopics.set(S4, { topic: S4, pairingTopic: R3 })]), await this.client.core.relayer.subscribe(S4, { transportType: r5 }), this.client.logger.info(`sending request to new pairing topic: ${R3}`), m4.length > 0) {
        const { namespace: O4 } = Ye2(n6[0]);
        let T6 = ts(O4, "request", m4);
        Me2(_7) && (T6 = ns(T6, _7.pop())), _7.push(T6);
      }
      const M7 = y7 && y7 > v7.wc_sessionAuthenticate.req.ttl ? y7 : v7.wc_sessionAuthenticate.req.ttl, W4 = { authPayload: { type: d6 ?? "caip122", chains: n6, statement: a4, aud: c5, domain: h7, version: "1", nonce: p5, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l6, nbf: w6, resources: _7 }, requester: { publicKey: E7, metadata: this.client.metadata }, expiryTimestamp: ho2(M7) }, N10 = { eip155: { chains: n6, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m4])], events: ["chainChanged", "accountsChanged"] } }, Ve3 = { requiredNamespaces: {}, optionalNamespaces: N10, relays: [{ protocol: "irn" }], pairingTopic: R3, proposer: { publicKey: E7, metadata: this.client.metadata }, expiryTimestamp: ho2(v7.wc_sessionPropose.req.ttl) }, { done: mt3, resolve: Me3, reject: Ee4 } = co2(M7, "Request expired"), ce3 = async ({ error: O4, session: T6 }) => {
        if (this.events.off(go2("session_request", G3), Re3), O4)
          Ee4(O4);
        else if (T6) {
          T6.self.publicKey = E7, await this.client.session.set(T6.topic, T6), await this.setExpiry(T6.topic, T6.expiry), R3 && await this.client.core.pairing.updateMetadata({ topic: R3, metadata: T6.peer.metadata });
          const le3 = this.client.session.get(T6.topic);
          await this.deleteProposal(Z3), Me3({ session: le3 });
        }
      }, Re3 = async (O4) => {
        var T6, le3, ke3;
        if (await this.deletePendingAuthRequest(G3, { message: "fulfilled", code: 0 }), O4.error) {
          const te4 = de2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O4.error.code === te4.code ? void 0 : (this.events.off(go2("session_connect"), ce3), Ee4(O4.error.message));
        }
        await this.deleteProposal(Z3), this.events.off(go2("session_connect"), ce3);
        const { cacaos: $e3, responder: j6 } = O4.result, Ie4 = [], Ke3 = [];
        for (const te4 of $e3) {
          await Yo2({ cacao: te4, projectId: this.client.core.projectId }) || (this.client.logger.error(te4, "Signature verification failed"), Ee4(de2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe4 } = te4, ve4 = Me2(fe4.resources), Ue3 = [On2(fe4.iss)], _t4 = ut2(fe4.iss);
          if (ve4) {
            const qe3 = rs(ve4), Et4 = os(ve4);
            Ie4.push(...qe3), Ue3.push(...Et4);
          }
          for (const qe3 of Ue3)
            Ke3.push(`${qe3}:${_t4}`);
        }
        const ee2 = await this.client.core.crypto.generateSharedKey(E7, j6.publicKey);
        let pe2;
        Ie4.length > 0 && (pe2 = { topic: ee2, acknowledged: true, self: { publicKey: E7, metadata: this.client.metadata }, peer: j6, controller: j6.publicKey, expiry: ho2(H5), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R3, namespaces: Ti([...new Set(Ie4)], [...new Set(Ke3)]), transportType: r5 }, await this.client.core.relayer.subscribe(ee2, { transportType: r5 }), await this.client.session.set(ee2, pe2), R3 && await this.client.core.pairing.updateMetadata({ topic: R3, metadata: j6.metadata }), pe2 = this.client.session.get(ee2)), (T6 = this.client.metadata.redirect) != null && T6.linkMode && (le3 = j6.metadata.redirect) != null && le3.linkMode && (ke3 = j6.metadata.redirect) != null && ke3.universal && t3 && (this.client.core.addLinkModeSupportedApp(j6.metadata.redirect.universal), this.client.session.update(ee2, { transportType: M6.link_mode })), Me3({ auths: $e3, session: pe2 });
      }, G3 = payloadId(), Z3 = payloadId();
      this.events.once(go2("session_connect"), ce3), this.events.once(go2("session_request", G3), Re3);
      let Se3;
      try {
        if (i5) {
          const O4 = formatJsonRpcRequest("wc_sessionAuthenticate", W4, G3);
          this.client.core.history.set(R3, O4);
          const T6 = await this.client.core.crypto.encode("", O4, { type: _e2, encoding: Qs });
          Se3 = Ei(t3, R3, T6);
        } else
          await Promise.all([this.sendRequest({ topic: R3, method: "wc_sessionAuthenticate", params: W4, expiry: e4.expiry, throwOnFailedPublish: true, clientRpcId: G3 }), this.sendRequest({ topic: R3, method: "wc_sessionPropose", params: Ve3, expiry: v7.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z3 })]);
      } catch (O4) {
        throw this.events.off(go2("session_connect"), ce3), this.events.off(go2("session_request", G3), Re3), O4;
      }
      return await this.setProposal(Z3, I4({ id: Z3 }, Ve3)), await this.setAuthRequest(G3, { request: D4(I4({}, W4), { verifyContext: {} }), pairingTopic: R3, transportType: r5 }), { uri: Se3 ?? V4, response: mt3 };
    }, this.approveSessionAuthenticate = async (e4) => {
      const { id: t3, auths: s5 } = e4, i5 = this.client.core.eventClient.createEvent({ properties: { topic: t3.toString(), trace: [As2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y7) {
        throw i5.setError(Ns2.no_internet_connection), y7;
      }
      const r5 = this.getPendingAuthRequest(t3);
      if (!r5)
        throw i5.setError(Ns2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t3}`);
      const n6 = r5.transportType || M6.relay;
      n6 === M6.relay && await this.confirmOnlineStateOrThrow();
      const a4 = r5.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h7 = oi(a4), p5 = { type: Ie2, receiverPublicKey: a4, senderPublicKey: c5 }, d6 = [], l6 = [];
      for (const y7 of s5) {
        if (!await Yo2({ cacao: y7, projectId: this.client.core.projectId })) {
          i5.setError(Ns2.invalid_cacao);
          const S4 = de2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t3, topic: h7, error: S4, encodeOpts: p5 }), new Error(S4.message);
        }
        i5.addTrace(As2.cacaos_verified);
        const { p: _7 } = y7, R3 = Me2(_7.resources), V4 = [On2(_7.iss)], E7 = ut2(_7.iss);
        if (R3) {
          const S4 = rs(R3), M7 = os(R3);
          d6.push(...S4), V4.push(...M7);
        }
        for (const S4 of V4)
          l6.push(`${S4}:${E7}`);
      }
      const w6 = await this.client.core.crypto.generateSharedKey(c5, a4);
      i5.addTrace(As2.create_authenticated_session_topic);
      let m4;
      if (d6?.length > 0) {
        m4 = { topic: w6, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a4, metadata: r5.requester.metadata }, controller: a4, expiry: ho2(H5), authentication: s5, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r5.pairingTopic, namespaces: Ti([...new Set(d6)], [...new Set(l6)]), transportType: n6 }, i5.addTrace(As2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w6, { transportType: n6 });
        } catch (y7) {
          throw i5.setError(Ns2.subscribe_authenticated_session_topic_failure), y7;
        }
        i5.addTrace(As2.subscribe_authenticated_session_topic_success), await this.client.session.set(w6, m4), i5.addTrace(As2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r5.pairingTopic, metadata: r5.requester.metadata });
      }
      i5.addTrace(As2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h7, id: t3, result: { cacaos: s5, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p5, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r5.requester.metadata, n6) });
      } catch (y7) {
        throw i5.setError(Ns2.authenticated_session_approve_publish_failure), y7;
      }
      return await this.client.auth.requests.delete(t3, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r5.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i5.eventId }), { session: m4 };
    }, this.rejectSessionAuthenticate = async (e4) => {
      this.isInitialized();
      const { id: t3, reason: s5 } = e4, i5 = this.getPendingAuthRequest(t3);
      if (!i5)
        throw new Error(`Could not find pending auth request with id ${t3}`);
      i5.transportType === M6.relay && await this.confirmOnlineStateOrThrow();
      const r5 = i5.requester.publicKey, n6 = await this.client.core.crypto.generateKeyPair(), a4 = oi(r5), c5 = { type: Ie2, receiverPublicKey: r5, senderPublicKey: n6 };
      await this.sendError({ id: t3, topic: a4, error: s5, encodeOpts: c5, rpcOpts: v7.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i5.requester.metadata, i5.transportType) }), await this.client.auth.requests.delete(t3, { message: "rejected", code: 0 }), await this.client.proposal.delete(t3, de2("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e4) => {
      this.isInitialized();
      const { request: t3, iss: s5 } = e4;
      return In2(t3, s5);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0)
          for (; this.relayMessageCache.length > 0; )
            try {
              const e4 = this.relayMessageCache.shift();
              e4 && await this.onRelayMessage(e4);
            } catch (e4) {
              this.client.logger.error(e4);
            }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e4) => {
      if (e4.pairingTopic)
        try {
          const t3 = this.client.core.pairing.pairings.get(e4.pairingTopic), s5 = this.client.core.pairing.pairings.getAll().filter((i5) => {
            var r5, n6;
            return ((r5 = i5.peerMetadata) == null ? void 0 : r5.url) && ((n6 = i5.peerMetadata) == null ? void 0 : n6.url) === e4.peer.metadata.url && i5.topic && i5.topic !== t3.topic;
          });
          if (s5.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${s5.length} duplicate pairing(s)`), await Promise.all(s5.map((i5) => this.client.core.pairing.disconnect({ topic: i5.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (t3) {
          this.client.logger.error(t3);
        }
    }, this.deleteSession = async (e4) => {
      var t3;
      const { topic: s5, expirerHasDeleted: i5 = false, emitEvent: r5 = true, id: n6 = 0 } = e4, { self: a4 } = this.client.session.get(s5);
      await this.client.core.relayer.unsubscribe(s5), await this.client.session.delete(s5, de2("USER_DISCONNECTED")), this.addToRecentlyDeleted(s5, "session"), this.client.core.crypto.keychain.has(a4.publicKey) && await this.client.core.crypto.deleteKeyPair(a4.publicKey), this.client.core.crypto.keychain.has(s5) && await this.client.core.crypto.deleteSymKey(s5), i5 || this.client.core.expirer.del(s5), this.client.core.storage.removeItem(De4).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s5 && this.deletePendingSessionRequest(c5.id, de2("USER_DISCONNECTED"));
      }), s5 === ((t3 = this.sessionRequestQueue.queue[0]) == null ? void 0 : t3.topic) && (this.sessionRequestQueue.state = L4.idle), r5 && this.client.events.emit("session_delete", { id: n6, topic: s5 });
    }, this.deleteProposal = async (e4, t3) => {
      if (t3)
        try {
          const s5 = this.client.proposal.get(e4), i5 = this.client.core.eventClient.getEvent({ topic: s5.pairingTopic });
          i5?.setError(Os2.proposal_expired);
        } catch {
        }
      await Promise.all([this.client.proposal.delete(e4, de2("USER_DISCONNECTED")), t3 ? Promise.resolve() : this.client.core.expirer.del(e4)]), this.addToRecentlyDeleted(e4, "proposal");
    }, this.deletePendingSessionRequest = async (e4, t3, s5 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e4, t3), s5 ? Promise.resolve() : this.client.core.expirer.del(e4)]), this.addToRecentlyDeleted(e4, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i5) => i5.id !== e4), s5 && (this.sessionRequestQueue.state = L4.idle, this.client.events.emit("session_request_expire", { id: e4 }));
    }, this.deletePendingAuthRequest = async (e4, t3, s5 = false) => {
      await Promise.all([this.client.auth.requests.delete(e4, t3), s5 ? Promise.resolve() : this.client.core.expirer.del(e4)]);
    }, this.setExpiry = async (e4, t3) => {
      this.client.session.keys.includes(e4) && (this.client.core.expirer.set(e4, t3), await this.client.session.update(e4, { expiry: t3 }));
    }, this.setProposal = async (e4, t3) => {
      this.client.core.expirer.set(e4, ho2(v7.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e4, t3);
    }, this.setAuthRequest = async (e4, t3) => {
      const { request: s5, pairingTopic: i5, transportType: r5 = M6.relay } = t3;
      this.client.core.expirer.set(e4, s5.expiryTimestamp), await this.client.auth.requests.set(e4, { authPayload: s5.authPayload, requester: s5.requester, expiryTimestamp: s5.expiryTimestamp, id: e4, pairingTopic: i5, verifyContext: s5.verifyContext, transportType: r5 });
    }, this.setPendingSessionRequest = async (e4) => {
      const { id: t3, topic: s5, params: i5, verifyContext: r5 } = e4, n6 = i5.request.expiryTimestamp || ho2(v7.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t3, n6), await this.client.pendingRequest.set(t3, { id: t3, topic: s5, params: i5, verifyContext: r5 });
    }, this.sendRequest = async (e4) => {
      const { topic: t3, method: s5, params: i5, expiry: r5, relayRpcId: n6, clientRpcId: a4, throwOnFailedPublish: c5, appLink: h7 } = e4, p5 = formatJsonRpcRequest(s5, i5, a4);
      let d6;
      const l6 = !!h7;
      try {
        const y7 = l6 ? Qs : At;
        d6 = await this.client.core.crypto.encode(t3, p5, { encoding: y7 });
      } catch (y7) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t3} failed`), y7;
      }
      let w6;
      if (ct4.includes(s5)) {
        const y7 = si(JSON.stringify(p5)), _7 = si(d6);
        w6 = await this.client.core.verify.register({ id: _7, decryptedId: y7 });
      }
      const m4 = v7[s5].req;
      if (m4.attestation = w6, r5 && (m4.ttl = r5), n6 && (m4.id = n6), this.client.core.history.set(t3, p5), l6) {
        const y7 = Ei(h7, t3, d6);
        await globalThis.Linking.openURL(y7, this.client.name);
      } else {
        const y7 = v7[s5].req;
        r5 && (y7.ttl = r5), n6 && (y7.id = n6), c5 ? (y7.internal = D4(I4({}, y7.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t3, d6, y7)) : this.client.core.relayer.publish(t3, d6, y7).catch((_7) => this.client.logger.error(_7));
      }
      return p5.id;
    }, this.sendResult = async (e4) => {
      const { id: t3, topic: s5, result: i5, throwOnFailedPublish: r5, encodeOpts: n6, appLink: a4 } = e4, c5 = formatJsonRpcResult(t3, i5);
      let h7;
      const p5 = a4 && typeof (globalThis == null ? void 0 : globalThis.Linking) < "u";
      try {
        const l6 = p5 ? Qs : At;
        h7 = await this.client.core.crypto.encode(s5, c5, D4(I4({}, n6 || {}), { encoding: l6 }));
      } catch (l6) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s5} failed`), l6;
      }
      let d6;
      try {
        d6 = await this.client.core.history.get(s5, t3);
      } catch (l6) {
        throw this.client.logger.error(`sendResult() -> history.get(${s5}, ${t3}) failed`), l6;
      }
      if (p5) {
        const l6 = Ei(a4, s5, h7);
        await globalThis.Linking.openURL(l6, this.client.name);
      } else {
        const l6 = v7[d6.request.method].res;
        r5 ? (l6.internal = D4(I4({}, l6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s5, h7, l6)) : this.client.core.relayer.publish(s5, h7, l6).catch((w6) => this.client.logger.error(w6));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e4) => {
      const { id: t3, topic: s5, error: i5, encodeOpts: r5, rpcOpts: n6, appLink: a4 } = e4, c5 = formatJsonRpcError(t3, i5);
      let h7;
      const p5 = a4 && typeof (globalThis == null ? void 0 : globalThis.Linking) < "u";
      try {
        const l6 = p5 ? Qs : At;
        h7 = await this.client.core.crypto.encode(s5, c5, D4(I4({}, r5 || {}), { encoding: l6 }));
      } catch (l6) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s5} failed`), l6;
      }
      let d6;
      try {
        d6 = await this.client.core.history.get(s5, t3);
      } catch (l6) {
        throw this.client.logger.error(`sendError() -> history.get(${s5}, ${t3}) failed`), l6;
      }
      if (p5) {
        const l6 = Ei(a4, s5, h7);
        await globalThis.Linking.openURL(l6, this.client.name);
      } else {
        const l6 = n6 || v7[d6.request.method].res;
        this.client.core.relayer.publish(s5, h7, l6);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e4 = [], t3 = [];
      this.client.session.getAll().forEach((s5) => {
        let i5 = false;
        po2(s5.expiry) && (i5 = true), this.client.core.crypto.keychain.has(s5.topic) || (i5 = true), i5 && e4.push(s5.topic);
      }), this.client.proposal.getAll().forEach((s5) => {
        po2(s5.expiryTimestamp) && t3.push(s5.id);
      }), await Promise.all([...e4.map((s5) => this.deleteSession({ topic: s5 })), ...t3.map((s5) => this.deleteProposal(s5))]);
    }, this.onRelayEventRequest = async (e4) => {
      this.requestQueue.queue.push(e4), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === L4.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = L4.active;
        const e4 = this.requestQueue.queue.shift();
        if (e4)
          try {
            await this.processRequest(e4);
          } catch (t3) {
            this.client.logger.warn(t3);
          }
      }
      this.requestQueue.state = L4.idle;
    }, this.processRequest = async (e4) => {
      const { topic: t3, payload: s5, attestation: i5, transportType: r5, encryptedId: n6 } = e4, a4 = s5.method;
      if (!this.shouldIgnorePairingRequest({ topic: t3, requestMethod: a4 }))
        switch (a4) {
          case "wc_sessionPropose":
            return await this.onSessionProposeRequest({ topic: t3, payload: s5, attestation: i5, encryptedId: n6 });
          case "wc_sessionSettle":
            return await this.onSessionSettleRequest(t3, s5);
          case "wc_sessionUpdate":
            return await this.onSessionUpdateRequest(t3, s5);
          case "wc_sessionExtend":
            return await this.onSessionExtendRequest(t3, s5);
          case "wc_sessionPing":
            return await this.onSessionPingRequest(t3, s5);
          case "wc_sessionDelete":
            return await this.onSessionDeleteRequest(t3, s5);
          case "wc_sessionRequest":
            return await this.onSessionRequest({ topic: t3, payload: s5, attestation: i5, encryptedId: n6, transportType: r5 });
          case "wc_sessionEvent":
            return await this.onSessionEventRequest(t3, s5);
          case "wc_sessionAuthenticate":
            return await this.onSessionAuthenticateRequest({ topic: t3, payload: s5, attestation: i5, encryptedId: n6, transportType: r5 });
          default:
            return this.client.logger.info(`Unsupported request method ${a4}`);
        }
    }, this.onRelayEventResponse = async (e4) => {
      const { topic: t3, payload: s5, transportType: i5 } = e4, r5 = (await this.client.core.history.get(t3, s5.id)).request.method;
      switch (r5) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t3, s5, i5);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t3, s5);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t3, s5);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t3, s5);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t3, s5);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t3, s5);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t3, s5);
        default:
          return this.client.logger.info(`Unsupported response method ${r5}`);
      }
    }, this.onRelayEventUnknownPayload = (e4) => {
      const { topic: t3 } = e4, { message: s5 } = te2("MISSING_OR_INVALID", `Decoded payload on topic ${t3} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s5);
    }, this.shouldIgnorePairingRequest = (e4) => {
      const { topic: t3, requestMethod: s5 } = e4, i5 = this.expectedPairingMethodMap.get(t3);
      return !i5 || i5.includes(s5) ? false : !!(i5.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e4) => {
      const { topic: t3, payload: s5, attestation: i5, encryptedId: r5 } = e4, { params: n6, id: a4 } = s5;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t3 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5?.setError($3.proposal_listener_not_found)), this.isValidConnect(I4({}, s5.params));
        const h7 = n6.expiryTimestamp || ho2(v7.wc_sessionPropose.req.ttl), p5 = I4({ id: a4, pairingTopic: t3, expiryTimestamp: h7 }, n6);
        await this.setProposal(a4, p5);
        const d6 = await this.getVerifyContext({ attestationId: i5, hash: si(JSON.stringify(s5)), encryptedId: r5, metadata: p5.proposer.metadata });
        c5?.addTrace(z6.emit_session_proposal), this.client.events.emit("session_proposal", { id: a4, params: p5, verifyContext: d6 });
      } catch (c5) {
        await this.sendError({ id: a4, topic: t3, error: c5, rpcOpts: v7.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e4, t3, s5) => {
      const { id: i5 } = t3;
      if (isJsonRpcResult(t3)) {
        const { result: r5 } = t3;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r5 });
        const n6 = this.client.proposal.get(i5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n6 });
        const a4 = n6.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a4 });
        const c5 = r5.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h7 = await this.client.core.crypto.generateSharedKey(a4, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h7 });
        const p5 = await this.client.core.relayer.subscribe(h7, { transportType: s5 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p5 }), await this.client.core.pairing.activate({ topic: e4 });
      } else if (isJsonRpcError(t3)) {
        await this.client.proposal.delete(i5, de2("USER_DISCONNECTED"));
        const r5 = go2("session_connect");
        if (this.events.listenerCount(r5) === 0)
          throw new Error(`emitting ${r5} without any listeners, 954`);
        this.events.emit(go2("session_connect"), { error: t3.error });
      }
    }, this.onSessionSettleRequest = async (e4, t3) => {
      const { id: s5, params: i5 } = t3;
      try {
        this.isValidSessionSettleRequest(i5);
        const { relay: r5, controller: n6, expiry: a4, namespaces: c5, sessionProperties: h7, sessionConfig: p5 } = t3.params, d6 = D4(I4(I4({ topic: e4, relay: r5, expiry: a4, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n6.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n6.publicKey, metadata: n6.metadata } }, h7 && { sessionProperties: h7 }), p5 && { sessionConfig: p5 }), { transportType: M6.relay }), l6 = go2("session_connect");
        if (this.events.listenerCount(l6) === 0)
          throw new Error(`emitting ${l6} without any listeners 997`);
        this.events.emit(go2("session_connect"), { session: d6 }), await this.sendResult({ id: t3.id, topic: e4, result: true, throwOnFailedPublish: true });
      } catch (r5) {
        await this.sendError({ id: s5, topic: e4, error: r5 }), this.client.logger.error(r5);
      }
    }, this.onSessionSettleResponse = async (e4, t3) => {
      const { id: s5 } = t3;
      isJsonRpcResult(t3) ? (await this.client.session.update(e4, { acknowledged: true }), this.events.emit(go2("session_approve", s5), {})) : isJsonRpcError(t3) && (await this.client.session.delete(e4, de2("USER_DISCONNECTED")), this.events.emit(go2("session_approve", s5), { error: t3.error }));
    }, this.onSessionUpdateRequest = async (e4, t3) => {
      const { params: s5, id: i5 } = t3;
      try {
        const r5 = `${e4}_session_update`, n6 = Zi.get(r5);
        if (n6 && this.isRequestOutOfSync(n6, i5)) {
          this.client.logger.warn(`Discarding out of sync request - ${i5}`), this.sendError({ id: i5, topic: e4, error: de2("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I4({ topic: e4 }, s5));
        try {
          Zi.set(r5, i5), await this.client.session.update(e4, { namespaces: s5.namespaces }), await this.sendResult({ id: i5, topic: e4, result: true, throwOnFailedPublish: true });
        } catch (a4) {
          throw Zi.delete(r5), a4;
        }
        this.client.events.emit("session_update", { id: i5, topic: e4, params: s5 });
      } catch (r5) {
        await this.sendError({ id: i5, topic: e4, error: r5 }), this.client.logger.error(r5);
      }
    }, this.isRequestOutOfSync = (e4, t3) => t3.toString().slice(0, -3) < e4.toString().slice(0, -3), this.onSessionUpdateResponse = (e4, t3) => {
      const { id: s5 } = t3, i5 = go2("session_update", s5);
      if (this.events.listenerCount(i5) === 0)
        throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t3) ? this.events.emit(go2("session_update", s5), {}) : isJsonRpcError(t3) && this.events.emit(go2("session_update", s5), { error: t3.error });
    }, this.onSessionExtendRequest = async (e4, t3) => {
      const { id: s5 } = t3;
      try {
        this.isValidExtend({ topic: e4 }), await this.setExpiry(e4, ho2(H5)), await this.sendResult({ id: s5, topic: e4, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s5, topic: e4 });
      } catch (i5) {
        await this.sendError({ id: s5, topic: e4, error: i5 }), this.client.logger.error(i5);
      }
    }, this.onSessionExtendResponse = (e4, t3) => {
      const { id: s5 } = t3, i5 = go2("session_extend", s5);
      if (this.events.listenerCount(i5) === 0)
        throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t3) ? this.events.emit(go2("session_extend", s5), {}) : isJsonRpcError(t3) && this.events.emit(go2("session_extend", s5), { error: t3.error });
    }, this.onSessionPingRequest = async (e4, t3) => {
      const { id: s5 } = t3;
      try {
        this.isValidPing({ topic: e4 }), await this.sendResult({ id: s5, topic: e4, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s5, topic: e4 });
      } catch (i5) {
        await this.sendError({ id: s5, topic: e4, error: i5 }), this.client.logger.error(i5);
      }
    }, this.onSessionPingResponse = (e4, t3) => {
      const { id: s5 } = t3, i5 = go2("session_ping", s5);
      if (this.events.listenerCount(i5) === 0)
        throw new Error(`emitting ${i5} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t3) ? this.events.emit(go2("session_ping", s5), {}) : isJsonRpcError(t3) && this.events.emit(go2("session_ping", s5), { error: t3.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e4, t3) => {
      const { id: s5 } = t3;
      try {
        this.isValidDisconnect({ topic: e4, reason: t3.params }), Promise.all([new Promise((i5) => {
          this.client.core.relayer.once(v6.publish, async () => {
            i5(await this.deleteSession({ topic: e4, id: s5 }));
          });
        }), this.sendResult({ id: s5, topic: e4, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e4, error: de2("USER_DISCONNECTED") })]).catch((i5) => this.client.logger.error(i5));
      } catch (i5) {
        this.client.logger.error(i5);
      }
    }, this.onSessionRequest = async (e4) => {
      var t3, s5, i5;
      const { topic: r5, payload: n6, attestation: a4, encryptedId: c5, transportType: h7 } = e4, { id: p5, params: d6 } = n6;
      try {
        await this.isValidRequest(I4({ topic: r5 }, d6));
        const l6 = this.client.session.get(r5), w6 = await this.getVerifyContext({ attestationId: a4, hash: si(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d6, p5))), encryptedId: c5, metadata: l6.peer.metadata, transportType: h7 }), m4 = { id: p5, topic: r5, params: d6, verifyContext: w6 };
        await this.setPendingSessionRequest(m4), h7 === M6.link_mode && (t3 = l6.peer.metadata.redirect) != null && t3.universal && this.client.core.addLinkModeSupportedApp((s5 = l6.peer.metadata.redirect) == null ? void 0 : s5.universal), (i5 = this.client.signConfig) != null && i5.disableRequestQueue ? this.emitSessionRequest(m4) : (this.addSessionRequestToSessionRequestQueue(m4), this.processSessionRequestQueue());
      } catch (l6) {
        await this.sendError({ id: p5, topic: r5, error: l6 }), this.client.logger.error(l6);
      }
    }, this.onSessionRequestResponse = (e4, t3) => {
      const { id: s5 } = t3, i5 = go2("session_request", s5);
      if (this.events.listenerCount(i5) === 0)
        throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t3) ? this.events.emit(go2("session_request", s5), { result: t3.result }) : isJsonRpcError(t3) && this.events.emit(go2("session_request", s5), { error: t3.error });
    }, this.onSessionEventRequest = async (e4, t3) => {
      const { id: s5, params: i5 } = t3;
      try {
        const r5 = `${e4}_session_event_${i5.event.name}`, n6 = Zi.get(r5);
        if (n6 && this.isRequestOutOfSync(n6, s5)) {
          this.client.logger.info(`Discarding out of sync request - ${s5}`);
          return;
        }
        this.isValidEmit(I4({ topic: e4 }, i5)), this.client.events.emit("session_event", { id: s5, topic: e4, params: i5 }), Zi.set(r5, s5);
      } catch (r5) {
        await this.sendError({ id: s5, topic: e4, error: r5 }), this.client.logger.error(r5);
      }
    }, this.onSessionAuthenticateResponse = (e4, t3) => {
      const { id: s5 } = t3;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e4, payload: t3 }), isJsonRpcResult(t3) ? this.events.emit(go2("session_request", s5), { result: t3.result }) : isJsonRpcError(t3) && this.events.emit(go2("session_request", s5), { error: t3.error });
    }, this.onSessionAuthenticateRequest = async (e4) => {
      var t3;
      const { topic: s5, payload: i5, attestation: r5, encryptedId: n6, transportType: a4 } = e4;
      try {
        const { requester: c5, authPayload: h7, expiryTimestamp: p5 } = i5.params, d6 = await this.getVerifyContext({ attestationId: r5, hash: si(JSON.stringify(i5)), encryptedId: n6, metadata: c5.metadata, transportType: a4 }), l6 = { requester: c5, pairingTopic: s5, id: i5.id, authPayload: h7, verifyContext: d6, expiryTimestamp: p5 };
        await this.setAuthRequest(i5.id, { request: l6, pairingTopic: s5, transportType: a4 }), a4 === M6.link_mode && (t3 = c5.metadata.redirect) != null && t3.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s5, params: i5.params, id: i5.id, verifyContext: d6 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h7 = i5.params.requester.publicKey, p5 = await this.client.core.crypto.generateKeyPair(), d6 = this.getAppLinkIfEnabled(i5.params.requester.metadata, a4), l6 = { type: Ie2, receiverPublicKey: h7, senderPublicKey: p5 };
        await this.sendError({ id: i5.id, topic: s5, error: c5, encodeOpts: l6, rpcOpts: v7.wc_sessionAuthenticate.autoReject, appLink: d6 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e4) => {
      this.sessionRequestQueue.queue.push(e4);
    }, this.cleanupAfterResponse = (e4) => {
      this.deletePendingSessionRequest(e4.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = L4.idle, this.processSessionRequestQueue();
      }, (0, import_time5.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e4, error: t3 }) => {
      const s5 = this.client.core.history.pending;
      s5.length > 0 && s5.filter((i5) => i5.topic === e4 && i5.request.method === "wc_sessionRequest").forEach((i5) => {
        const r5 = i5.request.id, n6 = go2("session_request", r5);
        if (this.events.listenerCount(n6) === 0)
          throw new Error(`emitting ${n6} without any listeners`);
        this.events.emit(go2("session_request", i5.request.id), { error: t3 });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === L4.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e4 = this.sessionRequestQueue.queue[0];
      if (!e4) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = L4.active, this.emitSessionRequest(e4);
      } catch (t3) {
        this.client.logger.error(t3);
      }
    }, this.emitSessionRequest = (e4) => {
      this.client.events.emit("session_request", e4);
    }, this.onPairingCreated = (e4) => {
      if (e4.methods && this.expectedPairingMethodMap.set(e4.topic, e4.methods), e4.active)
        return;
      const t3 = this.client.proposal.getAll().find((s5) => s5.pairingTopic === e4.topic);
      t3 && this.onSessionProposeRequest({ topic: e4.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t3.requiredNamespaces, optionalNamespaces: t3.optionalNamespaces, relays: t3.relays, proposer: t3.proposer, sessionProperties: t3.sessionProperties }, t3.id) });
    }, this.isValidConnect = async (e4) => {
      if (!Di(e4)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e4)}`);
        throw new Error(a4);
      }
      const { pairingTopic: t3, requiredNamespaces: s5, optionalNamespaces: i5, sessionProperties: r5, relays: n6 } = e4;
      if (ae(t3) || await this.isValidPairingTopic(t3), !Ci(n6, true)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `connect() relays: ${n6}`);
        throw new Error(a4);
      }
      !ae(s5) && qe2(s5) !== 0 && this.validateNamespaces(s5, "requiredNamespaces"), !ae(i5) && qe2(i5) !== 0 && this.validateNamespaces(i5, "optionalNamespaces"), ae(r5) || this.validateSessionProps(r5, "sessionProperties");
    }, this.validateNamespaces = (e4, t3) => {
      const s5 = ji(e4, "connect()", t3);
      if (s5)
        throw new Error(s5.message);
    }, this.isValidApprove = async (e4) => {
      if (!Di(e4))
        throw new Error(te2("MISSING_OR_INVALID", `approve() params: ${e4}`).message);
      const { id: t3, namespaces: s5, relayProtocol: i5, sessionProperties: r5 } = e4;
      this.checkRecentlyDeleted(t3), await this.isValidProposalId(t3);
      const n6 = this.client.proposal.get(t3), a4 = Ir2(s5, "approve()");
      if (a4)
        throw new Error(a4.message);
      const c5 = Nr2(n6.requiredNamespaces, s5, "approve()");
      if (c5)
        throw new Error(c5.message);
      if (!q3(i5, true)) {
        const { message: h7 } = te2("MISSING_OR_INVALID", `approve() relayProtocol: ${i5}`);
        throw new Error(h7);
      }
      ae(r5) || this.validateSessionProps(r5, "sessionProperties");
    }, this.isValidReject = async (e4) => {
      if (!Di(e4)) {
        const { message: i5 } = te2("MISSING_OR_INVALID", `reject() params: ${e4}`);
        throw new Error(i5);
      }
      const { id: t3, reason: s5 } = e4;
      if (this.checkRecentlyDeleted(t3), await this.isValidProposalId(t3), !Mi(s5)) {
        const { message: i5 } = te2("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s5)}`);
        throw new Error(i5);
      }
    }, this.isValidSessionSettleRequest = (e4) => {
      if (!Di(e4)) {
        const { message: c5 } = te2("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e4}`);
        throw new Error(c5);
      }
      const { relay: t3, controller: s5, namespaces: i5, expiry: r5 } = e4;
      if (!Ar2(t3)) {
        const { message: c5 } = te2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n6 = Bi(s5, "onSessionSettleRequest()");
      if (n6)
        throw new Error(n6.message);
      const a4 = Ir2(i5, "onSessionSettleRequest()");
      if (a4)
        throw new Error(a4.message);
      if (po2(r5)) {
        const { message: c5 } = te2("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e4) => {
      if (!Di(e4)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `update() params: ${e4}`);
        throw new Error(a4);
      }
      const { topic: t3, namespaces: s5 } = e4;
      this.checkRecentlyDeleted(t3), await this.isValidSessionTopic(t3);
      const i5 = this.client.session.get(t3), r5 = Ir2(s5, "update()");
      if (r5)
        throw new Error(r5.message);
      const n6 = Nr2(i5.requiredNamespaces, s5, "update()");
      if (n6)
        throw new Error(n6.message);
    }, this.isValidExtend = async (e4) => {
      if (!Di(e4)) {
        const { message: s5 } = te2("MISSING_OR_INVALID", `extend() params: ${e4}`);
        throw new Error(s5);
      }
      const { topic: t3 } = e4;
      this.checkRecentlyDeleted(t3), await this.isValidSessionTopic(t3);
    }, this.isValidRequest = async (e4) => {
      if (!Di(e4)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `request() params: ${e4}`);
        throw new Error(a4);
      }
      const { topic: t3, request: s5, chainId: i5, expiry: r5 } = e4;
      this.checkRecentlyDeleted(t3), await this.isValidSessionTopic(t3);
      const { namespaces: n6 } = this.client.session.get(t3);
      if (!Fi(n6, i5)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `request() chainId: ${i5}`);
        throw new Error(a4);
      }
      if (!Vi(s5)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `request() ${JSON.stringify(s5)}`);
        throw new Error(a4);
      }
      if (!qi(n6, i5, s5.method)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `request() method: ${s5.method}`);
        throw new Error(a4);
      }
      if (r5 && !Ji(r5, me4)) {
        const { message: a4 } = te2("MISSING_OR_INVALID", `request() expiry: ${r5}. Expiry must be a number (in seconds) between ${me4.min} and ${me4.max}`);
        throw new Error(a4);
      }
    }, this.isValidRespond = async (e4) => {
      var t3;
      if (!Di(e4)) {
        const { message: r5 } = te2("MISSING_OR_INVALID", `respond() params: ${e4}`);
        throw new Error(r5);
      }
      const { topic: s5, response: i5 } = e4;
      try {
        await this.isValidSessionTopic(s5);
      } catch (r5) {
        throw (t3 = e4?.response) != null && t3.id && this.cleanupAfterResponse(e4), r5;
      }
      if (!Hi(i5)) {
        const { message: r5 } = te2("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i5)}`);
        throw new Error(r5);
      }
    }, this.isValidPing = async (e4) => {
      if (!Di(e4)) {
        const { message: s5 } = te2("MISSING_OR_INVALID", `ping() params: ${e4}`);
        throw new Error(s5);
      }
      const { topic: t3 } = e4;
      await this.isValidSessionOrPairingTopic(t3);
    }, this.isValidEmit = async (e4) => {
      if (!Di(e4)) {
        const { message: n6 } = te2("MISSING_OR_INVALID", `emit() params: ${e4}`);
        throw new Error(n6);
      }
      const { topic: t3, event: s5, chainId: i5 } = e4;
      await this.isValidSessionTopic(t3);
      const { namespaces: r5 } = this.client.session.get(t3);
      if (!Fi(r5, i5)) {
        const { message: n6 } = te2("MISSING_OR_INVALID", `emit() chainId: ${i5}`);
        throw new Error(n6);
      }
      if (!Ki(s5)) {
        const { message: n6 } = te2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s5)}`);
        throw new Error(n6);
      }
      if (!Gi(r5, i5, s5.name)) {
        const { message: n6 } = te2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s5)}`);
        throw new Error(n6);
      }
    }, this.isValidDisconnect = async (e4) => {
      if (!Di(e4)) {
        const { message: s5 } = te2("MISSING_OR_INVALID", `disconnect() params: ${e4}`);
        throw new Error(s5);
      }
      const { topic: t3 } = e4;
      await this.isValidSessionOrPairingTopic(t3);
    }, this.isValidAuthenticate = (e4) => {
      const { chains: t3, uri: s5, domain: i5, nonce: r5 } = e4;
      if (!Array.isArray(t3) || t3.length === 0)
        throw new Error("chains is required and must be a non-empty array");
      if (!q3(s5, false))
        throw new Error("uri is required parameter");
      if (!q3(i5, false))
        throw new Error("domain is required parameter");
      if (!q3(r5, false))
        throw new Error("nonce is required parameter");
      if ([...new Set(t3.map((a4) => Ye2(a4).namespace))].length > 1)
        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n6 } = Ye2(t3[0]);
      if (n6 !== "eip155")
        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e4) => {
      const { attestationId: t3, hash: s5, encryptedId: i5, metadata: r5, transportType: n6 } = e4, a4 = { verified: { verifyUrl: r5.verifyUrl || X2, validation: "UNKNOWN", origin: r5.url || "" } };
      try {
        if (n6 === M6.link_mode) {
          const h7 = this.getAppLinkIfEnabled(r5, n6);
          return a4.verified.validation = h7 && new URL(h7).origin === new URL(r5.url).origin ? "VALID" : "INVALID", a4;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t3, hash: s5, encryptedId: i5, verifyUrl: r5.verifyUrl });
        c5 && (a4.verified.origin = c5.origin, a4.verified.isScam = c5.isScam, a4.verified.validation = c5.origin === new URL(r5.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a4)}`), a4;
    }, this.validateSessionProps = (e4, t3) => {
      Object.values(e4).forEach((s5) => {
        if (!q3(s5, false)) {
          const { message: i5 } = te2("MISSING_OR_INVALID", `${t3} must be in Record<string, string> format. Received: ${JSON.stringify(s5)}`);
          throw new Error(i5);
        }
      });
    }, this.getPendingAuthRequest = (e4) => {
      const t3 = this.client.auth.requests.get(e4);
      return typeof t3 == "object" ? t3 : void 0;
    }, this.addToRecentlyDeleted = (e4, t3) => {
      if (this.recentlyDeletedMap.set(e4, t3), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s5 = 0;
        const i5 = this.recentlyDeletedLimit / 2;
        for (const r5 of this.recentlyDeletedMap.keys()) {
          if (s5++ >= i5)
            break;
          this.recentlyDeletedMap.delete(r5);
        }
      }
    }, this.checkRecentlyDeleted = (e4) => {
      const t3 = this.recentlyDeletedMap.get(e4);
      if (t3) {
        const { message: s5 } = te2("MISSING_OR_INVALID", `Record was recently deleted - ${t3}: ${e4}`);
        throw new Error(s5);
      }
    }, this.isLinkModeEnabled = (e4, t3) => {
      var s5, i5, r5, n6, a4, c5, h7, p5, d6;
      return !e4 || t3 !== M6.link_mode ? false : ((i5 = (s5 = this.client.metadata) == null ? void 0 : s5.redirect) == null ? void 0 : i5.linkMode) === true && ((n6 = (r5 = this.client.metadata) == null ? void 0 : r5.redirect) == null ? void 0 : n6.universal) !== void 0 && ((c5 = (a4 = this.client.metadata) == null ? void 0 : a4.redirect) == null ? void 0 : c5.universal) !== "" && ((h7 = e4?.redirect) == null ? void 0 : h7.universal) !== void 0 && ((p5 = e4?.redirect) == null ? void 0 : p5.universal) !== "" && ((d6 = e4?.redirect) == null ? void 0 : d6.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e4.redirect.universal) && typeof (globalThis == null ? void 0 : globalThis.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e4, t3) => {
      var s5;
      return this.isLinkModeEnabled(e4, t3) ? (s5 = e4?.redirect) == null ? void 0 : s5.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e4 }) => {
      if (!e4 || !e4.includes("wc_ev") || !e4.includes("topic"))
        return;
      const t3 = bo2(e4, "topic") || "", s5 = decodeURIComponent(bo2(e4, "wc_ev") || ""), i5 = this.client.session.keys.includes(t3);
      i5 && this.client.session.update(t3, { transportType: M6.link_mode }), this.client.core.dispatchEnvelope({ topic: t3, message: s5, sessionExists: i5 });
    }, this.registerLinkModeListeners = async () => {
      var e4;
      if (Eo2() || ne() && (e4 = this.client.metadata.redirect) != null && e4.linkMode) {
        const t3 = globalThis == null ? void 0 : globalThis.Linking;
        if (typeof t3 < "u") {
          t3.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s5 = await t3.getInitialURL();
          s5 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s5 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o6 } = te2("NOT_INITIALIZED", this.name);
      throw new Error(o6);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(v6.message, (o6) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o6) : this.onRelayMessage(o6);
    });
  }
  async onRelayMessage(o6) {
    const { topic: e4, message: t3, attestation: s5, transportType: i5 } = o6, { publicKey: r5 } = this.client.auth.authKeys.keys.includes(ae3) ? this.client.auth.authKeys.get(ae3) : { responseTopic: void 0, publicKey: void 0 }, n6 = await this.client.core.crypto.decode(e4, t3, { receiverPublicKey: r5, encoding: i5 === M6.link_mode ? Qs : At });
    try {
      isJsonRpcRequest(n6) ? (this.client.core.history.set(e4, n6), this.onRelayEventRequest({ topic: e4, payload: n6, attestation: s5, transportType: i5, encryptedId: si(t3) })) : isJsonRpcResponse(n6) ? (await this.client.core.history.resolve(n6), await this.onRelayEventResponse({ topic: e4, payload: n6, transportType: i5 }), this.client.core.history.delete(e4, n6.id)) : this.onRelayEventUnknownPayload({ topic: e4, payload: n6, transportType: i5 });
    } catch (a4) {
      this.client.logger.error(a4);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(x8.expired, async (o6) => {
      const { topic: e4, id: t3 } = lo2(o6.target);
      if (t3 && this.client.pendingRequest.keys.includes(t3))
        return await this.deletePendingSessionRequest(t3, te2("EXPIRED"), true);
      if (t3 && this.client.auth.requests.keys.includes(t3))
        return await this.deletePendingAuthRequest(t3, te2("EXPIRED"), true);
      e4 ? this.client.session.keys.includes(e4) && (await this.deleteSession({ topic: e4, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e4 })) : t3 && (await this.deleteProposal(t3, true), this.client.events.emit("proposal_expire", { id: t3 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(j5.create, (o6) => this.onPairingCreated(o6)), this.client.core.pairing.events.on(j5.delete, (o6) => {
      this.addToRecentlyDeleted(o6.topic, "pairing");
    });
  }
  isValidPairingTopic(o6) {
    if (!q3(o6, false)) {
      const { message: e4 } = te2("MISSING_OR_INVALID", `pairing topic should be a string: ${o6}`);
      throw new Error(e4);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o6)) {
      const { message: e4 } = te2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o6}`);
      throw new Error(e4);
    }
    if (po2(this.client.core.pairing.pairings.get(o6).expiry)) {
      const { message: e4 } = te2("EXPIRED", `pairing topic: ${o6}`);
      throw new Error(e4);
    }
  }
  async isValidSessionTopic(o6) {
    if (!q3(o6, false)) {
      const { message: e4 } = te2("MISSING_OR_INVALID", `session topic should be a string: ${o6}`);
      throw new Error(e4);
    }
    if (this.checkRecentlyDeleted(o6), !this.client.session.keys.includes(o6)) {
      const { message: e4 } = te2("NO_MATCHING_KEY", `session topic doesn't exist: ${o6}`);
      throw new Error(e4);
    }
    if (po2(this.client.session.get(o6).expiry)) {
      await this.deleteSession({ topic: o6 });
      const { message: e4 } = te2("EXPIRED", `session topic: ${o6}`);
      throw new Error(e4);
    }
    if (!this.client.core.crypto.keychain.has(o6)) {
      const { message: e4 } = te2("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o6}`);
      throw await this.deleteSession({ topic: o6 }), new Error(e4);
    }
  }
  async isValidSessionOrPairingTopic(o6) {
    if (this.checkRecentlyDeleted(o6), this.client.session.keys.includes(o6))
      await this.isValidSessionTopic(o6);
    else if (this.client.core.pairing.pairings.keys.includes(o6))
      this.isValidPairingTopic(o6);
    else if (q3(o6, false)) {
      const { message: e4 } = te2("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o6}`);
      throw new Error(e4);
    } else {
      const { message: e4 } = te2("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o6}`);
      throw new Error(e4);
    }
  }
  async isValidProposalId(o6) {
    if (!ki(o6)) {
      const { message: e4 } = te2("MISSING_OR_INVALID", `proposal id should be a number: ${o6}`);
      throw new Error(e4);
    }
    if (!this.client.proposal.keys.includes(o6)) {
      const { message: e4 } = te2("NO_MATCHING_KEY", `proposal id doesn't exist: ${o6}`);
      throw new Error(e4);
    }
    if (po2(this.client.proposal.get(o6).expiryTimestamp)) {
      await this.deleteProposal(o6);
      const { message: e4 } = te2("EXPIRED", `proposal id: ${o6}`);
      throw new Error(e4);
    }
  }
};
var Ss3 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, it4, ye3), this.core = o6, this.logger = e4;
  }
};
var wt4 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, nt3, ye3), this.core = o6, this.logger = e4;
  }
};
var Is2 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, at3, ye3, (t3) => t3.id), this.core = o6, this.logger = e4;
  }
};
var fs2 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, ht4, oe3, () => ae3), this.core = o6, this.logger = e4;
  }
};
var vs2 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, dt4, oe3), this.core = o6, this.logger = e4;
  }
};
var qs3 = class extends li2 {
  constructor(o6, e4) {
    super(o6, e4, ut4, oe3, (t3) => t3.id), this.core = o6, this.logger = e4;
  }
};
var Ts2 = class {
  constructor(o6, e4) {
    this.core = o6, this.logger = e4, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs2(this.core, this.logger), this.requests = new qs3(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e4 = class extends S3 {
  constructor(o6) {
    super(o6), this.protocol = Ce4, this.version = xe3, this.name = we4.name, this.events = new EventEmitter(), this.on = (t3, s5) => this.events.on(t3, s5), this.once = (t3, s5) => this.events.once(t3, s5), this.off = (t3, s5) => this.events.off(t3, s5), this.removeListener = (t3, s5) => this.events.removeListener(t3, s5), this.removeAllListeners = (t3) => this.events.removeAllListeners(t3), this.connect = async (t3) => {
      try {
        return await this.engine.connect(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.pair = async (t3) => {
      try {
        return await this.engine.pair(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.approve = async (t3) => {
      try {
        return await this.engine.approve(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.reject = async (t3) => {
      try {
        return await this.engine.reject(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.update = async (t3) => {
      try {
        return await this.engine.update(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.extend = async (t3) => {
      try {
        return await this.engine.extend(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.request = async (t3) => {
      try {
        return await this.engine.request(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.respond = async (t3) => {
      try {
        return await this.engine.respond(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.ping = async (t3) => {
      try {
        return await this.engine.ping(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.emit = async (t3) => {
      try {
        return await this.engine.emit(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.disconnect = async (t3) => {
      try {
        return await this.engine.disconnect(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.find = (t3) => {
      try {
        return this.engine.find(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.authenticate = async (t3, s5) => {
      try {
        return await this.engine.authenticate(t3, s5);
      } catch (i5) {
        throw this.logger.error(i5.message), i5;
      }
    }, this.formatAuthMessage = (t3) => {
      try {
        return this.engine.formatAuthMessage(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.approveSessionAuthenticate = async (t3) => {
      try {
        return await this.engine.approveSessionAuthenticate(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.rejectSessionAuthenticate = async (t3) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t3);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }, this.name = o6?.name || we4.name, this.metadata = o6?.metadata || Yr2(), this.signConfig = o6?.signConfig;
    const e4 = typeof o6?.logger < "u" && typeof o6?.logger != "string" ? o6.logger : (0, import_pino2.default)(k4({ level: o6?.logger || we4.logger }));
    this.core = o6?.core || new Rn3(o6), this.logger = E5(e4, this.name), this.session = new wt4(this.core, this.logger), this.proposal = new Ss3(this.core, this.logger), this.pendingRequest = new Is2(this.core, this.logger), this.engine = new Rs2(this), this.auth = new Ts2(this.core, this.logger);
  }
  static async init(o6) {
    const e4 = new _e4(o6);
    return await e4.initialize(), e4;
  }
  get context() {
    return y5(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time5.toMiliseconds)(import_time5.ONE_SECOND));
    } catch (o6) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o6.message), o6;
    }
  }
};

// node_modules/.pnpm/@jnwng+walletconnect-solana@0.2.0_@react-native-async-storage+async-storage@1.24.0_react-nati_zpi2ztbgjwb3tlevgvxfiessg4/node_modules/@jnwng/walletconnect-solana/lib/esm/adapter.js
var import_bs58 = __toESM(require_bs58(), 1);

// node_modules/.pnpm/@jnwng+walletconnect-solana@0.2.0_@react-native-async-storage+async-storage@1.24.0_react-nati_zpi2ztbgjwb3tlevgvxfiessg4/node_modules/@jnwng/walletconnect-solana/lib/esm/errors.js
var ClientNotInitializedError = class extends Error {
  constructor() {
    super();
    Object.setPrototypeOf(this, ClientNotInitializedError.prototype);
  }
};
var QRCodeModalError = class extends Error {
  constructor() {
    super();
    Object.setPrototypeOf(this, QRCodeModalError.prototype);
  }
};

// node_modules/.pnpm/@jnwng+walletconnect-solana@0.2.0_@react-native-async-storage+async-storage@1.24.0_react-nati_zpi2ztbgjwb3tlevgvxfiessg4/node_modules/@jnwng/walletconnect-solana/lib/esm/adapter.js
var WalletConnectChainID;
(function(WalletConnectChainID2) {
  WalletConnectChainID2["Mainnet"] = "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ";
  WalletConnectChainID2["Devnet"] = "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K";
})(WalletConnectChainID || (WalletConnectChainID = {}));
var WalletConnectRPCMethods;
(function(WalletConnectRPCMethods2) {
  WalletConnectRPCMethods2["signTransaction"] = "solana_signTransaction";
  WalletConnectRPCMethods2["signMessage"] = "solana_signMessage";
})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));
var getConnectParams = (chainId) => ({
  requiredNamespaces: {
    solana: {
      chains: [chainId],
      methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],
      events: []
    }
  }
});
var isVersionedTransaction = (transaction) => "version" in transaction;
var WalletConnectWallet = class {
  constructor(config) {
    this._options = config.options;
    this._network = config.network;
  }
  async connect() {
    const client = this._client ?? await _e4.init(this._options);
    const sessions = client.find(getConnectParams(this._network)).filter((s5) => s5.acknowledged);
    if (sessions.length) {
      this._session = sessions[sessions.length - 1];
      this._client = client;
      return {
        publicKey: this.publicKey
      };
    } else {
      const { uri, approval } = await client.connect(getConnectParams(this._network));
      return new Promise((resolve, reject) => {
        if (uri) {
          import_qrcode_modal.default.open(uri, () => {
            reject(new QRCodeModalError());
          });
        }
        approval().then((session) => {
          this._session = session;
          this._client = client;
          resolve({ publicKey: this.publicKey });
        }).catch(reject).finally(() => {
          import_qrcode_modal.default.close();
        });
      });
    }
  }
  async disconnect() {
    if (this._client && this._session) {
      await this._client.disconnect({
        topic: this._session.topic,
        reason: de2("USER_DISCONNECTED")
      });
      this._session = void 0;
    } else {
      throw new ClientNotInitializedError();
    }
  }
  get client() {
    if (this._client) {
      return Object.assign({}, this._client, { off: this._client.removeListener });
    } else {
      throw new ClientNotInitializedError();
    }
  }
  get publicKey() {
    if (this._client && this._session) {
      const { address } = Xe2(this._session.namespaces.solana.accounts[0]);
      return new PublicKey(address);
    } else {
      throw new ClientNotInitializedError();
    }
  }
  async signTransaction(transaction) {
    if (this._client && this._session) {
      let rawTransaction;
      let legacyTransaction;
      if (isVersionedTransaction(transaction)) {
        rawTransaction = Buffer.from(transaction.serialize()).toString("base64");
        if (transaction.version === "legacy") {
          legacyTransaction = Transaction.from(transaction.serialize());
        }
      } else {
        rawTransaction = transaction.serialize({
          requireAllSignatures: false,
          verifySignatures: false
        }).toString("base64");
        legacyTransaction = transaction;
      }
      const { signature: signature2 } = await this._client.request({
        chainId: this._network,
        topic: this._session.topic,
        request: {
          method: WalletConnectRPCMethods.signTransaction,
          params: {
            // Passing ...legacyTransaction is deprecated.
            // All new clients should rely on the `transaction` parameter.
            // The future versions will stop passing ...legacyTransaction.
            ...legacyTransaction,
            // New base64-encoded serialized transaction request parameter
            transaction: rawTransaction
          }
        }
      });
      transaction.addSignature(this.publicKey, Buffer.from(import_bs58.default.decode(signature2)));
      return transaction;
    } else {
      throw new ClientNotInitializedError();
    }
  }
  async signMessage(message) {
    if (this._client && this._session) {
      const { signature: signature2 } = await this._client.request({
        // The network does not change the output of message signing, but this is a required parameter for SignClient
        chainId: this._network,
        topic: this._session.topic,
        request: {
          method: WalletConnectRPCMethods.signMessage,
          params: { pubkey: this.publicKey.toString(), message: import_bs58.default.encode(message) }
        }
      });
      return import_bs58.default.decode(signature2);
    } else {
      throw new ClientNotInitializedError();
    }
  }
};
export {
  ClientNotInitializedError,
  QRCodeModalError,
  WalletConnectChainID,
  _e4 as WalletConnectClient,
  WalletConnectRPCMethods,
  WalletConnectWallet
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@walletconnect/relay-auth/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=/build/_shared/esm-2QR4NSHI.js.map
