import {
  T,
  X,
  buffer,
  dew,
  dew$1,
  dew$2,
  dew$3,
  dew$6,
  dew$7,
  dew$8,
  dew$f,
  exports,
  init_chunk_2eac56ff,
  init_chunk_44e51b61,
  init_chunk_4ccc3a29,
  init_chunk_5decc758,
  init_chunk_6c718bbe,
  init_chunk_b4205b57,
  init_chunk_ce0fbc82,
  init_events,
  init_util,
  process as process2,
  promisify
} from "/build/_shared/chunk-R65GGW5O.js";
import {
  events_exports,
  init_events as init_events3
} from "/build/_shared/chunk-235M4KXU.js";
import {
  require_inherits_browser
} from "/build/_shared/chunk-LFIEXLVA.js";
import {
  require_semver
} from "/build/_shared/chunk-QHBTKWMT.js";
import {
  EventEmitter,
  init_chunk_4bd36a8f,
  init_events as init_events2
} from "/build/_shared/chunk-3KZTRC5K.js";
import {
  PublicKey,
  buffer_exports,
  init_buffer2 as init_buffer,
  init_index_browser_esm,
  require_safe_buffer
} from "/build/_shared/chunk-224XRCKB.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-DPSM2F2X.js";

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/primordials.js"(exports10, module) {
    "use strict";
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i4 = 0; i4 < errors.length; i4++) {
          message += `    ${errors[i4].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance2) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance2);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util/inspect.js"(exports10, module) {
    "use strict";
    module.exports = {
      format(format4, ...args) {
        return format4.replace(/%([sdifj])/g, function(...[_unused, type2]) {
          const replacement = args.shift();
          if (type2 === "f") {
            return replacement.toFixed(6);
          } else if (type2 === "j") {
            return JSON.stringify(replacement);
          } else if (type2 === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/errors.js"(exports10, module) {
    "use strict";
    var { format: format4, inspect: inspect2 } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes2 = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes2.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i4 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i4 >= start + 4; i4 -= 3) {
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      }
      return `${val.slice(0, i4)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format4(msg, ...args);
    }
    function E2(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes2[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes2.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E2("ERR_ASSERTION", "%s", Error);
    E2(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert2(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types2 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types2.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types2.indexOf("object");
          if (pos !== -1) {
            types2.splice(types2, pos, 1);
            instances.push("Object");
          }
        }
        if (types2.length > 0) {
          switch (types2.length) {
            case 1:
              msg += `of type ${types2[0]}`;
              break;
            case 2:
              msg += `one of type ${types2[0]} or ${types2[1]}`;
              break;
            default: {
              const last = types2.pop();
              msg += `one of type ${types2.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect2(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect2(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E2(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect2(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type2 = name.includes(".") ? "property" : "argument";
        return `The ${type2} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E2(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type2 = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type2}.`;
      },
      TypeError
    );
    E2(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a4) => `"${a4}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect2(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes: codes2
    };
  }
});

// node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/browser.js"(exports10, module) {
    "use strict";
    var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController2;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController2;
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/util.js"(exports10, module) {
    "use strict";
    var bufferModule = (init_buffer(), __toCommonJS(buffer_exports));
    var { format: format4, inspect: inspect2 } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors();
    var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b4) {
      return b4 instanceof Blob2;
    } : function isBlob2(b4) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve3;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve3 = res;
          reject = rej;
        });
        return {
          promise,
          resolve: resolve3,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve3, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve3(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format: format4,
      inspect: inspect2,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: (init_events3(), __toCommonJS(events_exports)).addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/validators.js"(exports10, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min2 = NumberMIN_SAFE_INTEGER, max2 = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min2 || value > max2)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min2} && <= ${max2}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min2 = -2147483648, max2 = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min2 || value > max2) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min2} && <= ${max2}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min2 = positive ? 1 : 0;
      const max2 = 4294967295;
      if (value < min2 || value > max2) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min2} && <= ${max2}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min2 = void 0, max2) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min2 != null && value < min2 || max2 != null && value > max2 || (min2 != null || max2 != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min2 != null ? `>= ${min2}` : ""}${min2 != null && max2 != null ? " && " : ""}${max2 != null ? `<= ${max2}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v4) => typeof v4 === "string" ? `'${v4}'` : String2(v4)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable2 = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable2 && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0; i4 < value.length; i4++) {
        validateString(value[i4], `${name}[${i4}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0; i4 < value.length; i4++) {
        validateBoolean(value[i4], `${name}[${i4}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i4 = 0; i4 < value.length; i4++) {
        const signal = value[i4];
        const indexedName = `${name}[${i4}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer2, name = "buffer") => {
      if (!isArrayBufferView(buffer2)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer2);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union2) {
      if (!ArrayPrototypeIncludes(union2, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union2, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i4 = 0; i4 < hintsLength; i4++) {
          const link = hints[i4];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i4 !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports10, module) {
    var process3 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e6) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e6) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e6) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e7) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e6) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e7) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i4 = 1; i4 < arguments.length; i4++) {
          args[i4 - 1] = arguments[i4];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop2() {
    }
    process3.on = noop2;
    process3.addListener = noop2;
    process3.once = noop2;
    process3.off = noop2;
    process3.removeListener = noop2;
    process3.removeAllListeners = noop2;
    process3.emit = noop2;
    process3.prependListener = noop2;
    process3.prependOnceListener = noop2;
    process3.listeners = function(name) {
      return [];
    };
    process3.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/utils.js"(exports10, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict2 = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict2 || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable2(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict2) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict2 === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict2) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict2 === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable: isIterable2,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports10, module) {
    "use strict";
    var process3 = require_browser2();
    var { AbortError, codes: codes2 } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes2;
    var { kEmptyObject, once: once3 } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos3(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once3(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process3.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process3.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process3.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process3.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process3.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process3.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process3.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once3((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process3.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished2(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve3, reject) => {
        const cleanup = eos3(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve3();
          }
        });
      });
    }
    module.exports = eos3;
    module.exports.finished = finished2;
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports10, module) {
    "use strict";
    var process3 = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w2, r6) {
      if (err) {
        err.stack;
        if (w2 && !w2.errored) {
          w2.errored = err;
        }
        if (r6 && !r6.errored) {
          r6.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r6 = this._readableState;
      const w2 = this._writableState;
      const s2 = w2 || r6;
      if (w2 !== null && w2 !== void 0 && w2.destroyed || r6 !== null && r6 !== void 0 && r6.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w2, r6);
      if (w2) {
        w2.destroyed = true;
      }
      if (r6) {
        r6.destroyed = true;
      }
      if (!s2.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r6 = self2._readableState;
        const w2 = self2._writableState;
        checkError(err2, w2, r6);
        if (w2) {
          w2.closed = true;
        }
        if (r6) {
          r6.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process3.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process3.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r6 = self2._readableState;
      const w2 = self2._writableState;
      if (w2) {
        w2.closeEmitted = true;
      }
      if (r6) {
        r6.closeEmitted = true;
      }
      if (w2 !== null && w2 !== void 0 && w2.emitClose || r6 !== null && r6 !== void 0 && r6.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r6 = self2._readableState;
      const w2 = self2._writableState;
      if (w2 !== null && w2 !== void 0 && w2.errorEmitted || r6 !== null && r6 !== void 0 && r6.errorEmitted) {
        return;
      }
      if (w2) {
        w2.errorEmitted = true;
      }
      if (r6) {
        r6.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r6 = this._readableState;
      const w2 = this._writableState;
      if (r6) {
        r6.constructed = true;
        r6.closed = false;
        r6.closeEmitted = false;
        r6.destroyed = false;
        r6.errored = null;
        r6.errorEmitted = false;
        r6.reading = false;
        r6.ended = r6.readable === false;
        r6.endEmitted = r6.readable === false;
      }
      if (w2) {
        w2.constructed = true;
        w2.destroyed = false;
        w2.closed = false;
        w2.closeEmitted = false;
        w2.errored = null;
        w2.errorEmitted = false;
        w2.finalCalled = false;
        w2.prefinished = false;
        w2.ended = w2.writable === false;
        w2.ending = w2.writable === false;
        w2.finished = w2.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r6 = stream._readableState;
      const w2 = stream._writableState;
      if (w2 !== null && w2 !== void 0 && w2.destroyed || r6 !== null && r6 !== void 0 && r6.destroyed) {
        return this;
      }
      if (r6 !== null && r6 !== void 0 && r6.autoDestroy || w2 !== null && w2 !== void 0 && w2.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w2 && !w2.errored) {
          w2.errored = err;
        }
        if (r6 && !r6.errored) {
          r6.errored = err;
        }
        if (sync) {
          process3.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r6 = stream._readableState;
      const w2 = stream._writableState;
      if (r6) {
        r6.constructed = false;
      }
      if (w2) {
        w2.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process3.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r6 = stream._readableState;
        const w2 = stream._writableState;
        const s2 = w2 || r6;
        if (r6) {
          r6.constructed = true;
        }
        if (w2) {
          w2.constructed = true;
        }
        if (s2.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process3.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process3.nextTick(onConstruct, err);
        });
      } catch (err) {
        process3.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process3.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process3.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process3.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports10, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = (init_events3(), __toCommonJS(events_exports));
    function Stream2(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream2.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream2, EE);
    Stream2.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream: Stream2,
      prependListener
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports10, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes: codes2 } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos3 = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes2;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos3(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports10, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(buffer_exports));
    var { inspect: inspect2 } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v4) {
        const entry = {
          data: v4,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v4) {
        const entry = {
          data: v4,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s2) {
        if (this.length === 0)
          return "";
        let p4 = this.head;
        let ret = "" + p4.data;
        while ((p4 = p4.next) !== null)
          ret += s2 + p4.data;
        return ret;
      }
      concat(n5) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n5 >>> 0);
        let p4 = this.head;
        let i4 = 0;
        while (p4) {
          TypedArrayPrototypeSet(ret, p4.data, i4);
          i4 += p4.data.length;
          p4 = p4.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n5, hasStrings) {
        const data = this.head.data;
        if (n5 < data.length) {
          const slice = data.slice(0, n5);
          this.head.data = data.slice(n5);
          return slice;
        }
        if (n5 === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n5) : this._getBuffer(n5);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p4 = this.head; p4; p4 = p4.next) {
          yield p4.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n5) {
        let ret = "";
        let p4 = this.head;
        let c4 = 0;
        do {
          const str = p4.data;
          if (n5 > str.length) {
            ret += str;
            n5 -= str.length;
          } else {
            if (n5 === str.length) {
              ret += str;
              ++c4;
              if (p4.next)
                this.head = p4.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n5);
              this.head = p4;
              p4.data = StringPrototypeSlice(str, n5);
            }
            break;
          }
          ++c4;
        } while ((p4 = p4.next) !== null);
        this.length -= c4;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n5) {
        const ret = Buffer2.allocUnsafe(n5);
        const retLen = n5;
        let p4 = this.head;
        let c4 = 0;
        do {
          const buf = p4.data;
          if (n5 > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n5);
            n5 -= buf.length;
          } else {
            if (n5 === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n5);
              ++c4;
              if (p4.next)
                this.head = p4.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n5), retLen - n5);
              this.head = p4;
              p4.data = buf.slice(n5);
            }
            break;
          }
          ++c4;
        } while ((p4 = p4.next) !== null);
        this.length -= c4;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect2(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/state.js"(exports10, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports10) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports10.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r6;
      var i4;
      if (this.lastNeed) {
        r6 = this.fillLast(buf);
        if (r6 === void 0)
          return "";
        i4 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i4 = 0;
      }
      if (i4 < buf.length)
        return r6 ? r6 + this.text(buf, i4) : this.text(buf, i4);
      return r6 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j2 = buf.length - 1;
      if (j2 < i4)
        return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p4) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p4 = this.lastTotal - this.lastNeed;
      var r6 = utf8CheckExtraBytes(this, buf, p4);
      if (r6 !== void 0)
        return r6;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p4, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p4, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + "\uFFFD";
      return r6;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r6 = buf.toString("utf16le", i4);
        if (r6) {
          var c4 = r6.charCodeAt(r6.length - 1);
          if (c4 >= 55296 && c4 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r6.slice(0, -1);
          }
        }
        return r6;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r6 + this.lastChar.toString("utf16le", 0, end);
      }
      return r6;
    }
    function base64Text(buf, i4) {
      var n5 = (buf.length - i4) % 3;
      if (n5 === 0)
        return buf.toString("base64", i4);
      this.lastNeed = 3 - n5;
      this.lastTotal = 3;
      if (n5 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i4, buf.length - n5);
    }
    function base64End(buf) {
      var r6 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r6 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r6;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/from.js"(exports10, module) {
    "use strict";
    var process3 = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(buffer_exports));
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process3.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e6) => process3.nextTick(cb, e6 || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/readable.js"(exports10, module) {
    "use strict";
    var process3 = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = (init_events3(), __toCommonJS(events_exports));
    var { Stream: Stream2, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(buffer_exports));
    var { addAbortSignal } = require_add_abort_signal();
    var eos3 = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Readable2, Stream2);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2))
        return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream2.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve3, reject) => eos3(this, (err) => err && err !== error ? reject(err) : resolve3(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer2 = this._readableState.buffer;
      let content = "";
      for (const data of buffer2) {
        content += decoder.write(data);
      }
      buffer2.clear();
      if (content !== "")
        buffer2.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n5);
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n5)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n5 <= state.length)
        return n5;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n5) {
      debug("read", n5);
      if (n5 === void 0) {
        n5 = NaN;
      } else if (!NumberIsInteger(n5)) {
        n5 = NumberParseInt(n5, 10);
      }
      const state = this._readableState;
      const nOrig = n5;
      if (n5 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 !== 0)
        state.state &= ~kEmittedReadable;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading)
          n5 = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n5 > 0)
        ret = fromList(n5, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n5 && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process3.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process3.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n5) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process3.stdout && dest !== process3.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process3.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s2 = dest._writableState || dest._readableState;
          if (s2 && !s2.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i4 = 0; i4 < dests.length; i4++)
          dests[i4].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream2.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process3.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process3.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process3.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process3.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j2 = 1; j2 < streamKeys.length; j2++) {
        const i4 = streamKeys[j2];
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = stream[i4].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve3) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve3;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos3(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r6 = this._readableState;
          return !!r6 && r6.readable !== false && !r6.destroyed && !r6.errorEmitted && !r6.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n5, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process3.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process3.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/writable.js"(exports10, module) {
    "use strict";
    var process3 = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable2;
    Writable2.WritableState = WritableState;
    var { EventEmitter: EE } = (init_events3(), __toCommonJS(events_exports));
    var Stream2 = require_legacy().Stream;
    var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(buffer_exports));
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable2.prototype, Stream2.prototype);
    ObjectSetPrototypeOf(Writable2, Stream2);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable2(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream2.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable2, SymbolHasInstance, {
      __proto__: null,
      value: function(object2) {
        if (FunctionPrototypeSymbolHasInstance(this, object2))
          return true;
        if (this !== Writable2)
          return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream2._isUint8Array(chunk)) {
          chunk = Stream2._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process3.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process3.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process3.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n5 = state.bufferedIndex; n5 < state.buffered.length; ++n5) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n5];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0; i4 < onfinishCallbacks.length; i4++) {
        var _state$errored2;
        onfinishCallbacks[i4](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i4 = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n5 = i4; n5 < buffered.length; ++n5) {
            buffered[n5].callback(err);
          }
        };
        const chunks = state.allNoop && i4 === 0 ? buffered : ArrayPrototypeSlice(buffered, i4);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i4];
          buffered[i4++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i4 < buffered.length && !state.writing);
        if (i4 === buffered.length) {
          resetBuffer(state);
        } else if (i4 > 256) {
          buffered.splice(0, i4);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i4;
        }
      }
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process3.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i4 = 0; i4 < onfinishCallbacks.length; i4++) {
            onfinishCallbacks[i4](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process3.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process3.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i4 = 0; i4 < onfinishCallbacks.length; i4++) {
        onfinishCallbacks[i4]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable2.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w2 = this._writableState;
          return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable2.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process3.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable2.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable2.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports10, module) {
    var process3 = require_browser2();
    var bufferModule = (init_buffer(), __toCommonJS(buffer_exports));
    var {
      isReadable,
      isWritable,
      isIterable: isIterable2,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos3 = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex4 = require_duplex();
    var Readable2 = require_readable();
    var Writable2 = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b4) {
      return b4 instanceof Blob2;
    } : function isBlob2(b4) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex4 {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable2.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable2(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d3;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d3, err);
            }
          );
          return d3 = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process3.nextTick(cb, null);
                } catch (err) {
                  process3.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable2(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d3;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d3.push(val);
            }
            d3.push(null);
          },
          (err) => {
            destroyer(d3, err);
          }
        );
        return d3 = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve: resolve3 } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process3.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve: resolve3 } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve3;
          resolve3 = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve3;
          resolve3 = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r6 = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w2 = pair.writable;
      let readable = !!isReadable(r6);
      let writable = !!isWritable(w2);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d3;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d3.destroy(err);
        }
      }
      d3 = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r6 !== null && r6 !== void 0 && r6.readableObjectMode),
        writableObjectMode: !!(w2 !== null && w2 !== void 0 && w2.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos3(w2, (err) => {
          writable = false;
          if (err) {
            destroyer(r6, err);
          }
          onfinished(err);
        });
        d3._write = function(chunk, encoding, callback) {
          if (w2.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d3._final = function(callback) {
          w2.end();
          onfinish = callback;
        };
        w2.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w2.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos3(r6, (err) => {
          readable = false;
          if (err) {
            destroyer(r6, err);
          }
          onfinished(err);
        });
        r6.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r6.on("end", function() {
          d3.push(null);
        });
        d3._read = function() {
          while (true) {
            const buf = r6.read();
            if (buf === null) {
              onreadable = d3._read;
              return;
            }
            if (!d3.push(buf)) {
              return;
            }
          }
        };
      }
      d3._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w2, err);
          destroyer(r6, err);
        }
      };
      return d3;
    }
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports10, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex4;
    var Readable2 = require_readable();
    var Writable2 = require_writable();
    ObjectSetPrototypeOf(Duplex4.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex4, Readable2);
    {
      const keys = ObjectKeys(Writable2.prototype);
      for (let i4 = 0; i4 < keys.length; i4++) {
        const method = keys[i4];
        if (!Duplex4.prototype[method])
          Duplex4.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex4(options) {
      if (!(this instanceof Duplex4))
        return new Duplex4(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex4.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable2.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex4.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex4.toWeb = function(duplex2) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex2);
    };
    var duplexify;
    Duplex4.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/transform.js"(exports10, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform2;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex4 = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform2.prototype, Duplex4.prototype);
    ObjectSetPrototypeOf(Transform2, Duplex4);
    var kCallback = Symbol2("kCallback");
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex4.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform2.prototype._final = final;
    Transform2.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform2.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform2.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports10, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough2;
    var Transform2 = require_transform();
    ObjectSetPrototypeOf(PassThrough2.prototype, Transform2.prototype);
    ObjectSetPrototypeOf(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports10, module) {
    var process3 = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos3 = require_end_of_stream();
    var { once: once3 } = require_util();
    var destroyImpl = require_destroy();
    var Duplex4 = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable: isIterable2,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var PassThrough2;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished2 = false;
      stream.on("close", () => {
        finished2 = true;
      });
      const cleanup = eos3(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished2 = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished2)
            return;
          finished2 = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable2(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve3, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve3();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos3(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline2(...streams) {
      return pipelineImpl(streams, once3(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process3.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i4 = 0; i4 < streams.length; i4++) {
        const stream = streams[i4];
        const reading = i4 < streams.length - 1;
        const writing = i4 > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i4 === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i4 === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable2(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable2(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex4.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable2(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i4 - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough2) {
              PassThrough2 = require_passthrough();
            }
            const pt = new PassThrough2({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process3.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process3.nextTick(finish, err);
                }
              );
            } else if (isIterable2(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable2(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable2(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex4.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process3.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process3.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos3(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos3(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline: pipeline2
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/compose.js"(exports10, module) {
    "use strict";
    var { pipeline: pipeline2 } = require_pipeline();
    var Duplex4 = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos3 = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex4.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex4.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex4.from(streams[idx]);
      }
      for (let n5 = 0; n5 < streams.length; ++n5) {
        if (!isNodeStream(streams[n5]) && !isWebStream(streams[n5])) {
          continue;
        }
        if (n5 < streams.length - 1 && !(isReadable(streams[n5]) || isReadableStream(streams[n5]) || isTransformStream(streams[n5]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n5}]`, orgStreams[n5], "must be readable");
        }
        if (n5 > 0 && !(isWritable(streams[n5]) || isWritableStream(streams[n5]) || isTransformStream(streams[n5]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n5}]`, orgStreams[n5], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d3;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d3.destroy(err);
        } else if (!readable && !writable) {
          d3.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline2(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d3 = new Duplex4({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d3._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d3._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d3._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d3._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos3(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d3.push(null);
          });
          d3._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d3._read;
                return;
              }
              if (!d3.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d3._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d3.push(value)) {
                  return;
                }
                if (done) {
                  d3.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d3._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d3;
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/internal/streams/operators.js"(exports10, module) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished: finished2 } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate: deprecate2 } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map2(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map3() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump4() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve3) => {
                  resume = resolve3;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump4();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve3) => {
              next = resolve3;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map2.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map2.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished2(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map2.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number2) {
      number2 = Number2(number2);
      if (NumberIsNaN(number2)) {
        return 0;
      }
      if (number2 < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number2);
      }
      return number2;
    }
    function drop(number2, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number2 = toIntegerOrInfinity(number2);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number2-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number2, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number2 = toIntegerOrInfinity(number2);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number2-- > 0) {
            yield val;
          }
          if (number2 <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate2(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map: map2,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream/promises.js"(exports10, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable: isIterable2, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished: finished2 } = require_end_of_stream();
    require_stream();
    function pipeline2(...streams) {
      return new Promise2((resolve3, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable2(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve3(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished: finished2,
      pipeline: pipeline2
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/stream.js"(exports10, module) {
    "use strict";
    var { Buffer: Buffer2 } = (init_buffer(), __toCommonJS(buffer_exports));
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline: pipeline2 } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos3 = require_end_of_stream();
    var promises2 = require_promises();
    var utils = require_utils();
    var Stream2 = module.exports = require_legacy().Stream;
    Stream2.isDestroyed = utils.isDestroyed;
    Stream2.isDisturbed = utils.isDisturbed;
    Stream2.isErrored = utils.isErrored;
    Stream2.isReadable = utils.isReadable;
    Stream2.isWritable = utils.isWritable;
    Stream2.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream2.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream2.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream2.Writable = require_writable();
    Stream2.Duplex = require_duplex();
    Stream2.Transform = require_transform();
    Stream2.PassThrough = require_passthrough();
    Stream2.pipeline = pipeline2;
    var { addAbortSignal } = require_add_abort_signal();
    Stream2.addAbortSignal = addAbortSignal;
    Stream2.finished = eos3;
    Stream2.destroy = destroyer;
    Stream2.compose = compose;
    Stream2.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream2.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream2, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    ObjectDefineProperty(pipeline2, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.pipeline;
      }
    });
    ObjectDefineProperty(eos3, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises2.finished;
      }
    });
    Stream2.Stream = Stream2;
    Stream2._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream2._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/readable-stream@4.7.0/node_modules/readable-stream/lib/ours/browser.js"(exports10, module) {
    "use strict";
    var CustomStream = require_stream();
    var promises2 = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises2;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js"(exports10, module) {
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_2) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k2, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k2, { value: replace });
          arr.push([parent, k2, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k2, replace]);
        }
      } else {
        parent[k2] = replace;
        arr.push([parent, k2, val]);
      }
    }
    function decirc(val, k2, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            decirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i4 = 0; i4 < keys.length; i4++) {
            var key = keys[i4];
            decirc(val[key], key, i4, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a4, b4) {
      if (a4 < b4) {
        return -1;
      }
      if (a4 > b4) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_2) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k2, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_2) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            deterministicDecirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i4 = 0; i4 < keys.length; i4++) {
            var key = keys[i4];
            deterministicDecirc(val[key], key, i4, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k2, val]);
            parent[k2] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k2, v4) {
        return v4;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i4 = 0; i4 < replacerStack.length; i4++) {
            var part = replacerStack[i4];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i4, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/.pnpm/superstruct@1.0.4/node_modules/superstruct/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  Struct: () => Struct,
  StructError: () => StructError,
  any: () => any,
  array: () => array,
  assert: () => assert,
  assign: () => assign,
  bigint: () => bigint,
  boolean: () => boolean,
  coerce: () => coerce,
  create: () => create,
  date: () => date,
  defaulted: () => defaulted,
  define: () => define2,
  deprecated: () => deprecated,
  dynamic: () => dynamic,
  empty: () => empty,
  enums: () => enums,
  func: () => func,
  instance: () => instance,
  integer: () => integer,
  intersection: () => intersection,
  is: () => is,
  lazy: () => lazy,
  literal: () => literal,
  map: () => map,
  mask: () => mask,
  max: () => max,
  min: () => min,
  never: () => never,
  nonempty: () => nonempty,
  nullable: () => nullable,
  number: () => number,
  object: () => object,
  omit: () => omit,
  optional: () => optional,
  partial: () => partial,
  pattern: () => pattern,
  pick: () => pick,
  record: () => record,
  refine: () => refine,
  regexp: () => regexp,
  set: () => set,
  size: () => size,
  string: () => string,
  struct: () => struct,
  trimmed: () => trimmed,
  tuple: () => tuple,
  type: () => type,
  union: () => union,
  unknown: () => unknown,
  validate: () => validate
});
function isIterable(x2) {
  return isObject(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isPlainObject(x2) {
  if (Object.prototype.toString.call(x2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(x2);
  return prototype === null || prototype === Object.prototype;
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path: path3, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path3[path3.length - 1],
    path: path3,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r6 of result) {
    const failure = toFailure(r6, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const { path: path3 = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path: path3, branch };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
    if (mask2 && struct2.type !== "type" && isObject(struct2.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct2.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k2, v4, s2] of struct2.entries(value, ctx)) {
    const ts = run(v4, s2, {
      path: k2 === void 0 ? path3 : [...path3, k2],
      branch: k2 === void 0 ? branch : [...branch, v4],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t4 of ts) {
      if (t4[0]) {
        status = t4[0].refinement != null ? "not_refined" : "not_valid";
        yield [t4[0], void 0];
      } else if (coerce2) {
        v4 = t4[1];
        if (k2 === void 0) {
          value = v4;
        } else if (value instanceof Map) {
          value.set(k2, v4);
        } else if (value instanceof Set) {
          value.add(v4);
        } else if (isObject(value)) {
          if (v4 !== void 0 || k2 in value)
            value[k2] = v4;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
function assert(value, struct2, message) {
  const result = validate(value, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct2, message) {
  const result = validate(value, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct2, message) {
  const result = validate(value, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct2) {
  const result = validate(value, struct2);
  return !result[0];
}
function validate(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t4 of tuples) {
        if (t4[0]) {
          yield t4[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v4 = tuple2[1];
    return [void 0, v4];
  }
}
function assign(...Structs) {
  const isType = Structs[0].type === "type";
  const schemas = Structs.map((s2) => s2.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type(schema) : object(schema);
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function deprecated(struct2, log5) {
  return new Struct({
    ...struct2,
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx),
    validator(value, ctx) {
      if (value === void 0) {
        return true;
      } else {
        log5(value, ctx);
        return struct2.validator(value, ctx);
      }
    }
  });
}
function dynamic(fn) {
  return new Struct({
    type: "dynamic",
    schema: null,
    *entries(value, ctx) {
      const struct2 = fn(value, ctx);
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      const struct2 = fn(value, ctx);
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      const struct2 = fn(value, ctx);
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      const struct2 = fn(value, ctx);
      return struct2.refiner(value, ctx);
    }
  });
}
function lazy(fn) {
  let struct2;
  return new Struct({
    type: "lazy",
    schema: null,
    *entries(value, ctx) {
      struct2 ?? (struct2 = fn());
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      struct2 ?? (struct2 = fn());
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      struct2 ?? (struct2 = fn());
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      struct2 ?? (struct2 = fn());
      return struct2.refiner(value, ctx);
    }
  });
}
function omit(struct2, keys) {
  const { schema } = struct2;
  const subschema = { ...schema };
  for (const key of keys) {
    delete subschema[key];
  }
  switch (struct2.type) {
    case "type":
      return type(subschema);
    default:
      return object(subschema);
  }
}
function partial(struct2) {
  const isStruct = struct2 instanceof Struct;
  const schema = isStruct ? { ...struct2.schema } : { ...struct2 };
  for (const key in schema) {
    schema[key] = optional(schema[key]);
  }
  if (isStruct && struct2.type === "type") {
    return type(schema);
  }
  return object(schema);
}
function pick(struct2, keys) {
  const { schema } = struct2;
  const subschema = {};
  for (const key of keys) {
    subschema[key] = schema[key];
  }
  switch (struct2.type) {
    case "type":
      return type(subschema);
    default:
      return object(subschema);
  }
}
function struct(name, validator) {
  console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
  return define2(name, validator);
}
function any() {
  return define2("any", () => true);
}
function array(Element2) {
  return new Struct({
    type: "array",
    schema: Element2,
    *entries(value) {
      if (Element2 && Array.isArray(value)) {
        for (const [i4, v4] of value.entries()) {
          yield [i4, v4, Element2];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function bigint() {
  return define2("bigint", (value) => {
    return typeof value === "bigint";
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function date() {
  return define2("date", (value) => {
    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
  });
}
function enums(values) {
  const schema = {};
  const description = values.map((v4) => print(v4)).join();
  for (const key of values) {
    schema[key] = key;
  }
  return new Struct({
    type: "enums",
    schema,
    validator(value) {
      return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function func() {
  return define2("func", (value) => {
    return typeof value === "function" || `Expected a function, but received: ${print(value)}`;
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function integer() {
  return define2("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
  });
}
function intersection(Structs) {
  return new Struct({
    type: "intersection",
    schema: null,
    *entries(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.entries(value, ctx);
      }
    },
    *validator(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.validator(value, ctx);
      }
    },
    *refiner(value, ctx) {
      for (const S2 of Structs) {
        yield* S2.refiner(value, ctx);
      }
    }
  });
}
function literal(constant) {
  const description = print(constant);
  const t4 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t4 === "string" || t4 === "number" || t4 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function map(Key, Value) {
  return new Struct({
    type: "map",
    schema: null,
    *entries(value) {
      if (Key && Value && value instanceof Map) {
        for (const [k2, v4] of value.entries()) {
          yield [k2, k2, Key];
          yield [k2, v4, Value];
        }
      }
    },
    coercer(value) {
      return value instanceof Map ? new Map(value) : value;
    },
    validator(value) {
      return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: "object",
    schema: schema ? schema : null,
    *entries(value) {
      if (schema && isObject(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key of knowns) {
          unknowns.delete(key);
          yield [key, value[key], schema[key]];
        }
        for (const key of unknowns) {
          yield [key, value[key], Never];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function optional(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k2 in value) {
          const v4 = value[k2];
          yield [k2, k2, Key];
          yield [k2, v4, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    }
  });
}
function regexp() {
  return define2("regexp", (value) => {
    return value instanceof RegExp;
  });
}
function set(Element2) {
  return new Struct({
    type: "set",
    schema: null,
    *entries(value) {
      if (Element2 && value instanceof Set) {
        for (const v4 of value) {
          yield [v4, v4, Element2];
        }
      }
    },
    coercer(value) {
      return value instanceof Set ? new Set(value) : value;
    },
    validator(value) {
      return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i4 = 0; i4 < length; i4++) {
          yield [i4, value[i4], Structs[i4] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k2 of keys) {
          yield [k2, value[k2], schema[k2]];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s2) => s2.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct2, condition, coercer) {
  return new Struct({
    ...struct2,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
function defaulted(struct2, fallback, options = {}) {
  return coerce(struct2, unknown(), (x2) => {
    const f4 = typeof fallback === "function" ? fallback() : fallback;
    if (x2 === void 0) {
      return f4;
    }
    if (!options.strict && isPlainObject(x2) && isPlainObject(f4)) {
      const ret = { ...x2 };
      let changed = false;
      for (const key in f4) {
        if (ret[key] === void 0) {
          ret[key] = f4[key];
          changed = true;
        }
      }
      if (changed) {
        return ret;
      }
    }
    return x2;
  });
}
function trimmed(struct2) {
  return coerce(struct2, string(), (x2) => x2.trim());
}
function empty(struct2) {
  return refine(struct2, "empty", (value) => {
    const size2 = getSize(value);
    return size2 === 0 || `Expected an empty ${struct2.type} but received one with a size of \`${size2}\``;
  });
}
function getSize(value) {
  if (value instanceof Map || value instanceof Set) {
    return value.size;
  } else {
    return value.length;
  }
}
function max(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "max", (value) => {
    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct2.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function min(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "min", (value) => {
    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct2.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function nonempty(struct2) {
  return refine(struct2, "nonempty", (value) => {
    const size2 = getSize(value);
    return size2 > 0 || `Expected a nonempty ${struct2.type} but received an empty one`;
  });
}
function pattern(struct2, regexp2) {
  return refine(struct2, "pattern", (value) => {
    return regexp2.test(value) || `Expected a ${struct2.type} matching \`/${regexp2.source}/\` but received "${value}"`;
  });
}
function size(struct2, min2, max2 = min2) {
  const expected = `Expected a ${struct2.type}`;
  const of = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
  return refine(struct2, "size", (value) => {
    if (typeof value === "number" || value instanceof Date) {
      return min2 <= value && value <= max2 || `${expected} ${of} but received \`${value}\``;
    } else if (value instanceof Map || value instanceof Set) {
      const { size: size2 } = value;
      return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of} but received one with a size of \`${size2}\``;
    } else {
      const { length } = value;
      return min2 <= length && length <= max2 || `${expected} with a length ${of} but received one with a length of \`${length}\``;
    }
  });
}
function refine(struct2, name, refiner) {
  return new Struct({
    ...struct2,
    *refiner(value, ctx) {
      yield* struct2.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct2, value);
      for (const failure of failures) {
        yield { ...failure, refinement: name };
      }
    }
  });
}
var StructError, Struct;
var init_dist = __esm({
  "node_modules/.pnpm/superstruct@1.0.4/node_modules/superstruct/dist/index.mjs"() {
    StructError = class extends TypeError {
      constructor(failure, failures) {
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path: path3 } = failure;
        const msg = path3.length === 0 ? message : `At path: ${path3.join(".")} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null)
          this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          return cached ?? (cached = [failure, ...failures()]);
        };
      }
    };
    Struct = class {
      constructor(props) {
        const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
        } } = props;
        this.type = type2;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      /**
       * Assert that a value passes the struct's validation, throwing if it doesn't.
       */
      assert(value, message) {
        return assert(value, this, message);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */
      create(value, message) {
        return create(value, this, message);
      }
      /**
       * Check if a value passes the struct's validation.
       */
      is(value) {
        return is(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema.
       */
      mask(value, message) {
        return mask(value, this, message);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `withCoercion` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful.
       */
      validate(value, options = {}) {
        return validate(value, this, options);
      }
    };
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/assert.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.assertExhaustive = exports10.assertStruct = exports10.assert = exports10.AssertionError = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    function isErrorWithMessage(error) {
      return typeof error === "object" && error !== null && "message" in error;
    }
    function isConstructable(fn) {
      var _a, _b;
      return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === "string");
    }
    function getErrorMessage(error) {
      const message = isErrorWithMessage(error) ? error.message : String(error);
      if (message.endsWith(".")) {
        return message.slice(0, -1);
      }
      return message;
    }
    function getError(ErrorWrapper, message) {
      if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
          message
        });
      }
      return ErrorWrapper({
        message
      });
    }
    var AssertionError2 = class extends Error {
      constructor(options) {
        super(options.message);
        this.code = "ERR_ASSERTION";
      }
    };
    exports10.AssertionError = AssertionError2;
    function assert2(value, message = "Assertion failed.", ErrorWrapper = AssertionError2) {
      if (!value) {
        if (message instanceof Error) {
          throw message;
        }
        throw getError(ErrorWrapper, message);
      }
    }
    exports10.assert = assert2;
    function assertStruct(value, struct2, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError2) {
      try {
        (0, superstruct_1.assert)(value, struct2);
      } catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
      }
    }
    exports10.assertStruct = assertStruct;
    function assertExhaustive(_object) {
      throw new Error("Invalid branch reached. Should be detected during compilation.");
    }
    exports10.assertExhaustive = assertExhaustive;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/base64.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.base64 = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var base64 = (struct2, options = {}) => {
      var _a, _b;
      const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
      const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : "base64";
      let letters;
      if (characterSet === "base64") {
        letters = String.raw`[A-Za-z0-9+\/]`;
      } else {
        (0, assert_1.assert)(characterSet === "base64url");
        letters = String.raw`[-_A-Za-z0-9]`;
      }
      let re;
      if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, "u");
      } else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, "u");
      }
      return (0, superstruct_1.pattern)(struct2, re);
    };
    exports10.base64 = base64;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/hex.js
var require_hex = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/hex.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.remove0x = exports10.add0x = exports10.assertIsStrictHexString = exports10.assertIsHexString = exports10.isStrictHexString = exports10.isHexString = exports10.StrictHexStruct = exports10.HexStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    exports10.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
    exports10.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
    function isHexString(value) {
      return (0, superstruct_1.is)(value, exports10.HexStruct);
    }
    exports10.isHexString = isHexString;
    function isStrictHexString(value) {
      return (0, superstruct_1.is)(value, exports10.StrictHexStruct);
    }
    exports10.isStrictHexString = isStrictHexString;
    function assertIsHexString(value) {
      (0, assert_1.assert)(isHexString(value), "Value must be a hexadecimal string.");
    }
    exports10.assertIsHexString = assertIsHexString;
    function assertIsStrictHexString(value) {
      (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
    }
    exports10.assertIsStrictHexString = assertIsStrictHexString;
    function add0x(hexadecimal) {
      if (hexadecimal.startsWith("0x")) {
        return hexadecimal;
      }
      if (hexadecimal.startsWith("0X")) {
        return `0x${hexadecimal.substring(2)}`;
      }
      return `0x${hexadecimal}`;
    }
    exports10.add0x = add0x;
    function remove0x(hexadecimal) {
      if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
        return hexadecimal.substring(2);
      }
      return hexadecimal;
    }
    exports10.remove0x = remove0x;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/bytes.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.createDataView = exports10.concatBytes = exports10.valueToBytes = exports10.stringToBytes = exports10.numberToBytes = exports10.signedBigIntToBytes = exports10.bigIntToBytes = exports10.hexToBytes = exports10.bytesToString = exports10.bytesToNumber = exports10.bytesToSignedBigInt = exports10.bytesToBigInt = exports10.bytesToHex = exports10.assertIsBytes = exports10.isBytes = void 0;
    var assert_1 = require_assert();
    var hex_1 = require_hex();
    var HEX_MINIMUM_NUMBER_CHARACTER = 48;
    var HEX_MAXIMUM_NUMBER_CHARACTER = 58;
    var HEX_CHARACTER_OFFSET = 87;
    function getPrecomputedHexValuesBuilder() {
      const lookupTable = [];
      return () => {
        if (lookupTable.length === 0) {
          for (let i4 = 0; i4 < 256; i4++) {
            lookupTable.push(i4.toString(16).padStart(2, "0"));
          }
        }
        return lookupTable;
      };
    }
    var getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
    function isBytes(value) {
      return value instanceof Uint8Array;
    }
    exports10.isBytes = isBytes;
    function assertIsBytes(value) {
      (0, assert_1.assert)(isBytes(value), "Value must be a Uint8Array.");
    }
    exports10.assertIsBytes = assertIsBytes;
    function bytesToHex(bytes) {
      assertIsBytes(bytes);
      if (bytes.length === 0) {
        return "0x";
      }
      const lookupTable = getPrecomputedHexValues();
      const hexadecimal = new Array(bytes.length);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        hexadecimal[i4] = lookupTable[bytes[i4]];
      }
      return (0, hex_1.add0x)(hexadecimal.join(""));
    }
    exports10.bytesToHex = bytesToHex;
    function bytesToBigInt(bytes) {
      assertIsBytes(bytes);
      const hexadecimal = bytesToHex(bytes);
      return BigInt(hexadecimal);
    }
    exports10.bytesToBigInt = bytesToBigInt;
    function bytesToSignedBigInt(bytes) {
      assertIsBytes(bytes);
      let value = BigInt(0);
      for (const byte of bytes) {
        value = (value << BigInt(8)) + BigInt(byte);
      }
      return BigInt.asIntN(bytes.length * 8, value);
    }
    exports10.bytesToSignedBigInt = bytesToSignedBigInt;
    function bytesToNumber(bytes) {
      assertIsBytes(bytes);
      const bigint2 = bytesToBigInt(bytes);
      (0, assert_1.assert)(bigint2 <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead.");
      return Number(bigint2);
    }
    exports10.bytesToNumber = bytesToNumber;
    function bytesToString(bytes) {
      assertIsBytes(bytes);
      return new TextDecoder().decode(bytes);
    }
    exports10.bytesToString = bytesToString;
    function hexToBytes(value) {
      var _a;
      if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === "0x") {
        return new Uint8Array();
      }
      (0, hex_1.assertIsHexString)(value);
      const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
      const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
      const bytes = new Uint8Array(normalizedValue.length / 2);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        const c1 = normalizedValue.charCodeAt(i4 * 2);
        const c22 = normalizedValue.charCodeAt(i4 * 2 + 1);
        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
        const n22 = c22 - (c22 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
        bytes[i4] = n1 * 16 + n22;
      }
      return bytes;
    }
    exports10.hexToBytes = hexToBytes;
    function bigIntToBytes(value) {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(value >= BigInt(0), "Value must be a non-negative bigint.");
      const hexadecimal = value.toString(16);
      return hexToBytes(hexadecimal);
    }
    exports10.bigIntToBytes = bigIntToBytes;
    function bigIntFits(value, bytes) {
      (0, assert_1.assert)(bytes > 0);
      const mask2 = value >> BigInt(31);
      return !((~value & mask2) + (value & ~mask2) >> BigInt(bytes * 8 + ~0));
    }
    function signedBigIntToBytes(value, byteLength) {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(typeof byteLength === "number", "Byte length must be a number.");
      (0, assert_1.assert)(byteLength > 0, "Byte length must be greater than 0.");
      (0, assert_1.assert)(bigIntFits(value, byteLength), "Byte length is too small to represent the given value.");
      let numberValue = value;
      const bytes = new Uint8Array(byteLength);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        bytes[i4] = Number(BigInt.asUintN(8, numberValue));
        numberValue >>= BigInt(8);
      }
      return bytes.reverse();
    }
    exports10.signedBigIntToBytes = signedBigIntToBytes;
    function numberToBytes(value) {
      (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
      (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToBytes` instead.");
      const hexadecimal = value.toString(16);
      return hexToBytes(hexadecimal);
    }
    exports10.numberToBytes = numberToBytes;
    function stringToBytes(value) {
      (0, assert_1.assert)(typeof value === "string", "Value must be a string.");
      return new TextEncoder().encode(value);
    }
    exports10.stringToBytes = stringToBytes;
    function valueToBytes(value) {
      if (typeof value === "bigint") {
        return bigIntToBytes(value);
      }
      if (typeof value === "number") {
        return numberToBytes(value);
      }
      if (typeof value === "string") {
        if (value.startsWith("0x")) {
          return hexToBytes(value);
        }
        return stringToBytes(value);
      }
      if (isBytes(value)) {
        return value;
      }
      throw new TypeError(`Unsupported value type: "${typeof value}".`);
    }
    exports10.valueToBytes = valueToBytes;
    function concatBytes(values) {
      const normalizedValues = new Array(values.length);
      let byteLength = 0;
      for (let i4 = 0; i4 < values.length; i4++) {
        const value = valueToBytes(values[i4]);
        normalizedValues[i4] = value;
        byteLength += value.length;
      }
      const bytes = new Uint8Array(byteLength);
      for (let i4 = 0, offset = 0; i4 < normalizedValues.length; i4++) {
        bytes.set(normalizedValues[i4], offset);
        offset += normalizedValues[i4].length;
      }
      return bytes;
    }
    exports10.concatBytes = concatBytes;
    function createDataView(bytes) {
      if (typeof Buffer !== "undefined" && bytes instanceof Buffer) {
        const buffer2 = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer2);
      }
      return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
    exports10.createDataView = createDataView;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/checksum.js
var require_checksum = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/checksum.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.ChecksumStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var base64_1 = require_base64();
    exports10.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/coercers.js
var require_coercers = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/coercers.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.createHex = exports10.createBytes = exports10.createBigInt = exports10.createNumber = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var bytes_1 = require_bytes();
    var hex_1 = require_hex();
    var NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
    var NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
    var BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
    var BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
    var BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
    var HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
    function createNumber(value) {
      try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a number-like value, got "${value}".`);
        }
        throw error;
      }
    }
    exports10.createNumber = createNumber;
    function createBigInt(value) {
      try {
        return (0, superstruct_1.create)(value, BigIntCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports10.createBigInt = createBigInt;
    function createBytes(value) {
      if (typeof value === "string" && value.toLowerCase() === "0x") {
        return new Uint8Array();
      }
      try {
        return (0, superstruct_1.create)(value, BytesCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports10.createBytes = createBytes;
    function createHex(value) {
      if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
        return "0x";
      }
      try {
        return (0, superstruct_1.create)(value, HexCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports10.createHex = createHex;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/collections.js
var require_collections = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/collections.js"(exports10) {
    "use strict";
    var __classPrivateFieldSet = exports10 && exports10.__classPrivateFieldSet || function(receiver, state, value, kind, f4) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f4.call(receiver, value) : f4 ? f4.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports10 && exports10.__classPrivateFieldGet || function(receiver, state, kind, f4) {
      if (kind === "a" && !f4)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f4 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f4 : kind === "a" ? f4.call(receiver) : f4 ? f4.value : state.get(receiver);
    };
    var _FrozenMap_map;
    var _FrozenSet_set;
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.FrozenSet = exports10.FrozenMap = void 0;
    var FrozenMap = class {
      constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
      }
      get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
      }
      [(_FrozenMap_map = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
      }
      entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
      }
      forEach(callbackfn, thisArg) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
      }
      get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
      }
      has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
      }
      keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
      }
      values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
      }
      toString() {
        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key, value]) => `${String(key)} => ${String(value)}`).join(", ")} ` : ""}}`;
      }
    };
    exports10.FrozenMap = FrozenMap;
    var FrozenSet = class {
      constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
      }
      get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
      }
      [(_FrozenSet_set = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
      }
      entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
      }
      forEach(callbackfn, thisArg) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
      }
      has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
      }
      keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
      }
      values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
      }
      toString() {
        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
      }
    };
    exports10.FrozenSet = FrozenSet;
    Object.freeze(FrozenMap);
    Object.freeze(FrozenMap.prototype);
    Object.freeze(FrozenSet);
    Object.freeze(FrozenSet.prototype);
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/encryption-types.js
var require_encryption_types = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/encryption-types.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/json.js
var require_json = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/json.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.getJsonRpcIdValidator = exports10.assertIsJsonRpcError = exports10.isJsonRpcError = exports10.assertIsJsonRpcFailure = exports10.isJsonRpcFailure = exports10.assertIsJsonRpcSuccess = exports10.isJsonRpcSuccess = exports10.assertIsJsonRpcResponse = exports10.isJsonRpcResponse = exports10.assertIsPendingJsonRpcResponse = exports10.isPendingJsonRpcResponse = exports10.JsonRpcResponseStruct = exports10.JsonRpcFailureStruct = exports10.JsonRpcSuccessStruct = exports10.PendingJsonRpcResponseStruct = exports10.assertIsJsonRpcRequest = exports10.isJsonRpcRequest = exports10.assertIsJsonRpcNotification = exports10.isJsonRpcNotification = exports10.JsonRpcNotificationStruct = exports10.JsonRpcRequestStruct = exports10.JsonRpcParamsStruct = exports10.JsonRpcErrorStruct = exports10.JsonRpcIdStruct = exports10.JsonRpcVersionStruct = exports10.jsonrpc2 = exports10.getJsonSize = exports10.isValidJson = exports10.JsonStruct = exports10.UnsafeJsonStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var finiteNumber = () => (0, superstruct_1.define)("finite number", (value) => {
      return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);
    });
    exports10.UnsafeJsonStruct = (0, superstruct_1.union)([
      (0, superstruct_1.literal)(null),
      (0, superstruct_1.boolean)(),
      finiteNumber(),
      (0, superstruct_1.string)(),
      (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports10.UnsafeJsonStruct)),
      (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports10.UnsafeJsonStruct))
    ]);
    exports10.JsonStruct = (0, superstruct_1.define)("Json", (value, context) => {
      function checkStruct(innerValue, struct2) {
        const iterator = struct2.validator(innerValue, context);
        const errors = [...iterator];
        if (errors.length > 0) {
          return errors;
        }
        return true;
      }
      try {
        const unsafeResult = checkStruct(value, exports10.UnsafeJsonStruct);
        if (unsafeResult !== true) {
          return unsafeResult;
        }
        return checkStruct(JSON.parse(JSON.stringify(value)), exports10.UnsafeJsonStruct);
      } catch (error) {
        if (error instanceof RangeError) {
          return "Circular reference detected";
        }
        return false;
      }
    });
    function isValidJson(value) {
      return (0, superstruct_1.is)(value, exports10.JsonStruct);
    }
    exports10.isValidJson = isValidJson;
    function getJsonSize(value) {
      (0, assert_1.assertStruct)(value, exports10.JsonStruct, "Invalid JSON value");
      const json = JSON.stringify(value);
      return new TextEncoder().encode(json).byteLength;
    }
    exports10.getJsonSize = getJsonSize;
    exports10.jsonrpc2 = "2.0";
    exports10.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports10.jsonrpc2);
    exports10.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
    exports10.JsonRpcErrorStruct = (0, superstruct_1.object)({
      code: (0, superstruct_1.integer)(),
      message: (0, superstruct_1.string)(),
      data: (0, superstruct_1.optional)(exports10.JsonStruct),
      stack: (0, superstruct_1.optional)((0, superstruct_1.string)())
    });
    exports10.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports10.JsonStruct), (0, superstruct_1.array)(exports10.JsonStruct)]));
    exports10.JsonRpcRequestStruct = (0, superstruct_1.object)({
      id: exports10.JsonRpcIdStruct,
      jsonrpc: exports10.JsonRpcVersionStruct,
      method: (0, superstruct_1.string)(),
      params: exports10.JsonRpcParamsStruct
    });
    exports10.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports10.JsonRpcRequestStruct, ["id"]);
    function isJsonRpcNotification(value) {
      return (0, superstruct_1.is)(value, exports10.JsonRpcNotificationStruct);
    }
    exports10.isJsonRpcNotification = isJsonRpcNotification;
    function assertIsJsonRpcNotification(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", ErrorWrapper);
    }
    exports10.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
    function isJsonRpcRequest(value) {
      return (0, superstruct_1.is)(value, exports10.JsonRpcRequestStruct);
    }
    exports10.isJsonRpcRequest = isJsonRpcRequest;
    function assertIsJsonRpcRequest(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcRequestStruct, "Invalid JSON-RPC request", ErrorWrapper);
    }
    exports10.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
    exports10.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
      id: exports10.JsonRpcIdStruct,
      jsonrpc: exports10.JsonRpcVersionStruct,
      result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
      error: (0, superstruct_1.optional)(exports10.JsonRpcErrorStruct)
    });
    exports10.JsonRpcSuccessStruct = (0, superstruct_1.object)({
      id: exports10.JsonRpcIdStruct,
      jsonrpc: exports10.JsonRpcVersionStruct,
      result: exports10.JsonStruct
    });
    exports10.JsonRpcFailureStruct = (0, superstruct_1.object)({
      id: exports10.JsonRpcIdStruct,
      jsonrpc: exports10.JsonRpcVersionStruct,
      error: exports10.JsonRpcErrorStruct
    });
    exports10.JsonRpcResponseStruct = (0, superstruct_1.union)([
      exports10.JsonRpcSuccessStruct,
      exports10.JsonRpcFailureStruct
    ]);
    function isPendingJsonRpcResponse(response) {
      return (0, superstruct_1.is)(response, exports10.PendingJsonRpcResponseStruct);
    }
    exports10.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
    function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
      (0, assert_1.assertStruct)(response, exports10.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", ErrorWrapper);
    }
    exports10.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
    function isJsonRpcResponse(response) {
      return (0, superstruct_1.is)(response, exports10.JsonRpcResponseStruct);
    }
    exports10.isJsonRpcResponse = isJsonRpcResponse;
    function assertIsJsonRpcResponse(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcResponseStruct, "Invalid JSON-RPC response", ErrorWrapper);
    }
    exports10.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
    function isJsonRpcSuccess(value) {
      return (0, superstruct_1.is)(value, exports10.JsonRpcSuccessStruct);
    }
    exports10.isJsonRpcSuccess = isJsonRpcSuccess;
    function assertIsJsonRpcSuccess(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", ErrorWrapper);
    }
    exports10.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
    function isJsonRpcFailure(value) {
      return (0, superstruct_1.is)(value, exports10.JsonRpcFailureStruct);
    }
    exports10.isJsonRpcFailure = isJsonRpcFailure;
    function assertIsJsonRpcFailure(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", ErrorWrapper);
    }
    exports10.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
    function isJsonRpcError(value) {
      return (0, superstruct_1.is)(value, exports10.JsonRpcErrorStruct);
    }
    exports10.isJsonRpcError = isJsonRpcError;
    function assertIsJsonRpcError(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports10.JsonRpcErrorStruct, "Invalid JSON-RPC error", ErrorWrapper);
    }
    exports10.assertIsJsonRpcError = assertIsJsonRpcError;
    function getJsonRpcIdValidator(options) {
      const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
      const isValidJsonRpcId = (id) => {
        return Boolean(typeof id === "number" && (permitFractions || Number.isInteger(id)) || typeof id === "string" && (permitEmptyString || id.length > 0) || permitNull && id === null);
      };
      return isValidJsonRpcId;
    }
    exports10.getJsonRpcIdValidator = getJsonRpcIdValidator;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/keyring.js
var require_keyring = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/keyring.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports10, module) {
    var s2 = 1e3;
    var m4 = s2 * 60;
    var h5 = m4 * 60;
    var d3 = h5 * 24;
    var w2 = d3 * 7;
    var y4 = d3 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse3(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n5 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n5 * y4;
        case "weeks":
        case "week":
        case "w":
          return n5 * w2;
        case "days":
        case "day":
        case "d":
          return n5 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n5 * h5;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n5 * m4;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n5 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n5;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h5) {
        return Math.round(ms / h5) + "h";
      }
      if (msAbs >= m4) {
        return Math.round(ms / m4) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h5) {
        return plural(ms, msAbs, h5, "hour");
      }
      if (msAbs >= m4) {
        return plural(ms, msAbs, m4, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n5, name) {
      var isPlural = msAbs >= n5 * 1.5;
      return Math.round(ms / n5) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports10, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i4);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format4) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format4];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v4) => {
            enableOverride = v4;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i4;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i4;
        let len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp2) {
        return regexp2.toString().substring(2, regexp2.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports10, module) {
    exports10.formatArgs = formatArgs;
    exports10.save = save;
    exports10.load = load;
    exports10.useColors = useColors;
    exports10.storage = localstorage();
    exports10.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports10.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c4);
    }
    exports10.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports10.storage.setItem("debug", namespaces);
        } else {
          exports10.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r6;
      try {
        r6 = exports10.storage.getItem("debug");
      } catch (error) {
      }
      if (!r6 && typeof process !== "undefined" && "env" in process) {
        r6 = process.env.DEBUG;
      }
      return r6;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports10);
    var { formatters } = module.exports;
    formatters.j = function(v4) {
      try {
        return JSON.stringify(v4);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/logging.js
var require_logging = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/logging.js"(exports10) {
    "use strict";
    var __importDefault = exports10 && exports10.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.createModuleLogger = exports10.createProjectLogger = void 0;
    var debug_1 = __importDefault(require_browser4());
    var globalLogger = (0, debug_1.default)("metamask");
    function createProjectLogger(projectName) {
      return globalLogger.extend(projectName);
    }
    exports10.createProjectLogger = createProjectLogger;
    function createModuleLogger(projectLogger, moduleName) {
      return projectLogger.extend(moduleName);
    }
    exports10.createModuleLogger = createModuleLogger;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/misc.js
var require_misc = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/misc.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.calculateNumberSize = exports10.calculateStringSize = exports10.isASCII = exports10.isPlainObject = exports10.ESCAPE_CHARACTERS_REGEXP = exports10.JsonSize = exports10.hasProperty = exports10.isObject = exports10.isNullOrUndefined = exports10.isNonEmptyArray = void 0;
    function isNonEmptyArray(value) {
      return Array.isArray(value) && value.length > 0;
    }
    exports10.isNonEmptyArray = isNonEmptyArray;
    function isNullOrUndefined2(value) {
      return value === null || value === void 0;
    }
    exports10.isNullOrUndefined = isNullOrUndefined2;
    function isObject3(value) {
      return Boolean(value) && typeof value === "object" && !Array.isArray(value);
    }
    exports10.isObject = isObject3;
    var hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
    exports10.hasProperty = hasProperty;
    var JsonSize;
    (function(JsonSize2) {
      JsonSize2[JsonSize2["Null"] = 4] = "Null";
      JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
      JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
      JsonSize2[JsonSize2["True"] = 4] = "True";
      JsonSize2[JsonSize2["False"] = 5] = "False";
      JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
      JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
      JsonSize2[JsonSize2["Date"] = 24] = "Date";
    })(JsonSize = exports10.JsonSize || (exports10.JsonSize = {}));
    exports10.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
    function isPlainObject2(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
      } catch (_2) {
        return false;
      }
    }
    exports10.isPlainObject = isPlainObject2;
    function isASCII(character) {
      return character.charCodeAt(0) <= 127;
    }
    exports10.isASCII = isASCII;
    function calculateStringSize(value) {
      var _a;
      const size2 = value.split("").reduce((total, character) => {
        if (isASCII(character)) {
          return total + 1;
        }
        return total + 2;
      }, 0);
      return size2 + ((_a = value.match(exports10.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
    }
    exports10.calculateStringSize = calculateStringSize;
    function calculateNumberSize(value) {
      return value.toString().length;
    }
    exports10.calculateNumberSize = calculateNumberSize;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/number.js
var require_number = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/number.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.hexToBigInt = exports10.hexToNumber = exports10.bigIntToHex = exports10.numberToHex = void 0;
    var assert_1 = require_assert();
    var hex_1 = require_hex();
    var numberToHex = (value) => {
      (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
      (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToHex` instead.");
      return (0, hex_1.add0x)(value.toString(16));
    };
    exports10.numberToHex = numberToHex;
    var bigIntToHex2 = (value) => {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative bigint.");
      return (0, hex_1.add0x)(value.toString(16));
    };
    exports10.bigIntToHex = bigIntToHex2;
    var hexToNumber = (value) => {
      (0, hex_1.assertIsHexString)(value);
      const numberValue = parseInt(value, 16);
      (0, assert_1.assert)(Number.isSafeInteger(numberValue), "Value is not a safe integer. Use `hexToBigInt` instead.");
      return numberValue;
    };
    exports10.hexToNumber = hexToNumber;
    var hexToBigInt = (value) => {
      (0, hex_1.assertIsHexString)(value);
      return BigInt((0, hex_1.add0x)(value));
    };
    exports10.hexToBigInt = hexToBigInt;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/opaque.js
var require_opaque = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/opaque.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/time.js
var require_time = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/time.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.timeSince = exports10.inMilliseconds = exports10.Duration = void 0;
    var Duration;
    (function(Duration2) {
      Duration2[Duration2["Millisecond"] = 1] = "Millisecond";
      Duration2[Duration2["Second"] = 1e3] = "Second";
      Duration2[Duration2["Minute"] = 6e4] = "Minute";
      Duration2[Duration2["Hour"] = 36e5] = "Hour";
      Duration2[Duration2["Day"] = 864e5] = "Day";
      Duration2[Duration2["Week"] = 6048e5] = "Week";
      Duration2[Duration2["Year"] = 31536e6] = "Year";
    })(Duration = exports10.Duration || (exports10.Duration = {}));
    var isNonNegativeInteger = (number2) => Number.isInteger(number2) && number2 >= 0;
    var assertIsNonNegativeInteger = (number2, name) => {
      if (!isNonNegativeInteger(number2)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number2}".`);
      }
    };
    function inMilliseconds(count, duration) {
      assertIsNonNegativeInteger(count, "count");
      return count * duration;
    }
    exports10.inMilliseconds = inMilliseconds;
    function timeSince(timestamp) {
      assertIsNonNegativeInteger(timestamp, "timestamp");
      return Date.now() - timestamp;
    }
    exports10.timeSince = timeSince;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/transaction-types.js
var require_transaction_types = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/transaction-types.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/versions.js
var require_versions = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/versions.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.satisfiesVersionRange = exports10.gtRange = exports10.gtVersion = exports10.assertIsSemVerRange = exports10.assertIsSemVerVersion = exports10.isValidSemVerRange = exports10.isValidSemVerVersion = exports10.VersionRangeStruct = exports10.VersionStruct = void 0;
    var semver_1 = require_semver();
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    exports10.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), "Version", (value) => {
      if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
      }
      return true;
    });
    exports10.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), "Version range", (value) => {
      if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
      }
      return true;
    });
    function isValidSemVerVersion(version2) {
      return (0, superstruct_1.is)(version2, exports10.VersionStruct);
    }
    exports10.isValidSemVerVersion = isValidSemVerVersion;
    function isValidSemVerRange(versionRange) {
      return (0, superstruct_1.is)(versionRange, exports10.VersionRangeStruct);
    }
    exports10.isValidSemVerRange = isValidSemVerRange;
    function assertIsSemVerVersion(version2) {
      (0, assert_1.assertStruct)(version2, exports10.VersionStruct);
    }
    exports10.assertIsSemVerVersion = assertIsSemVerVersion;
    function assertIsSemVerRange(range) {
      (0, assert_1.assertStruct)(range, exports10.VersionRangeStruct);
    }
    exports10.assertIsSemVerRange = assertIsSemVerRange;
    function gtVersion(version1, version2) {
      return (0, semver_1.gt)(version1, version2);
    }
    exports10.gtVersion = gtVersion;
    function gtRange(version2, range) {
      return (0, semver_1.gtr)(version2, range);
    }
    exports10.gtRange = gtRange;
    function satisfiesVersionRange(version2, versionRange) {
      return (0, semver_1.satisfies)(version2, versionRange, {
        includePrerelease: true
      });
    }
    exports10.satisfiesVersionRange = satisfiesVersionRange;
  }
});

// node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@metamask+utils@5.0.2/node_modules/@metamask/utils/dist/index.js"(exports10) {
    "use strict";
    var __createBinding = exports10 && exports10.__createBinding || (Object.create ? function(o5, m4, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m4, k2);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k2];
        } };
      }
      Object.defineProperty(o5, k22, desc);
    } : function(o5, m4, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o5[k22] = m4[k2];
    });
    var __exportStar = exports10 && exports10.__exportStar || function(m4, exports11) {
      for (var p4 in m4)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports11, p4))
          __createBinding(exports11, m4, p4);
    };
    Object.defineProperty(exports10, "__esModule", { value: true });
    __exportStar(require_assert(), exports10);
    __exportStar(require_base64(), exports10);
    __exportStar(require_bytes(), exports10);
    __exportStar(require_checksum(), exports10);
    __exportStar(require_coercers(), exports10);
    __exportStar(require_collections(), exports10);
    __exportStar(require_encryption_types(), exports10);
    __exportStar(require_hex(), exports10);
    __exportStar(require_json(), exports10);
    __exportStar(require_keyring(), exports10);
    __exportStar(require_logging(), exports10);
    __exportStar(require_misc(), exports10);
    __exportStar(require_number(), exports10);
    __exportStar(require_opaque(), exports10);
    __exportStar(require_time(), exports10);
    __exportStar(require_transaction_types(), exports10);
    __exportStar(require_versions(), exports10);
  }
});

// node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/error-constants.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.errorValues = exports10.errorCodes = void 0;
    exports10.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports10.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/utils.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.serializeCause = exports10.serializeError = exports10.isValidCode = exports10.getMessageFromCode = exports10.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var utils_1 = require_dist();
    var error_constants_1 = require_error_constants();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports10.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (isValidCode(code)) {
        const codeString = code.toString();
        if ((0, utils_1.hasProperty)(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports10.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports10.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      return Number.isInteger(code);
    }
    exports10.isValidCode = isValidCode;
    function serializeError4(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {}) {
      if (!(0, utils_1.isJsonRpcError)(fallbackError)) {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      const serialized = buildError(error, fallbackError);
      if (!shouldIncludeStack) {
        delete serialized.stack;
      }
      return serialized;
    }
    exports10.serializeError = serializeError4;
    function buildError(error, fallbackError) {
      if (error && typeof error === "object" && "serialize" in error && typeof error.serialize === "function") {
        return error.serialize();
      }
      if ((0, utils_1.isJsonRpcError)(error)) {
        return error;
      }
      const cause = serializeCause(error);
      const fallbackWithCause = {
        ...fallbackError,
        data: { cause }
      };
      return fallbackWithCause;
    }
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function serializeCause(error) {
      if (Array.isArray(error)) {
        return error.map((entry) => {
          if ((0, utils_1.isValidJson)(entry)) {
            return entry;
          } else if ((0, utils_1.isObject)(entry)) {
            return serializeObject(entry);
          }
          return null;
        });
      } else if ((0, utils_1.isObject)(error)) {
        return serializeObject(error);
      }
      if ((0, utils_1.isValidJson)(error)) {
        return error;
      }
      return null;
    }
    exports10.serializeCause = serializeCause;
    function serializeObject(object2) {
      return Object.getOwnPropertyNames(object2).reduce((acc, key) => {
        const value = object2[key];
        if ((0, utils_1.isValidJson)(value)) {
          acc[key] = value;
        }
        return acc;
      }, {});
    }
  }
});

// node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/classes.js"(exports10) {
    "use strict";
    var __importDefault = exports10 && exports10.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.EthereumProviderError = exports10.JsonRpcError = void 0;
    var utils_1 = require_dist();
    var fast_safe_stringify_1 = __importDefault(require_fast_safe_stringify());
    var utils_2 = require_utils2();
    var JsonRpcError = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a non-empty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Get the error as JSON-serializable object.
       *
       * @returns A plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
          if ((0, utils_1.isPlainObject)(this.data)) {
            serialized.data.cause = (0, utils_2.serializeCause)(this.data.cause);
          }
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Get a string representation of the serialized error, omitting any circular
       * references.
       *
       * @returns A string representation of the serialized error.
       */
      toString() {
        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports10.JsonRpcError = JsonRpcError;
    var EthereumProviderError = class extends JsonRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       *
       * @param code - The JSON-RPC error code. Must be an integer in the
       * `1000 <= n <= 4999` range.
       * @param message - The JSON-RPC error message.
       * @param data - Optional data to include in the error.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports10.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_2, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/errors.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.providerErrors = exports10.rpcErrors = void 0;
    var classes_1 = require_classes();
    var error_constants_1 = require_error_constants();
    var utils_1 = require_utils2();
    exports10.rpcErrors = {
      /**
       * Get a JSON RPC 2.0 Parse (-32700) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      parse: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
      /**
       * Get a JSON RPC 2.0 Invalid Request (-32600) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      invalidRequest: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
      /**
       * Get a JSON RPC 2.0 Invalid Params (-32602) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      invalidParams: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
      /**
       * Get a JSON RPC 2.0 Method Not Found (-32601) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      methodNotFound: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
      /**
       * Get a JSON RPC 2.0 Internal (-32603) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      internal: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
      /**
       * Get a JSON RPC 2.0 Server error.
       * Permits integer error codes in the [ -32099 <= -32005 ] range.
       * Codes -32000 through -32004 are reserved by EIP-1474.
       *
       * @param opts - The error options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      server: (opts) => {
        if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
          throw new Error("Ethereum RPC Server errors must provide single object argument.");
        }
        const { code } = opts;
        if (!Number.isInteger(code) || code > -32005 || code < -32099) {
          throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        }
        return getJsonRpcError(code, opts);
      },
      /**
       * Get an Ethereum JSON RPC Invalid Input (-32000) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      invalidInput: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
      /**
       * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      resourceNotFound: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
      /**
       * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      resourceUnavailable: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
      /**
       * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      transactionRejected: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
      /**
       * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      methodNotSupported: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
      /**
       * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link JsonRpcError} class.
       */
      limitExceeded: (arg) => getJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
    };
    exports10.providerErrors = {
      /**
       * Get an Ethereum Provider User Rejected Request (4001) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      userRejectedRequest: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
      },
      /**
       * Get an Ethereum Provider Unauthorized (4100) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      unauthorized: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
      },
      /**
       * Get an Ethereum Provider Unsupported Method (4200) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      unsupportedMethod: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
      },
      /**
       * Get an Ethereum Provider Not Connected (4900) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      disconnected: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
      },
      /**
       * Get an Ethereum Provider Chain Not Connected (4901) error.
       *
       * @param arg - The error message or options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      chainDisconnected: (arg) => {
        return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
      },
      /**
       * Get a custom Ethereum Provider error.
       *
       * @param opts - The error options bag.
       * @returns An instance of the {@link EthereumProviderError} class.
       */
      custom: (opts) => {
        if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
          throw new Error("Ethereum Provider custom errors must provide single object argument.");
        }
        const { code, message, data } = opts;
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string');
        }
        return new classes_1.EthereumProviderError(code, message, data);
      }
    };
    function getJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.JsonRpcError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message ?? void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/@metamask+rpc-errors@5.1.1/node_modules/@metamask/rpc-errors/dist/index.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.errorCodes = exports10.providerErrors = exports10.rpcErrors = exports10.getMessageFromCode = exports10.serializeError = exports10.serializeCause = exports10.EthereumProviderError = exports10.JsonRpcError = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports10, "JsonRpcError", { enumerable: true, get: function() {
      return classes_1.JsonRpcError;
    } });
    Object.defineProperty(exports10, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports10, "serializeCause", { enumerable: true, get: function() {
      return utils_1.serializeCause;
    } });
    Object.defineProperty(exports10, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports10, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports10, "rpcErrors", { enumerable: true, get: function() {
      return errors_1.rpcErrors;
    } });
    Object.defineProperty(exports10, "providerErrors", { enumerable: true, get: function() {
      return errors_1.providerErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports10, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports10, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k2) {
        wrapper[k2] = fn[k2];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i4 = 0; i4 < args.length; i4++) {
          args[i4] = arguments[i4];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k2) {
            ret[k2] = cb2[k2];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports10, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once3);
    module.exports.strict = wrappy(onceStrict);
    once3.proto = once3(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once3(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once3(fn) {
      var f4 = function() {
        if (f4.called)
          return f4.value;
        f4.called = true;
        return f4.value = fn.apply(this, arguments);
      };
      f4.called = false;
      return f4;
    }
    function onceStrict(fn) {
      var f4 = function() {
        if (f4.called)
          throw new Error(f4.onceError);
        f4.called = true;
        return f4.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f4.onceError = name + " shouldn't be called more than once";
      f4.called = false;
      return f4;
    }
  }
});

// node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS({
  "node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js"(exports10, module) {
    var once3 = require_once();
    var noop2 = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos3 = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos3(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once3(callback || noop2);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos3;
  }
});

// node-modules-polyfills-empty:fs
var require_fs = __commonJS({
  "node-modules-polyfills-empty:fs"(exports10, module) {
    module.exports = {};
  }
});

// node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js"(exports10, module) {
    var once3 = require_once();
    var eos3 = require_end_of_stream2();
    var fs = require_fs();
    var noop2 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop2) || stream instanceof (fs.WriteStream || noop2)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos3(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop2);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump4 = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module.exports = pump4;
  }
});

// node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/classes.js
var require_classes2 = __commonJS({
  "node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/classes.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.EthereumProviderError = exports10.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError2 = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports10.EthereumRpcError = EthereumRpcError2;
    var EthereumProviderError = class extends EthereumRpcError2 {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports10.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_2, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants2 = __commonJS({
  "node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/error-constants.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.errorValues = exports10.errorCodes = void 0;
    exports10.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports10.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/utils.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.serializeError = exports10.isValidCode = exports10.getMessageFromCode = exports10.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants2();
    var classes_1 = require_classes2();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports10.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports10.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports10.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports10.isValidCode = isValidCode;
    function serializeError4(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports10.serializeError = serializeError4;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/errors.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.ethErrors = void 0;
    var classes_1 = require_classes2();
    var utils_1 = require_utils3();
    var error_constants_1 = require_error_constants2();
    exports10.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/eth-rpc-errors@4.0.3/node_modules/eth-rpc-errors/dist/index.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.getMessageFromCode = exports10.serializeError = exports10.EthereumProviderError = exports10.EthereumRpcError = exports10.ethErrors = exports10.errorCodes = void 0;
    var classes_1 = require_classes2();
    Object.defineProperty(exports10, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports10, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils3();
    Object.defineProperty(exports10, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports10, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors3();
    Object.defineProperty(exports10, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants2();
    Object.defineProperty(exports10, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/.pnpm/json-rpc-random-id@1.0.1/node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/.pnpm/json-rpc-random-id@1.0.1/node_modules/json-rpc-random-id/index.js"(exports10, module) {
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max2 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
      return function createRandomId2() {
        idCounter = idCounter % max2;
        return idCounter++;
      };
    }
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_assert.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.output = exports10.exists = exports10.hash = exports10.bytes = exports10.bool = exports10.number = exports10.isBytes = void 0;
    function number2(n5) {
      if (!Number.isSafeInteger(n5) || n5 < 0)
        throw new Error(`positive integer expected, not ${n5}`);
    }
    exports10.number = number2;
    function bool(b4) {
      if (typeof b4 !== "boolean")
        throw new Error(`boolean expected, not ${b4}`);
    }
    exports10.bool = bool;
    function isBytes(a4) {
      return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
    }
    exports10.isBytes = isBytes;
    function bytes(b4, ...lengths) {
      if (!isBytes(b4))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b4.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b4.length}`);
    }
    exports10.bytes = bytes;
    function hash(h5) {
      if (typeof h5 !== "function" || typeof h5.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(h5.outputLen);
      number2(h5.blockLen);
    }
    exports10.hash = hash;
    function exists(instance2, checkFinished = true) {
      if (instance2.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance2.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports10.exists = exists;
    function output(out, instance2) {
      bytes(out);
      const min2 = instance2.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports10.output = output;
    var assert2 = { number: number2, bool, bytes, hash, exists, output };
    exports10.default = assert2;
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/crypto.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.crypto = void 0;
    exports10.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/utils.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.randomBytes = exports10.wrapXOFConstructorWithOpts = exports10.wrapConstructorWithOpts = exports10.wrapConstructor = exports10.checkOpts = exports10.Hash = exports10.concatBytes = exports10.toBytes = exports10.utf8ToBytes = exports10.asyncLoop = exports10.nextTick = exports10.hexToBytes = exports10.bytesToHex = exports10.byteSwap32 = exports10.byteSwapIfBE = exports10.byteSwap = exports10.isLE = exports10.rotl = exports10.rotr = exports10.createView = exports10.u32 = exports10.u8 = exports10.isBytes = void 0;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert2();
    function isBytes(a4) {
      return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
    }
    exports10.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports10.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports10.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports10.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports10.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports10.rotl = rotl;
    exports10.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports10.byteSwap = byteSwap;
    exports10.byteSwapIfBE = exports10.isLE ? (n5) => n5 : (n5) => (0, exports10.byteSwap)(n5);
    function byteSwap32(arr) {
      for (let i4 = 0; i4 < arr.length; i4++) {
        arr[i4] = (0, exports10.byteSwap)(arr[i4]);
      }
    }
    exports10.byteSwap32 = byteSwap32;
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i4) => i4.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i4 = 0; i4 < bytes.length; i4++) {
        hex += hexes[bytes[i4]];
      }
      return hex;
    }
    exports10.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    exports10.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports10.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i4 = 0; i4 < iters; i4++) {
        cb(i4);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports10.nextTick)();
        ts += diff;
      }
    }
    exports10.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports10.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports10.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i4 = 0; i4 < arrays.length; i4++) {
        const a4 = arrays[i4];
        (0, _assert_js_1.bytes)(a4);
        sum += a4.length;
      }
      const res = new Uint8Array(sum);
      for (let i4 = 0, pad = 0; i4 < arrays.length; i4++) {
        const a4 = arrays[i4];
        res.set(a4, pad);
        pad += a4.length;
      }
      return res;
    }
    exports10.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports10.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports10.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports10.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports10.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports10.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports10.randomBytes = randomBytes;
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_md.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.HashMD = exports10.Maj = exports10.Chi = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils4();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h5 = isLE ? 4 : 0;
      const l4 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h5, wh, isLE);
      view.setUint32(byteOffset + l4, wl, isLE);
    }
    var Chi = (a4, b4, c4) => a4 & b4 ^ ~a4 & c4;
    exports10.Chi = Chi;
    var Maj = (a4, b4, c4) => a4 & b4 ^ a4 & c4 ^ b4 & c4;
    exports10.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer: buffer2, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer2.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer: buffer2, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer2[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i4 = pos; i4 < blockLen; i4++)
          buffer2[i4] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i4 = 0; i4 < outLen; i4++)
          oview.setUint32(4 * i4, state[i4], isLE);
      }
      digest() {
        const { buffer: buffer2, outputLen } = this;
        this.digestInto(buffer2);
        const res = buffer2.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished2;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer2);
        return to;
      }
    };
    exports10.HashMD = HashMD;
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha256.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.sha224 = exports10.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils4();
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
        return [A2, B2, C2, D2, E2, F2, G2, H2];
      }
      // prettier-ignore
      set(A2, B2, C2, D2, E2, F2, G2, H2) {
        this.A = A2 | 0;
        this.B = B2 | 0;
        this.C = C2 | 0;
        this.D = D2 | 0;
        this.E = E2 | 0;
        this.F = F2 | 0;
        this.G = G2 | 0;
        this.H = H2 | 0;
      }
      process(view, offset) {
        for (let i4 = 0; i4 < 16; i4++, offset += 4)
          SHA256_W[i4] = view.getUint32(offset, false);
        for (let i4 = 16; i4 < 64; i4++) {
          const W15 = SHA256_W[i4 - 15];
          const W2 = SHA256_W[i4 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
        }
        let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
        for (let i4 = 0; i4 < 64; i4++) {
          const sigma1 = (0, utils_js_1.rotr)(E2, 6) ^ (0, utils_js_1.rotr)(E2, 11) ^ (0, utils_js_1.rotr)(E2, 25);
          const T1 = H2 + sigma1 + (0, _md_js_1.Chi)(E2, F2, G2) + SHA256_K[i4] + SHA256_W[i4] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A2, 2) ^ (0, utils_js_1.rotr)(A2, 13) ^ (0, utils_js_1.rotr)(A2, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A2, B2, C2) | 0;
          H2 = G2;
          G2 = F2;
          F2 = E2;
          E2 = D2 + T1 | 0;
          D2 = C2;
          C2 = B2;
          B2 = A2;
          A2 = T1 + T22 | 0;
        }
        A2 = A2 + this.A | 0;
        B2 = B2 + this.B | 0;
        C2 = C2 + this.C | 0;
        D2 = D2 + this.D | 0;
        E2 = E2 + this.E | 0;
        F2 = F2 + this.F | 0;
        G2 = G2 + this.G | 0;
        H2 = H2 + this.H | 0;
        this.set(A2, B2, C2, D2, E2, F2, G2, H2);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports10.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports10.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/hmac.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.hmac = exports10.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils4();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i4 = 0; i4 < pad.length; i4++)
          pad[i4] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i4 = 0; i4 < pad.length; i4++)
          pad[i4] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished2;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports10.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports10.hmac = hmac;
    exports10.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/utils.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.bitMask = void 0;
    exports10.isBytes = isBytes;
    exports10.abytes = abytes;
    exports10.bytesToHex = bytesToHex;
    exports10.numberToHexUnpadded = numberToHexUnpadded;
    exports10.hexToNumber = hexToNumber;
    exports10.hexToBytes = hexToBytes;
    exports10.bytesToNumberBE = bytesToNumberBE;
    exports10.bytesToNumberLE = bytesToNumberLE;
    exports10.numberToBytesBE = numberToBytesBE;
    exports10.numberToBytesLE = numberToBytesLE;
    exports10.numberToVarBytesBE = numberToVarBytesBE;
    exports10.ensureBytes = ensureBytes;
    exports10.concatBytes = concatBytes;
    exports10.equalBytes = equalBytes;
    exports10.utf8ToBytes = utf8ToBytes;
    exports10.bitLen = bitLen;
    exports10.bitGet = bitGet;
    exports10.bitSet = bitSet;
    exports10.createHmacDrbg = createHmacDrbg;
    exports10.validateObject = validateObject;
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    function isBytes(a4) {
      return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i4) => i4.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i4 = 0; i4 < bytes.length; i4++) {
        hex += hexes[bytes[i4]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n5, len) {
      return hexToBytes(n5.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n5, len) {
      return numberToBytesBE(n5, len).reverse();
    }
    function numberToVarBytesBE(n5) {
      return hexToBytes(numberToHexUnpadded(n5));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e6) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e6}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i4 = 0; i4 < arrays.length; i4++) {
        const a4 = arrays[i4];
        abytes(a4);
        sum += a4.length;
      }
      const res = new Uint8Array(sum);
      for (let i4 = 0, pad = 0; i4 < arrays.length; i4++) {
        const a4 = arrays[i4];
        res.set(a4, pad);
        pad += a4.length;
      }
      return res;
    }
    function equalBytes(a4, b4) {
      if (a4.length !== b4.length)
        return false;
      let diff = 0;
      for (let i4 = 0; i4 < a4.length; i4++)
        diff |= a4[i4] ^ b4[i4];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n5) {
      let len;
      for (len = 0; n5 > _0n; n5 >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n5, pos) {
      return n5 >> BigInt(pos) & _1n;
    }
    function bitSet(n5, pos, value) {
      return n5 | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n5) => (_2n << BigInt(n5 - 1)) - _1n;
    exports10.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v4 = u8n(hashLen);
      let k2 = u8n(hashLen);
      let i4 = 0;
      const reset = () => {
        v4.fill(1);
        k2.fill(0);
        i4 = 0;
      };
      const h5 = (...b4) => hmacFn(k2, v4, ...b4);
      const reseed = (seed = u8n()) => {
        k2 = h5(u8fr([0]), seed);
        v4 = h5();
        if (seed.length === 0)
          return;
        k2 = h5(u8fr([1]), seed);
        v4 = h5();
      };
      const gen = () => {
        if (i4++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v4 = h5();
          const sl = v4.slice();
          out.push(sl);
          len += v4.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object2) => object2.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object2, validators, optValidators = {}) {
      const checkField = (fieldName, type2, isOptional) => {
        const checkVal = validatorFns[type2];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type2}", expected function`);
        const val = object2[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object2)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
        }
      };
      for (const [fieldName, type2] of Object.entries(validators))
        checkField(fieldName, type2, false);
      for (const [fieldName, type2] of Object.entries(optValidators))
        checkField(fieldName, type2, true);
      return object2;
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/modular.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.isNegativeLE = void 0;
    exports10.mod = mod;
    exports10.pow = pow;
    exports10.pow2 = pow2;
    exports10.invert = invert;
    exports10.tonelliShanks = tonelliShanks;
    exports10.FpSqrt = FpSqrt;
    exports10.validateField = validateField;
    exports10.FpPow = FpPow;
    exports10.FpInvertBatch = FpInvertBatch;
    exports10.FpDiv = FpDiv;
    exports10.FpIsSquare = FpIsSquare;
    exports10.nLength = nLength;
    exports10.Field = Field;
    exports10.FpSqrtOdd = FpSqrtOdd;
    exports10.FpSqrtEven = FpSqrtEven;
    exports10.hashToPrivateScalar = hashToPrivateScalar;
    exports10.getFieldBytesLength = getFieldBytesLength;
    exports10.getMinHashLength = getMinHashLength;
    exports10.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils5();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a4, b4) {
      const result = a4 % b4;
      return result >= _0n ? result : b4 + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x2, power, modulo) {
      let res = x2;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number2, modulo) {
      if (number2 === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
      }
      let a4 = mod(number2, modulo);
      let b4 = modulo;
      let x2 = _0n, y4 = _1n, u4 = _1n, v4 = _0n;
      while (a4 !== _0n) {
        const q2 = b4 / a4;
        const r6 = b4 % a4;
        const m4 = x2 - u4 * q2;
        const n5 = y4 - v4 * q2;
        b4 = a4, a4 = r6, x2 = u4, y4 = v4, u4 = m4, v4 = n5;
      }
      const gcd = b4;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x2, modulo);
    }
    function tonelliShanks(P2) {
      const legendreC = (P2 - _1n) / _2n;
      let Q2, S2, Z2;
      for (Q2 = P2 - _1n, S2 = 0; Q2 % _2n === _0n; Q2 /= _2n, S2++)
        ;
      for (Z2 = _2n; Z2 < P2 && pow(Z2, legendreC, P2) !== P2 - _1n; Z2++)
        ;
      if (S2 === 1) {
        const p1div4 = (P2 + _1n) / _4n;
        return function tonelliFast(Fp, n5) {
          const root = Fp.pow(n5, p1div4);
          if (!Fp.eql(Fp.sqr(root), n5))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q2 + _1n) / _2n;
      return function tonelliSlow(Fp, n5) {
        if (Fp.pow(n5, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r6 = S2;
        let g4 = Fp.pow(Fp.mul(Fp.ONE, Z2), Q2);
        let x2 = Fp.pow(n5, Q1div2);
        let b4 = Fp.pow(n5, Q2);
        while (!Fp.eql(b4, Fp.ONE)) {
          if (Fp.eql(b4, Fp.ZERO))
            return Fp.ZERO;
          let m4 = 1;
          for (let t22 = Fp.sqr(b4); m4 < r6; m4++) {
            if (Fp.eql(t22, Fp.ONE))
              break;
            t22 = Fp.sqr(t22);
          }
          const ge = Fp.pow(g4, _1n << BigInt(r6 - m4 - 1));
          g4 = Fp.sqr(ge);
          x2 = Fp.mul(x2, ge);
          b4 = Fp.mul(b4, g4);
          r6 = m4;
        }
        return x2;
      };
    }
    function FpSqrt(P2) {
      if (P2 % _4n === _3n) {
        const p1div4 = (P2 + _1n) / _4n;
        return function sqrt3mod4(Fp, n5) {
          const root = Fp.pow(n5, p1div4);
          if (!Fp.eql(Fp.sqr(root), n5))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P2 % _8n === _5n) {
        const c1 = (P2 - _5n) / _8n;
        return function sqrt5mod8(Fp, n5) {
          const n22 = Fp.mul(n5, _2n);
          const v4 = Fp.pow(n22, c1);
          const nv = Fp.mul(n5, v4);
          const i4 = Fp.mul(Fp.mul(nv, _2n), v4);
          const root = Fp.mul(nv, Fp.sub(i4, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n5))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P2 % _16n === _9n) {
      }
      return tonelliShanks(P2);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports10.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map2, val) => {
        map2[val] = "function";
        return map2;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f4, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f4.ONE;
      if (power === _1n)
        return num;
      let p4 = f4.ONE;
      let d3 = num;
      while (power > _0n) {
        if (power & _1n)
          p4 = f4.mul(p4, d3);
        d3 = f4.sqr(d3);
        power >>= _1n;
      }
      return p4;
    }
    function FpInvertBatch(f4, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i4) => {
        if (f4.is0(num))
          return acc;
        tmp[i4] = acc;
        return f4.mul(acc, num);
      }, f4.ONE);
      const inverted = f4.inv(lastMultiplied);
      nums.reduceRight((acc, num, i4) => {
        if (f4.is0(num))
          return acc;
        tmp[i4] = f4.mul(acc, tmp[i4]);
        return f4.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f4, lhs, rhs) {
      return f4.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f4.ORDER) : f4.inv(rhs));
    }
    function FpIsSquare(f4) {
      const legendreConst = (f4.ORDER - _1n) / _2n;
      return (x2) => {
        const p4 = f4.pow(x2, legendreConst);
        return f4.eql(p4, f4.ZERO) || f4.eql(p4, f4.ONE);
      };
    }
    function nLength(n5, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f4 = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f4, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n5) => sqrtP(f4, n5)),
        invertBatch: (lst) => FpInvertBatch(f4, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a4, b4, c4) => c4 ? b4 : a4,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f4);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/curve.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.wNAF = wNAF;
    exports10.validateBasic = validateBasic;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils5();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c4, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W2) => {
        const windows = Math.ceil(bits / W2) + 1;
        const windowSize = 2 ** (W2 - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n5) {
          let p4 = c4.ZERO;
          let d3 = elm;
          while (n5 > _0n) {
            if (n5 & _1n)
              p4 = p4.add(d3);
            d3 = d3.double();
            n5 >>= _1n;
          }
          return p4;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W2) {
          const { windows, windowSize } = opts(W2);
          const points = [];
          let p4 = elm;
          let base = p4;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p4;
            points.push(base);
            for (let i4 = 1; i4 < windowSize; i4++) {
              base = base.add(p4);
              points.push(base);
            }
            p4 = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W2, precomputes, n5) {
          const { windows, windowSize } = opts(W2);
          let p4 = c4.ZERO;
          let f4 = c4.BASE;
          const mask2 = BigInt(2 ** W2 - 1);
          const maxNumber = 2 ** W2;
          const shiftBy = BigInt(W2);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n5 & mask2);
            n5 >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n5 += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f4 = f4.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p4 = p4.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p: p4, f: f4 };
        },
        wNAFCached(P2, precomputesMap, n5, transform) {
          const W2 = P2._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P2);
          if (!comp) {
            comp = this.precomputeWindow(P2, W2);
            if (W2 !== 1) {
              precomputesMap.set(P2, transform(comp));
            }
          }
          return this.wNAF(W2, comp, n5);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/weierstrass.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.DER = void 0;
    exports10.weierstrassPoints = weierstrassPoints;
    exports10.weierstrass = weierstrass;
    exports10.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports10.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve();
    var mod = require_modular();
    var ut = require_utils5();
    var utils_js_1 = require_utils5();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a: a4 } = opts;
      if (endo) {
        if (!Fp.eql(a4, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports10.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m4 = "") {
          super(m4);
        }
      },
      _parseInt(data) {
        const { Err: E2 } = exports10.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E2("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E2("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E2("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E2("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E2 } = exports10.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l4 = data.length;
        if (l4 < 2 || data[0] != 48)
          throw new E2("Invalid signature tag");
        if (data[1] !== l4 - 2)
          throw new E2("Invalid signature: incorrect length");
        const { d: r6, l: sBytes } = exports10.DER._parseInt(data.subarray(2));
        const { d: s2, l: rBytesLeft } = exports10.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E2("Invalid signature: left bytes after parsing");
        return { r: r6, s: s2 };
      },
      hexFromSig(sig) {
        const slice = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
        const h5 = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s2 = slice(h5(sig.s));
        const r6 = slice(h5(sig.r));
        const shl = s2.length / 2;
        const rhl = r6.length / 2;
        const sl = h5(shl);
        const rl = h5(rhl);
        return `30${h5(rhl + shl + 4)}02${rl}${r6}02${sl}${s2}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a4 = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a4.x), Fp.toBytes(a4.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x2 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y4 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x: x2, y: y4 };
      });
      function weierstrassEquation(x2) {
        const { a: a4, b: b4 } = CURVE;
        const x22 = Fp.sqr(x2);
        const x3 = Fp.mul(x22, x2);
        return Fp.add(Fp.add(x3, Fp.mul(x2, a4)), b4);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n5 } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n5);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p4) {
          const { x: x2, y: y4 } = p4 || {};
          if (!p4 || !Fp.isValid(x2) || !Fp.isValid(y4))
            throw new Error("invalid affine point");
          if (p4 instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i4) => Fp.eql(i4, Fp.ZERO);
          if (is0(x2) && is0(y4))
            return Point.ZERO;
          return new Point(x2, y4, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p4) => p4.pz));
          return points.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P2 = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P2.assertValidity();
          return P2;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x: x2, y: y4 } = this.toAffine();
          if (!Fp.isValid(x2) || !Fp.isValid(y4))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y4);
          const right = weierstrassEquation(x2);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y: y4 } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y4);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X22, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X22, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a: a4, b: b4 } = CURVE;
          const b32 = Fp.mul(b4, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t22 = Fp.mul(Z1, Z1);
          let t32 = Fp.mul(X1, Y1);
          t32 = Fp.add(t32, t32);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a4, Z3);
          Y3 = Fp.mul(b32, t22);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t32, X3);
          Z3 = Fp.mul(b32, Z3);
          t22 = Fp.mul(a4, t22);
          t32 = Fp.sub(t0, t22);
          t32 = Fp.mul(a4, t32);
          t32 = Fp.add(t32, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t22);
          t0 = Fp.mul(t0, t32);
          Y3 = Fp.add(Y3, t0);
          t22 = Fp.mul(Y1, Z1);
          t22 = Fp.add(t22, t22);
          t0 = Fp.mul(t22, t32);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t22, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X22, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a4 = CURVE.a;
          const b32 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X22);
          let t1 = Fp.mul(Y1, Y2);
          let t22 = Fp.mul(Z1, Z2);
          let t32 = Fp.add(X1, Y1);
          let t4 = Fp.add(X22, Y2);
          t32 = Fp.mul(t32, t4);
          t4 = Fp.add(t0, t1);
          t32 = Fp.sub(t32, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X22, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t22);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t22);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a4, t4);
          X3 = Fp.mul(b32, t22);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t22 = Fp.mul(a4, t22);
          t4 = Fp.mul(b32, t4);
          t1 = Fp.add(t1, t22);
          t22 = Fp.sub(t0, t22);
          t22 = Fp.mul(a4, t22);
          t4 = Fp.add(t4, t22);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t32, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t32, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n5) {
          return wnaf.wNAFCached(this, pointPrecomputes, n5, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p4) => p4.pz));
            return comp.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n5) {
          const I2 = Point.ZERO;
          if (n5 === _0n)
            return I2;
          assertGE(n5);
          if (n5 === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n5);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
          let k1p = I2;
          let k2p = I2;
          let d3 = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d3);
            if (k2 & _1n)
              k2p = k2p.add(d3);
            d3 = d3.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n5 = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n5);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p: p4, f: f4 } = this.wNAF(n5);
            point = p4;
            fake = f4;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q2, a4, b4) {
          const G2 = Point.BASE;
          const mul = (P2, a5) => a5 === _0n || a5 === _1n || !P2.equals(G2) ? P2.multiplyUnsafe(a5) : P2.multiply(a5);
          const sum = mul(this, a4).add(mul(Q2, b4));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x2, py: y4, pz: z2 } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z2);
          const ax = Fp.mul(x2, iz);
          const ay = Fp.mul(y4, iz);
          const zz = Fp.mul(z2, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a4) {
        return mod.mod(a4, CURVE_ORDER);
      }
      function invN(a4) {
        return mod.invert(a4, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a4 = point.toAffine();
          const x2 = Fp.toBytes(a4.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
          } else {
            return cat(Uint8Array.from([4]), x2, Fp.toBytes(a4.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x2 = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x2))
              throw new Error("Point is not on curve");
            const y22 = weierstrassEquation(x2);
            let y4;
            try {
              y4 = Fp.sqrt(y22);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y4 & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y4 = Fp.neg(y4);
            return { x: x2, y: y4 };
          } else if (len === uncompressedLen && head === 4) {
            const x2 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y4 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x: x2, y: y4 };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number2) {
        const HALF = CURVE_ORDER >> _1n;
        return number2 > HALF;
      }
      function normalizeS(s2) {
        return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
      }
      const slcNum = (b4, from, to) => ut.bytesToNumberBE(b4.slice(from, to));
      class Signature {
        constructor(r6, s2, recovery) {
          this.r = r6;
          this.s = s2;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l4 = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l4 * 2);
          return new Signature(slcNum(hex, 0, l4), slcNum(hex, l4, 2 * l4));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r: r6, s: s2 } = exports10.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r6, s2);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r6, s: s2, recovery: rec } = this;
          const h5 = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r6 + CURVE.n : r6;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R2 = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h5 * ir);
          const u22 = modN(s2 * ir);
          const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u22);
          if (!Q2)
            throw new Error("point at infinify");
          Q2.assertValidity();
          return Q2;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports10.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b4 = Point.fromHex(publicB);
        return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k2) => k2 in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d3 = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d3), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e6 = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e6));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m4 = h1int;
        function k2sig(kBytes) {
          const k2 = bits2int(kBytes);
          if (!isWithinCurveOrder(k2))
            return;
          const ik = invN(k2);
          const q2 = Point.BASE.multiply(k2).toAffine();
          const r6 = modN(q2.x);
          if (r6 === _0n)
            return;
          const s2 = modN(ik * modN(m4 + r6 * d3));
          if (s2 === _0n)
            return;
          let recovery = (q2.x === r6 ? 0 : 2) | Number(q2.y & _1n);
          let normS = s2;
          if (lowS && isBiggerThanHalfOrder(s2)) {
            normS = normalizeS(s2);
            recovery ^= 1;
          }
          return new Signature(r6, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C2 = CURVE;
        const drbg = ut.createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P2;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports10.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r7, s: s3 } = sg;
            _sig = new Signature(r7, s3);
          } else {
            throw new Error("PARSE");
          }
          P2 = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r6, s: s2 } = _sig;
        const h5 = bits2int_modN(msgHash);
        const is2 = invN(s2);
        const u1 = modN(h5 * is2);
        const u22 = modN(r6 * is2);
        const R2 = Point.BASE.multiplyAndAddUnsafe(P2, u1, u22)?.toAffine();
        if (!R2)
          return false;
        const v4 = modN(R2.x);
        return v4 === r6;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z2) {
      const q2 = Fp.ORDER;
      let l4 = _0n;
      for (let o5 = q2 - _1n; o5 % _2n === _0n; o5 /= _2n)
        l4 += _1n;
      const c1 = l4;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c22 = (q2 - _1n) / _2n_pow_c1;
      const c32 = (c22 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z2, c22);
      const c7 = Fp.pow(Z2, (c22 + _1n) / _2n);
      let sqrtRatio = (u4, v4) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v4, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v4);
        let tv5 = Fp.mul(u4, tv3);
        tv5 = Fp.pow(tv5, c32);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v4);
        tv3 = Fp.mul(tv5, u4);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i4 = c1; i4 > _1n; i4--) {
          let tv52 = i4 - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c23 = Fp.sqrt(Fp.neg(Z2));
        sqrtRatio = (u4, v4) => {
          let tv1 = Fp.sqr(v4);
          const tv2 = Fp.mul(u4, v4);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y22 = Fp.mul(y1, c23);
          const tv3 = Fp.mul(Fp.sqr(y1), v4);
          const isQR = Fp.eql(tv3, u4);
          let y4 = Fp.cmov(y22, y1, isQR);
          return { isValid: isQR, value: y4 };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u4) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x2, y4;
        tv1 = Fp.sqr(u4);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x2 = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y4 = Fp.mul(tv1, u4);
        y4 = Fp.mul(y4, value);
        x2 = Fp.cmov(x2, tv3, isValid);
        y4 = Fp.cmov(y4, value, isValid);
        const e1 = Fp.isOdd(u4) === Fp.isOdd(y4);
        y4 = Fp.cmov(Fp.neg(y4), y4, e1);
        x2 = Fp.div(x2, tv4);
        return { x: x2, y: y4 };
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/_shortw_utils.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.getHash = getHash;
    exports10.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils4();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create2 = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create2(defHash), create: create2 });
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.expand_message_xmd = expand_message_xmd;
    exports10.expand_message_xof = expand_message_xof;
    exports10.hash_to_field = hash_to_field;
    exports10.isogenyMap = isogenyMap;
    exports10.createHasher = createHasher;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils5();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i4 = length - 1; i4 >= 0; i4--) {
        res[i4] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a4, b4) {
      const arr = new Uint8Array(a4.length);
      for (let i4 = 0; i4 < a4.length; i4++) {
        arr[i4] = a4[i4] ^ b4[i4];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H2) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H2((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H2;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b4 = new Array(ell);
      const b_0 = H2((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b4[0] = H2((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i4 = 1; i4 <= ell; i4++) {
        const args = [strxor(b_0, b4[i4 - 1]), i2osp(i4 + 1, 1), DST_prime];
        b4[i4] = H2((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b4);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k2, H2) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k2 / 8);
        DST = H2.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H2.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p: p4, k: k2, m: m4, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p4.toString(2).length;
      const L2 = Math.ceil((log2p + k2) / 8);
      const len_in_bytes = count * m4 * L2;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k2, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u4 = new Array(count);
      for (let i4 = 0; i4 < count; i4++) {
        const e6 = new Array(m4);
        for (let j2 = 0; j2 < m4; j2++) {
          const elm_offset = L2 * (j2 + i4 * m4);
          const tv = prb.subarray(elm_offset, elm_offset + L2);
          e6[j2] = (0, modular_js_1.mod)(os2ip(tv), p4);
        }
        u4[i4] = e6;
      }
      return u4;
    }
    function isogenyMap(field, map2) {
      const COEFF = map2.map((i4) => Array.from(i4).reverse());
      return (x2, y4) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i4) => field.add(field.mul(acc, x2), i4)));
        x2 = field.div(xNum, xDen);
        y4 = field.mul(y4, field.div(yNum, yDen));
        return { x: x2, y: y4 };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u4 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u4[0]));
          const u1 = Point.fromAffine(mapToCurve(u4[1]));
          const P2 = u0.add(u1).clearCofactor();
          P2.assertValidity();
          return P2;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u4 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P2 = Point.fromAffine(mapToCurve(u4[0])).clearCofactor();
          P2.assertValidity();
          return P2;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i4 of scalars)
            if (typeof i4 !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i4} in array`);
          const P2 = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P2.assertValidity();
          return P2;
        }
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.4.2/node_modules/@noble/curves/secp256k1.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.encodeToCurve = exports10.hashToCurve = exports10.schnorr = exports10.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils4();
    var _shortw_utils_js_1 = require_shortw_utils();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils5();
    var weierstrass_js_1 = require_weierstrass();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a4, b4) => (a4 + b4 / _2n) / b4;
    function sqrtMod(y4) {
      const P2 = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b22 = y4 * y4 * y4 % P2;
      const b32 = b22 * b22 * y4 % P2;
      const b6 = (0, modular_js_1.pow2)(b32, _3n, P2) * b32 % P2;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P2) * b32 % P2;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P2) * b22 % P2;
      const b222 = (0, modular_js_1.pow2)(b11, _11n, P2) * b11 % P2;
      const b44 = (0, modular_js_1.pow2)(b222, _22n, P2) * b222 % P2;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P2) * b44 % P2;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P2) * b88 % P2;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P2) * b44 % P2;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P2) * b32 % P2;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P2) * b222 % P2;
      const t22 = (0, modular_js_1.pow2)(t1, _6n, P2) * b22 % P2;
      const root = (0, modular_js_1.pow2)(t22, _2n, P2);
      if (!Fp.eql(Fp.sqr(root), y4))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports10.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k2) => {
          const n5 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b22 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b22 * k2, n5);
          const c22 = divNearest(-b1 * k2, n5);
          let k1 = (0, modular_js_1.mod)(k2 - c1 * a1 - c22 * a22, n5);
          let k22 = (0, modular_js_1.mod)(-c1 * b1 - c22 * b22, n5);
          const k1neg = k1 > POW_2_128;
          const k2neg = k22 > POW_2_128;
          if (k1neg)
            k1 = n5 - k1;
          if (k2neg)
            k22 = n5 - k22;
          if (k1 > POW_2_128 || k22 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k2);
          }
          return { k1neg, k1, k2neg, k2: k22 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x2) => typeof x2 === "bigint" && _0n < x2 && x2 < secp256k1P;
    var ge = (x2) => typeof x2 === "bigint" && _0n < x2 && x2 < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages2) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c4) => c4.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages2));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n5) => (0, utils_js_1.numberToBytesBE)(n5, 32);
    var modP = (x2) => (0, modular_js_1.mod)(x2, secp256k1P);
    var modN = (x2) => (0, modular_js_1.mod)(x2, secp256k1N);
    var Point = exports10.secp256k1.ProjectivePoint;
    var GmulAdd = (Q2, a4, b4) => Point.BASE.multiplyAndAddUnsafe(Q2, a4, b4);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports10.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p4 = Point.fromPrivateKey(d_);
      const scalar = p4.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p4) };
    }
    function lift_x(x2) {
      if (!fe(x2))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x2 * x2);
      const c4 = modP(xx * x2 + BigInt(7));
      let y4 = sqrtMod(c4);
      if (y4 % _2n !== _0n)
        y4 = modP(-y4);
      const p4 = new Point(x2, y4, _1n);
      p4.assertValidity();
      return p4;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m4 = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d3 } = schnorrGetExtPubKey(privateKey);
      const a4 = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t4 = numTo32b(d3 ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a4)));
      const rand = taggedHash("BIP0340/nonce", t4, px, m4);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k2 } = schnorrGetExtPubKey(k_);
      const e6 = challenge(rx, px, m4);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k2 + e6 * d3)), 32);
      if (!schnorrVerify(sig, m4, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m4 = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P2 = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r6 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r6))
          return false;
        const s2 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s2))
          return false;
        const e6 = challenge(numTo32b(r6), pointToBytes(P2), m4);
        const R2 = GmulAdd(P2, s2, modN(-e6));
        if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r6)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports10.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports10.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i4) => i4.map((j2) => BigInt(j2)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports10.secp256k1.ProjectivePoint, (scalars) => {
      const { x: x2, y: y4 } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x2, y4);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports10.hashToCurve = (() => htf.hashToCurve)();
    exports10.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/secp256k1.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.secp256k1 = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports10, "secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.secp256k1;
    } });
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/constants.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.MAX_WITHDRAWALS_PER_PAYLOAD = exports10.RLP_EMPTY_STRING = exports10.KECCAK256_RLP = exports10.KECCAK256_RLP_S = exports10.KECCAK256_RLP_ARRAY = exports10.KECCAK256_RLP_ARRAY_S = exports10.KECCAK256_NULL = exports10.KECCAK256_NULL_S = exports10.TWO_POW256 = exports10.SECP256K1_ORDER_DIV_2 = exports10.SECP256K1_ORDER = exports10.MAX_INTEGER_BIGINT = exports10.MAX_INTEGER = exports10.MAX_UINT64 = void 0;
    var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
    var secp256k1_1 = require_secp256k12();
    exports10.MAX_UINT64 = BigInt("0xffffffffffffffff");
    exports10.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports10.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports10.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
    exports10.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
    exports10.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    exports10.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports10.KECCAK256_NULL = buffer_1.Buffer.from(exports10.KECCAK256_NULL_S, "hex");
    exports10.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports10.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports10.KECCAK256_RLP_ARRAY_S, "hex");
    exports10.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports10.KECCAK256_RLP = buffer_1.Buffer.from(exports10.KECCAK256_RLP_S, "hex");
    exports10.RLP_EMPTY_STRING = buffer_1.Buffer.from([128]);
    exports10.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/units.js
var require_units = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/units.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.GWEI_TO_WEI = void 0;
    exports10.GWEI_TO_WEI = BigInt(1e9);
  }
});

// node_modules/.pnpm/@ethereumjs+rlp@4.0.1/node_modules/@ethereumjs/rlp/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/@ethereumjs+rlp@4.0.1/node_modules/@ethereumjs/rlp/dist/index.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.RLP = exports10.utils = exports10.decode = exports10.encode = void 0;
    function encode(input) {
      if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i4 = 0; i4 < input.length; i4++) {
          const encoded = encode(input[i4]);
          output.push(encoded);
          outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
    }
    exports10.encode = encode;
    function safeSlice(input, start, end) {
      if (end > input.length) {
        throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
      }
      return input.slice(start, end);
    }
    function decodeLength(v4) {
      if (v4[0] === 0) {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseHexByte(bytesToHex(v4));
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
    }
    function decode(input, stream = false) {
      if (typeof input === "undefined" || input === null || input.length === 0) {
        return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid RLP: remainder must be zero");
      }
      return decoded.data;
    }
    exports10.decode = decode;
    function _decode(input) {
      let length, llength, data, innerRemainder, d3;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Uint8Array.from([]);
        } else {
          data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = safeSlice(input, llength, length + llength);
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
          d3 = _decode(innerRemainder);
          decoded.push(d3.data);
          innerRemainder = d3.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
          throw new Error("invalid RLP: encoded list too short");
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid RLP: total length is larger than the data");
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
          d3 = _decode(innerRemainder);
          decoded.push(d3.data);
          innerRemainder = d3.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    var cachedHexes = Array.from({ length: 256 }, (_v, i4) => i4.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      let hex = "";
      for (let i4 = 0; i4 < uint8a.length; i4++) {
        hex += cachedHexes[uint8a[i4]];
      }
      return hex;
    }
    function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
        throw new Error("Invalid byte sequence");
      return byte;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array2 = new Uint8Array(hex.length / 2);
      for (let i4 = 0; i4 < array2.length; i4++) {
        const j2 = i4 * 2;
        array2[i4] = parseHexByte(hex.slice(j2, j2 + 2));
      }
      return array2;
    }
    function concatBytes(...arrays) {
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a4, arr) => a4 + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i4 = 0, pad = 0; i4 < arrays.length; i4++) {
        const arr = arrays[i4];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
    }
    function numberToHex(integer2) {
      if (integer2 < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      const hex = integer2.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
    }
    function padToEven(a4) {
      return a4.length % 2 ? `0${a4}` : a4;
    }
    function isHexPrefixed(str) {
      return str.length >= 2 && str[0] === "0" && str[1] === "x";
    }
    function stripHexPrefix2(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function toBytes(v4) {
      if (v4 instanceof Uint8Array) {
        return v4;
      }
      if (typeof v4 === "string") {
        if (isHexPrefixed(v4)) {
          return hexToBytes(padToEven(stripHexPrefix2(v4)));
        }
        return utf8ToBytes(v4);
      }
      if (typeof v4 === "number" || typeof v4 === "bigint") {
        if (!v4) {
          return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v4));
      }
      if (v4 === null || v4 === void 0) {
        return Uint8Array.from([]);
      }
      throw new Error("toBytes: received unsupported type " + typeof v4);
    }
    exports10.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes
    };
    exports10.RLP = { encode, decode };
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/_u64.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.add5L = exports10.add5H = exports10.add4H = exports10.add4L = exports10.add3H = exports10.add3L = exports10.add = exports10.rotlBL = exports10.rotlBH = exports10.rotlSL = exports10.rotlSH = exports10.rotr32L = exports10.rotr32H = exports10.rotrBL = exports10.rotrBH = exports10.rotrSL = exports10.rotrSH = exports10.shrSL = exports10.shrSH = exports10.toBig = exports10.split = exports10.fromBig = void 0;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n5, le = false) {
      if (le)
        return { h: Number(n5 & U32_MASK64), l: Number(n5 >> _32n & U32_MASK64) };
      return { h: Number(n5 >> _32n & U32_MASK64) | 0, l: Number(n5 & U32_MASK64) | 0 };
    }
    exports10.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i4 = 0; i4 < lst.length; i4++) {
        const { h: h5, l: l4 } = fromBig(lst[i4], le);
        [Ah[i4], Al[i4]] = [h5, l4];
      }
      return [Ah, Al];
    }
    exports10.split = split;
    var toBig = (h5, l4) => BigInt(h5 >>> 0) << _32n | BigInt(l4 >>> 0);
    exports10.toBig = toBig;
    var shrSH = (h5, _l, s2) => h5 >>> s2;
    exports10.shrSH = shrSH;
    var shrSL = (h5, l4, s2) => h5 << 32 - s2 | l4 >>> s2;
    exports10.shrSL = shrSL;
    var rotrSH = (h5, l4, s2) => h5 >>> s2 | l4 << 32 - s2;
    exports10.rotrSH = rotrSH;
    var rotrSL = (h5, l4, s2) => h5 << 32 - s2 | l4 >>> s2;
    exports10.rotrSL = rotrSL;
    var rotrBH = (h5, l4, s2) => h5 << 64 - s2 | l4 >>> s2 - 32;
    exports10.rotrBH = rotrBH;
    var rotrBL = (h5, l4, s2) => h5 >>> s2 - 32 | l4 << 64 - s2;
    exports10.rotrBL = rotrBL;
    var rotr32H = (_h, l4) => l4;
    exports10.rotr32H = rotr32H;
    var rotr32L = (h5, _l) => h5;
    exports10.rotr32L = rotr32L;
    var rotlSH = (h5, l4, s2) => h5 << s2 | l4 >>> 32 - s2;
    exports10.rotlSH = rotlSH;
    var rotlSL = (h5, l4, s2) => l4 << s2 | h5 >>> 32 - s2;
    exports10.rotlSL = rotlSL;
    var rotlBH = (h5, l4, s2) => l4 << s2 - 32 | h5 >>> 64 - s2;
    exports10.rotlBH = rotlBH;
    var rotlBL = (h5, l4, s2) => h5 << s2 - 32 | l4 >>> 64 - s2;
    exports10.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l4 = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l4 / 2 ** 32 | 0) | 0, l: l4 | 0 };
    }
    exports10.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports10.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports10.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports10.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports10.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports10.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports10.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports10.default = u64;
  }
});

// node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha3.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.shake256 = exports10.shake128 = exports10.keccak_512 = exports10.keccak_384 = exports10.keccak_256 = exports10.keccak_224 = exports10.sha3_512 = exports10.sha3_384 = exports10.sha3_256 = exports10.sha3_224 = exports10.Keccak = exports10.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils4();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _256n = /* @__PURE__ */ BigInt(256);
    var _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R2 = _1n, x2 = 1, y4 = 0; round < 24; round++) {
      [x2, y4] = [y4, (2 * x2 + 3 * y4) % 5];
      SHA3_PI.push(2 * (5 * y4 + x2));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t4 = _0n;
      for (let j2 = 0; j2 < 7; j2++) {
        R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
        if (R2 & _2n)
          t4 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
      }
      _SHA3_IOTA.push(t4);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h5, l4, s2) => s2 > 32 ? (0, _u64_js_1.rotlBH)(h5, l4, s2) : (0, _u64_js_1.rotlSH)(h5, l4, s2);
    var rotlL = (h5, l4, s2) => s2 > 32 ? (0, _u64_js_1.rotlBL)(h5, l4, s2) : (0, _u64_js_1.rotlSL)(h5, l4, s2);
    function keccakP(s2, rounds = 24) {
      const B2 = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x2 = 0; x2 < 10; x2++)
          B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
        for (let x2 = 0; x2 < 10; x2 += 2) {
          const idx1 = (x2 + 8) % 10;
          const idx0 = (x2 + 2) % 10;
          const B0 = B2[idx0];
          const B1 = B2[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B2[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
          for (let y4 = 0; y4 < 50; y4 += 10) {
            s2[x2 + y4] ^= Th;
            s2[x2 + y4 + 1] ^= Tl;
          }
        }
        let curH = s2[2];
        let curL = s2[3];
        for (let t4 = 0; t4 < 24; t4++) {
          const shift = SHA3_ROTL[t4];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t4];
          curH = s2[PI];
          curL = s2[PI + 1];
          s2[PI] = Th;
          s2[PI + 1] = Tl;
        }
        for (let y4 = 0; y4 < 50; y4 += 10) {
          for (let x2 = 0; x2 < 10; x2++)
            B2[x2] = s2[y4 + x2];
          for (let x2 = 0; x2 < 10; x2++)
            s2[y4 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
        }
        s2[0] ^= SHA3_IOTA_H[round];
        s2[1] ^= SHA3_IOTA_L[round];
      }
      B2.fill(0);
    }
    exports10.keccakP = keccakP;
    var Keccak = class extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i4 = 0; i4 < take; i4++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports10.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports10.sha3_224 = gen(6, 144, 224 / 8);
    exports10.sha3_256 = gen(6, 136, 256 / 8);
    exports10.sha3_384 = gen(6, 104, 384 / 8);
    exports10.sha3_512 = gen(6, 72, 512 / 8);
    exports10.keccak_224 = gen(1, 144, 224 / 8);
    exports10.keccak_256 = gen(1, 136, 256 / 8);
    exports10.keccak_384 = gen(1, 104, 384 / 8);
    exports10.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports10.shake128 = genShake(31, 168, 128 / 8);
    exports10.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/utils.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/utils.js"(exports10, module) {
    "use strict";
    var __importDefault = exports10 && exports10.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.crypto = exports10.utf8ToBytes = exports10.createView = exports10.concatBytes = exports10.toHex = exports10.bytesToHex = exports10.assertBytes = exports10.assertBool = void 0;
    exports10.bytesToUtf8 = bytesToUtf8;
    exports10.hexToBytes = hexToBytes;
    exports10.equalsBytes = equalsBytes;
    exports10.wrapHash = wrapHash;
    var _assert_1 = __importDefault(require_assert2());
    var utils_1 = require_utils4();
    var assertBool = _assert_1.default.bool;
    exports10.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports10.assertBytes = assertBytes;
    var utils_2 = require_utils4();
    Object.defineProperty(exports10, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports10, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports10, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports10, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports10, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    function equalsBytes(a4, b4) {
      if (a4.length !== b4.length) {
        return false;
      }
      for (let i4 = 0; i4 < a4.length; i4++) {
        if (a4[i4] !== b4[i4]) {
          return false;
        }
      }
      return true;
    }
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports10.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/.pnpm/ethereum-cryptography@2.2.1/node_modules/ethereum-cryptography/keccak.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.keccak512 = exports10.keccak384 = exports10.keccak256 = exports10.keccak224 = void 0;
    var sha3_1 = require_sha3();
    var utils_js_1 = require_utils6();
    exports10.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports10.keccak256 = (() => {
      const k2 = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k2.create = sha3_1.keccak_256.create;
      return k2;
    })();
    exports10.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports10.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/internal.js
var require_internal = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/internal.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.isHexString = exports10.getKeys = exports10.fromAscii = exports10.fromUtf8 = exports10.toAscii = exports10.arrayContainsArray = exports10.getBinarySize = exports10.padToEven = exports10.stripHexPrefix = exports10.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports10.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix2 = (str) => {
      if (typeof str !== "string")
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports10.stripHexPrefix = stripHexPrefix2;
    function padToEven(value) {
      let a4 = value;
      if (typeof a4 !== "string") {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a4}`);
      }
      if (a4.length % 2)
        a4 = `0${a4}`;
      return a4;
    }
    exports10.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports10.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? "some" : "every"]((value) => superset.indexOf(value) >= 0);
    }
    exports10.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      let str = "";
      let i4 = 0;
      const l4 = hex.length;
      if (hex.substring(0, 2) === "0x")
        i4 = 2;
      for (; i4 < l4; i4 += 2) {
        const code = parseInt(hex.substr(i4, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports10.toAscii = toAscii;
    function fromUtf8(stringValue) {
      const str = Buffer.from(stringValue, "utf8");
      return `0x${padToEven(str.toString("hex")).replace(/^0+|0+$/g, "")}`;
    }
    exports10.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      let hex = "";
      for (let i4 = 0; i4 < stringValue.length; i4++) {
        const code = stringValue.charCodeAt(i4);
        const n5 = code.toString(16);
        hex += n5.length < 2 ? `0${n5}` : n5;
      }
      return `0x${hex}`;
    }
    exports10.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== "string") {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i4 = 0; i4 < params.length; i4++) {
        let value = params[i4][key];
        if (allowEmpty === true && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
      }
      return result;
    }
    exports10.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports10.isHexString = isHexString;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/helpers.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.assertIsString = exports10.assertIsArray = exports10.assertIsBuffer = exports10.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports10.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports10.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports10.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports10.assertIsString = assertIsString;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/bytes.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.intToUnpaddedBuffer = exports10.bigIntToUnpaddedBuffer = exports10.bigIntToHex = exports10.bufArrToArr = exports10.arrToBufArr = exports10.validateNoLeadingZeroes = exports10.baToJSON = exports10.toUtf8 = exports10.short = exports10.addHexPrefix = exports10.toUnsigned = exports10.fromSigned = exports10.bufferToInt = exports10.bigIntToBuffer = exports10.bufferToBigInt = exports10.bufferToHex = exports10.toBuffer = exports10.unpadHexString = exports10.unpadArray = exports10.unpadBuffer = exports10.setLengthRight = exports10.setLengthLeft = exports10.zeros = exports10.intToBuffer = exports10.intToHex = void 0;
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var intToHex = function(i4) {
      if (!Number.isSafeInteger(i4) || i4 < 0) {
        throw new Error(`Received an invalid integer type: ${i4}`);
      }
      return `0x${i4.toString(16)}`;
    };
    exports10.intToHex = intToHex;
    var intToBuffer = function(i4) {
      const hex = (0, exports10.intToHex)(i4);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports10.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports10.zeros = zeros;
    var setLength = function(msg, length, right) {
      const buf = (0, exports10.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports10.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports10.setLengthRight = setLengthRight;
    var stripZeros = function(a4) {
      let first = a4[0];
      while (a4.length > 0 && first.toString() === "0") {
        a4 = a4.slice(1);
        first = a4[0];
      }
      return a4;
    };
    var unpadBuffer = function(a4) {
      (0, helpers_1.assertIsBuffer)(a4);
      return stripZeros(a4);
    };
    exports10.unpadBuffer = unpadBuffer;
    var unpadArray = function(a4) {
      (0, helpers_1.assertIsArray)(a4);
      return stripZeros(a4);
    };
    exports10.unpadArray = unpadArray;
    var unpadHexString = function(a4) {
      (0, helpers_1.assertIsHexString)(a4);
      a4 = (0, internal_1.stripHexPrefix)(a4);
      return "0x" + stripZeros(a4);
    };
    exports10.unpadHexString = unpadHexString;
    var toBuffer = function(v4) {
      if (v4 === null || v4 === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v4)) {
        return Buffer.from(v4);
      }
      if (Array.isArray(v4) || v4 instanceof Uint8Array) {
        return Buffer.from(v4);
      }
      if (typeof v4 === "string") {
        if (!(0, internal_1.isHexString)(v4)) {
          throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v4}`);
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v4)), "hex");
      }
      if (typeof v4 === "number") {
        return (0, exports10.intToBuffer)(v4);
      }
      if (typeof v4 === "bigint") {
        if (v4 < BigInt(0)) {
          throw new Error(`Cannot convert negative bigint to buffer. Given: ${v4}`);
        }
        let n5 = v4.toString(16);
        if (n5.length % 2)
          n5 = "0" + n5;
        return Buffer.from(n5, "hex");
      }
      if (v4.toArray) {
        return Buffer.from(v4.toArray());
      }
      if (v4.toBuffer) {
        return Buffer.from(v4.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports10.toBuffer = toBuffer;
    var bufferToHex = function(buf) {
      buf = (0, exports10.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports10.bufferToHex = bufferToHex;
    function bufferToBigInt2(buf) {
      const hex = (0, exports10.bufferToHex)(buf);
      if (hex === "0x") {
        return BigInt(0);
      }
      return BigInt(hex);
    }
    exports10.bufferToBigInt = bufferToBigInt2;
    function bigIntToBuffer2(num) {
      return (0, exports10.toBuffer)("0x" + num.toString(16));
    }
    exports10.bigIntToBuffer = bigIntToBuffer2;
    var bufferToInt = function(buf) {
      const res = Number(bufferToBigInt2(buf));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports10.bufferToInt = bufferToInt;
    var fromSigned2 = function(num) {
      return BigInt.asIntN(256, bufferToBigInt2(num));
    };
    exports10.fromSigned = fromSigned2;
    var toUnsigned2 = function(num) {
      return bigIntToBuffer2(BigInt.asUintN(256, num));
    };
    exports10.toUnsigned = toUnsigned2;
    var addHexPrefix2 = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports10.addHexPrefix = addHexPrefix2;
    function short(buffer2, maxLength = 50) {
      const bufferStr = Buffer.isBuffer(buffer2) ? buffer2.toString("hex") : buffer2;
      if (bufferStr.length <= maxLength) {
        return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + "\u2026";
    }
    exports10.short = short;
    var toUtf8 = function(hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      const bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports10.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return `0x${ba.toString("hex")}`;
      } else if (ba instanceof Array) {
        const array2 = [];
        for (let i4 = 0; i4 < ba.length; i4++) {
          array2.push((0, exports10.baToJSON)(ba[i4]));
        }
        return array2;
      }
    };
    exports10.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      for (const [k2, v4] of Object.entries(values)) {
        if (v4 !== void 0 && v4.length > 0 && v4[0] === 0) {
          throw new Error(`${k2} cannot have leading zeroes, received: ${v4.toString("hex")}`);
        }
      }
    };
    exports10.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map((a4) => arrToBufArr(a4));
    }
    exports10.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr ?? []);
      }
      return arr.map((a4) => bufArrToArr(a4));
    }
    exports10.bufArrToArr = bufArrToArr;
    var bigIntToHex2 = (num) => {
      return "0x" + num.toString(16);
    };
    exports10.bigIntToHex = bigIntToHex2;
    function bigIntToUnpaddedBuffer(value) {
      return (0, exports10.unpadBuffer)(bigIntToBuffer2(value));
    }
    exports10.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
    function intToUnpaddedBuffer(value) {
      return (0, exports10.unpadBuffer)((0, exports10.intToBuffer)(value));
    }
    exports10.intToUnpaddedBuffer = intToUnpaddedBuffer;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/account.js
var require_account = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/account.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.accountBodyToRLP = exports10.accountBodyToSlim = exports10.accountBodyFromSlim = exports10.isZeroAddress = exports10.zeroAddress = exports10.importPublic = exports10.privateToAddress = exports10.privateToPublic = exports10.publicToAddress = exports10.pubToAddress = exports10.isValidPublic = exports10.isValidPrivate = exports10.generateAddress2 = exports10.generateAddress = exports10.isValidChecksumAddress = exports10.toChecksumAddress = exports10.isValidAddress = exports10.Account = void 0;
    var rlp_1 = require_dist4();
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var utils_1 = require_utils6();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var _0n = BigInt(0);
    var Account = class {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
        this.nonce = nonce;
        this.balance = balance;
        this.storageRoot = storageRoot;
        this.codeHash = codeHash;
        this._validate();
      }
      static fromAccountData(accountData) {
        const { nonce, balance, storageRoot, codeHash } = accountData;
        return new Account(nonce !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : void 0, balance !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_1.toBuffer)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_1.toBuffer)(codeHash) : void 0);
      }
      static fromRlpSerializedAccount(serialized) {
        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized account input. Must be array");
        }
        return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
        const [nonce, balance, storageRoot, codeHash] = values;
        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
      }
      _validate() {
        if (this.nonce < _0n) {
          throw new Error("nonce must be greater than zero");
        }
        if (this.balance < _0n) {
          throw new Error("balance must be greater than zero");
        }
        if (this.storageRoot.length !== 32) {
          throw new Error("storageRoot must have a length of 32");
        }
        if (this.codeHash.length !== 32) {
          throw new Error("codeHash must have a length of 32");
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
        return [
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
          this.storageRoot,
          this.codeHash
        ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    };
    exports10.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e6) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports10.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = "";
      if (eip1191ChainId !== void 0) {
        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
        prefix = chainId.toString() + "0x";
      }
      const buf = Buffer.from(prefix + address, "utf8");
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = "0x";
      for (let i4 = 0; i4 < address.length; i4++) {
        if (parseInt(hash[i4], 16) >= 8) {
          ret += address[i4].toUpperCase();
        } else {
          ret += address[i4];
        }
      }
      return ret;
    };
    exports10.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports10.isValidAddress)(hexAddress) && (0, exports10.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports10.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
    };
    exports10.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
        throw new Error("Expected from to be of length 20");
      }
      if (salt.length !== 32) {
        throw new Error("Expected salt to be of length 32");
      }
      const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
    };
    exports10.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
    };
    exports10.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        try {
          secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
          return true;
        } catch (e6) {
          return false;
        }
      }
      if (!sanitize) {
        return false;
      }
      try {
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
        return true;
      } catch (e6) {
        return false;
      }
    };
    exports10.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
        throw new Error("Expected pubKey to be of length 64");
      }
      return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    };
    exports10.pubToAddress = pubToAddress;
    exports10.publicToAddress = exports10.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
    };
    exports10.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports10.publicToAddress)((0, exports10.privateToPublic)(privateKey));
    };
    exports10.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
    };
    exports10.importPublic = importPublic;
    var zeroAddress = function() {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports10.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e6) {
        return false;
      }
      const zeroAddr = (0, exports10.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports10.isZeroAddress = isZeroAddress;
    function accountBodyFromSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash
      ];
    }
    exports10.accountBodyFromSlim = accountBodyFromSlim;
    var emptyUint8Arr = new Uint8Array(0);
    function accountBodyToSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash
      ];
    }
    exports10.accountBodyToSlim = accountBodyToSlim;
    function accountBodyToRLP(body, couldBeSlim = true) {
      const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
      return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
    }
    exports10.accountBodyToRLP = accountBodyToRLP;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/address.js
var require_address = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/address.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.Address = void 0;
    var account_1 = require_account();
    var bytes_1 = require_bytes2();
    var Address = class {
      constructor(buf) {
        if (buf.length !== 20) {
          throw new Error("Invalid address length");
        }
        this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
        return new Address((0, bytes_1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
          throw new Error("Invalid address");
        }
        return new Address((0, bytes_1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
          throw new Error("Public key should be Buffer");
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
          throw new Error("Private key should be Buffer");
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
        if (typeof nonce !== "bigint") {
          throw new Error("Expected nonce to be a bigint");
        }
        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
          throw new Error("Expected salt to be a Buffer");
        }
        if (!Buffer.isBuffer(initCode)) {
          throw new Error("Expected initCode to be a Buffer");
        }
        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
        return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
        return this.equals(Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
        const address = (0, bytes_1.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt("0xffff");
        return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
        return "0x" + this.buf.toString("hex");
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
        return Buffer.from(this.buf);
      }
    };
    exports10.Address = Address;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/types.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.toType = exports10.TypeOutput = void 0;
    var bytes_1 = require_bytes2();
    var internal_1 = require_internal();
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports10.TypeOutput || (exports10.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
        case TypeOutput.Buffer:
          return output;
        case TypeOutput.BigInt:
          return (0, bytes_1.bufferToBigInt)(output);
        case TypeOutput.Number: {
          const bigInt = (0, bytes_1.bufferToBigInt)(output);
          if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          }
          return Number(bigInt);
        }
        case TypeOutput.PrefixedHexString:
          return (0, bytes_1.bufferToHex)(output);
        default:
          throw new Error("unknown outputType");
      }
    }
    exports10.toType = toType;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/withdrawal.js
var require_withdrawal = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/withdrawal.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.Withdrawal = void 0;
    var address_1 = require_address();
    var bytes_1 = require_bytes2();
    var types_1 = require_types();
    var Withdrawal = class {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
       * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
       */
      constructor(index, validatorIndex, address, amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
      }
      static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);
        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));
        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);
        return new Withdrawal(index, validatorIndex, address, amount);
      }
      static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
          throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
      }
      /**
       * Convert a withdrawal to a buffer array
       * @param withdrawal the withdrawal to convert
       * @returns buffer array of the withdrawal
       */
      static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1.Address) {
          addressBuffer = address.buf;
        } else {
          addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
      }
      raw() {
        return Withdrawal.toBufferArray(this);
      }
      toValue() {
        return {
          index: this.index,
          validatorIndex: this.validatorIndex,
          address: this.address.buf,
          amount: this.amount
        };
      }
      toJSON() {
        return {
          index: (0, bytes_1.bigIntToHex)(this.index),
          validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),
          address: "0x" + this.address.buf.toString("hex"),
          amount: (0, bytes_1.bigIntToHex)(this.amount)
        };
      }
    };
    exports10.Withdrawal = Withdrawal;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/signature.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.hashPersonalMessage = exports10.isValidSignature = exports10.fromRpcSig = exports10.toCompactSig = exports10.toRpcSig = exports10.ecrecover = exports10.ecsign = void 0;
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k12();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    function ecsign2(msgHash, privateKey, chainId) {
      const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
      const buf = sig.toCompactRawBytes();
      const r6 = Buffer.from(buf.slice(0, 32));
      const s2 = Buffer.from(buf.slice(32, 64));
      const v4 = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r: r6, s: s2, v: v4 };
    }
    exports10.ecsign = ecsign2;
    function calculateSigRecovery(v4, chainId) {
      if (v4 === BigInt(0) || v4 === BigInt(1))
        return v4;
      if (chainId === void 0) {
        return v4 - BigInt(27);
      }
      return v4 - (chainId * BigInt(2) + BigInt(35));
    }
    function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
    }
    var ecrecover = function(msgHash, v4, r6, s2, chainId) {
      const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r6, 32), (0, bytes_1.setLengthLeft)(s2, 32)], 64);
      const recovery = calculateSigRecovery(v4, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
      const senderPubKey = sig.recoverPublicKey(msgHash);
      return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
    };
    exports10.ecrecover = ecrecover;
    var toRpcSig = function(v4, r6, s2, chainId) {
      const recovery = calculateSigRecovery(v4, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r6, 32), (0, bytes_1.setLengthLeft)(s2, 32), (0, bytes_1.toBuffer)(v4)]));
    };
    exports10.toRpcSig = toRpcSig;
    var toCompactSig = function(v4, r6, s2, chainId) {
      const recovery = calculateSigRecovery(v4, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      let ss = s2;
      if (v4 > BigInt(28) && v4 % BigInt(2) === BigInt(1) || v4 === BigInt(1) || v4 === BigInt(28)) {
        ss = Buffer.from(s2);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r6, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports10.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r6;
      let s2;
      let v4;
      if (buf.length >= 65) {
        r6 = buf.slice(0, 32);
        s2 = buf.slice(32, 64);
        v4 = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r6 = buf.slice(0, 32);
        s2 = buf.slice(32, 64);
        v4 = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s2[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v4 < 27) {
        v4 = v4 + BigInt(27);
      }
      return {
        v: v4,
        r: r6,
        s: s2
      };
    };
    exports10.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v4, r6, s2, homesteadOrLater = true, chainId) {
      if (r6.length !== 32 || s2.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v4, chainId))) {
        return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r6);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s2);
      if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {
        return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
        return false;
      }
      return true;
    };
    exports10.isValidSignature = isValidSignature;
    var hashPersonalMessage2 = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      const prefix = Buffer.from(`Ethereum Signed Message:
${message.length}`, "utf-8");
      return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
    };
    exports10.hashPersonalMessage = hashPersonalMessage2;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/encoding.js
var require_encoding = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/encoding.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.compactBytesToNibbles = exports10.bytesToNibbles = exports10.nibblesToCompactBytes = exports10.nibblesToBytes = exports10.hasTerminator = void 0;
    var hasTerminator = (nibbles) => {
      return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
    };
    exports10.hasTerminator = hasTerminator;
    var nibblesToBytes = (nibbles, bytes) => {
      for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];
      }
    };
    exports10.nibblesToBytes = nibblesToBytes;
    var nibblesToCompactBytes = (nibbles) => {
      let terminator = 0;
      if ((0, exports10.hasTerminator)(nibbles)) {
        terminator = 1;
        nibbles = nibbles.subarray(0, nibbles.length - 1);
      }
      const buf = new Uint8Array(nibbles.length / 2 + 1);
      buf[0] = terminator << 5;
      if ((nibbles.length & 1) === 1) {
        buf[0] |= 1 << 4;
        buf[0] |= nibbles[0];
        nibbles = nibbles.subarray(1);
      }
      (0, exports10.nibblesToBytes)(nibbles, buf.subarray(1));
      return buf;
    };
    exports10.nibblesToCompactBytes = nibblesToCompactBytes;
    var bytesToNibbles = (str) => {
      const l4 = str.length * 2 + 1;
      const nibbles = new Uint8Array(l4);
      for (let i4 = 0; i4 < str.length; i4++) {
        const b4 = str[i4];
        nibbles[i4 * 2] = b4 / 16;
        nibbles[i4 * 2 + 1] = b4 % 16;
      }
      nibbles[l4 - 1] = 16;
      return nibbles;
    };
    exports10.bytesToNibbles = bytesToNibbles;
    var compactBytesToNibbles = (compact) => {
      if (compact.length === 0) {
        return compact;
      }
      let base = (0, exports10.bytesToNibbles)(compact);
      if (base[0] < 2) {
        base = base.subarray(0, base.length - 1);
      }
      const chop = 2 - (base[0] & 1);
      return base.subarray(chop);
    };
    exports10.compactBytesToNibbles = compactBytesToNibbles;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js
var require_asyncEventEmitter = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/asyncEventEmitter.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.AsyncEventEmitter = void 0;
    var events_1 = (init_events3(), __toCommonJS(events_exports));
    async function runInSeries(context, tasks, data) {
      let error;
      for await (const task of tasks) {
        try {
          if (task.length < 2) {
            task.call(context, data);
          } else {
            await new Promise((resolve3, reject) => {
              task.call(context, data, (error2) => {
                if (error2) {
                  reject(error2);
                } else {
                  resolve3();
                }
              });
            });
          }
        } catch (e6) {
          error = e6;
        }
      }
      if (error) {
        throw error;
      }
    }
    var AsyncEventEmitter = class extends events_1.EventEmitter {
      emit(event, ...args) {
        let [data, callback] = args;
        const self2 = this;
        let listeners = self2._events[event] ?? [];
        if (callback === void 0 && typeof data === "function") {
          callback = data;
          data = void 0;
        }
        if (event === "newListener" || event === "removeListener") {
          data = {
            event: data,
            fn: callback
          };
          callback = void 0;
        }
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
        return self2.listenerCount(event) > 0;
      }
      once(event, listener) {
        const self2 = this;
        let g4;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (listener.length >= 2) {
          g4 = function(e6, next) {
            self2.removeListener(event, g4);
            void listener(e6, next);
          };
        } else {
          g4 = function(e6) {
            self2.removeListener(event, g4);
            void listener(e6, g4);
          };
        }
        self2.on(event, g4);
        return self2;
      }
      first(event, listener) {
        let listeners = this._events[event] ?? [];
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
      }
      before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
      }
      after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, "after");
      }
      beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i4;
        let index;
        const add = beforeOrAfter === "after" ? 1 : 0;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (typeof target !== "function") {
          throw new TypeError("target must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i4 = listeners.length; i4--; ) {
          if (listeners[i4] === target) {
            index = i4 + add;
            break;
          }
        }
        listeners.splice(index, 0, listener);
        return this;
      }
      on(event, listener) {
        return super.on(event, listener);
      }
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      eventNames() {
        return super.eventNames();
      }
      listeners(event) {
        return super.listeners(event);
      }
      listenerCount(event) {
        return super.listenerCount(event);
      }
      getMaxListeners() {
        return super.getMaxListeners();
      }
      setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
      }
    };
    exports10.AsyncEventEmitter = AsyncEventEmitter;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/lock.js
var require_lock = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/lock.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.Lock = void 0;
    var Lock = class {
      constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
      }
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      async acquire() {
        if (this.permits > 0) {
          this.permits -= 1;
          return Promise.resolve(true);
        }
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
      }
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          console.warn("Lock.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          const nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      }
    };
    exports10.Lock = Lock;
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-c3d025d9.js
function dew2() {
  if (_dewExec)
    return exports2;
  _dewExec = true;
  exports2 = exports2 = dew$3();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = dew$8();
  exports2.Duplex = dew$7();
  exports2.Transform = dew$2();
  exports2.PassThrough = dew$1();
  exports2.finished = dew$6();
  exports2.pipeline = dew();
  return exports2;
}
var exports2, _dewExec;
var init_chunk_c3d025d9 = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-c3d025d9.js"() {
    init_chunk_44e51b61();
    exports2 = {};
    _dewExec = false;
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
function i(t4) {
  throw new RangeError(r[t4]);
}
function f(t4, o5) {
  const n5 = t4.split("@");
  let r6 = "";
  n5.length > 1 && (r6 = n5[0] + "@", t4 = n5[1]);
  const c4 = function(t5, o6) {
    const n6 = [];
    let e6 = t5.length;
    for (; e6--; )
      n6[e6] = o6(t5[e6]);
    return n6;
  }((t4 = t4.replace(e, ".")).split("."), o5).join(".");
  return r6 + c4;
}
function l(t4) {
  const o5 = [];
  let n5 = 0;
  const e6 = t4.length;
  for (; n5 < e6; ) {
    const r6 = t4.charCodeAt(n5++);
    if (r6 >= 55296 && r6 <= 56319 && n5 < e6) {
      const e7 = t4.charCodeAt(n5++);
      56320 == (64512 & e7) ? o5.push(((1023 & r6) << 10) + (1023 & e7) + 65536) : (o5.push(r6), n5--);
    } else
      o5.push(r6);
  }
  return o5;
}
var t, o, n, e, r, c, s, u, a, d, h, p;
var init_chunk_924bb2e1 = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
    t = 2147483647;
    o = /^xn--/;
    n = /[^\0-\x7E]/;
    e = /[\x2E\u3002\uFF0E\uFF61]/g;
    r = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
    c = Math.floor;
    s = String.fromCharCode;
    u = function(t4, o5) {
      return t4 + 22 + 75 * (t4 < 26) - ((0 != o5) << 5);
    };
    a = function(t4, o5, n5) {
      let e6 = 0;
      for (t4 = n5 ? c(t4 / 700) : t4 >> 1, t4 += c(t4 / o5); t4 > 455; e6 += 36)
        t4 = c(t4 / 35);
      return c(e6 + 36 * t4 / (t4 + 38));
    };
    d = function(o5) {
      const n5 = [], e6 = o5.length;
      let r6 = 0, s2 = 128, f4 = 72, l4 = o5.lastIndexOf("-");
      l4 < 0 && (l4 = 0);
      for (let t4 = 0; t4 < l4; ++t4)
        o5.charCodeAt(t4) >= 128 && i("not-basic"), n5.push(o5.charCodeAt(t4));
      for (let d3 = l4 > 0 ? l4 + 1 : 0; d3 < e6; ) {
        let l5 = r6;
        for (let n6 = 1, s3 = 36; ; s3 += 36) {
          d3 >= e6 && i("invalid-input");
          const l6 = (u4 = o5.charCodeAt(d3++)) - 48 < 10 ? u4 - 22 : u4 - 65 < 26 ? u4 - 65 : u4 - 97 < 26 ? u4 - 97 : 36;
          (l6 >= 36 || l6 > c((t - r6) / n6)) && i("overflow"), r6 += l6 * n6;
          const a4 = s3 <= f4 ? 1 : s3 >= f4 + 26 ? 26 : s3 - f4;
          if (l6 < a4)
            break;
          const h6 = 36 - a4;
          n6 > c(t / h6) && i("overflow"), n6 *= h6;
        }
        const h5 = n5.length + 1;
        f4 = a(r6 - l5, h5, 0 == l5), c(r6 / h5) > t - s2 && i("overflow"), s2 += c(r6 / h5), r6 %= h5, n5.splice(r6++, 0, s2);
      }
      var u4;
      return String.fromCodePoint(...n5);
    };
    h = function(o5) {
      const n5 = [];
      let e6 = (o5 = l(o5)).length, r6 = 128, f4 = 0, d3 = 72;
      for (const t4 of o5)
        t4 < 128 && n5.push(s(t4));
      let h5 = n5.length, p4 = h5;
      for (h5 && n5.push("-"); p4 < e6; ) {
        let e7 = t;
        for (const t4 of o5)
          t4 >= r6 && t4 < e7 && (e7 = t4);
        const l4 = p4 + 1;
        e7 - r6 > c((t - f4) / l4) && i("overflow"), f4 += (e7 - r6) * l4, r6 = e7;
        for (const e8 of o5)
          if (e8 < r6 && ++f4 > t && i("overflow"), e8 == r6) {
            let t4 = f4;
            for (let o6 = 36; ; o6 += 36) {
              const e9 = o6 <= d3 ? 1 : o6 >= d3 + 26 ? 26 : o6 - d3;
              if (t4 < e9)
                break;
              const r7 = t4 - e9, i4 = 36 - e9;
              n5.push(s(u(e9 + r7 % i4, 0))), t4 = c(r7 / i4);
            }
            n5.push(s(u(t4, 0))), d3 = a(f4, l4, p4 == h5), f4 = 0, ++p4;
          }
        ++f4, ++r6;
      }
      return n5.join("");
    };
    p = { version: "2.1.0", ucs2: { decode: l, encode: (t4) => String.fromCodePoint(...t4) }, decode: d, encode: h, toASCII: function(t4) {
      return f(t4, function(t5) {
        return n.test(t5) ? "xn--" + h(t5) : t5;
      });
    }, toUnicode: function(t4) {
      return f(t4, function(t5) {
        return o.test(t5) ? d(t5.slice(4).toLowerCase()) : t5;
      });
    } };
    p.decode;
    p.encode;
    p.toASCII;
    p.toUnicode;
    p.ucs2;
    p.version;
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
function e2(e6, n5) {
  return Object.prototype.hasOwnProperty.call(e6, n5);
}
var n2, r2, t2, o2;
var init_chunk_b04e620d = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
    n2 = function(n5, r6, t4, o5) {
      r6 = r6 || "&", t4 = t4 || "=";
      var a4 = {};
      if ("string" != typeof n5 || 0 === n5.length)
        return a4;
      var u4 = /\+/g;
      n5 = n5.split(r6);
      var c4 = 1e3;
      o5 && "number" == typeof o5.maxKeys && (c4 = o5.maxKeys);
      var i4 = n5.length;
      c4 > 0 && i4 > c4 && (i4 = c4);
      for (var s2 = 0; s2 < i4; ++s2) {
        var p4, f4, d3, y4, m4 = n5[s2].replace(u4, "%20"), l4 = m4.indexOf(t4);
        l4 >= 0 ? (p4 = m4.substr(0, l4), f4 = m4.substr(l4 + 1)) : (p4 = m4, f4 = ""), d3 = decodeURIComponent(p4), y4 = decodeURIComponent(f4), e2(a4, d3) ? Array.isArray(a4[d3]) ? a4[d3].push(y4) : a4[d3] = [a4[d3], y4] : a4[d3] = y4;
      }
      return a4;
    };
    r2 = function(e6) {
      switch (typeof e6) {
        case "string":
          return e6;
        case "boolean":
          return e6 ? "true" : "false";
        case "number":
          return isFinite(e6) ? e6 : "";
        default:
          return "";
      }
    };
    t2 = function(e6, n5, t4, o5) {
      return n5 = n5 || "&", t4 = t4 || "=", null === e6 && (e6 = void 0), "object" == typeof e6 ? Object.keys(e6).map(function(o6) {
        var a4 = encodeURIComponent(r2(o6)) + t4;
        return Array.isArray(e6[o6]) ? e6[o6].map(function(e7) {
          return a4 + encodeURIComponent(r2(e7));
        }).join(n5) : a4 + encodeURIComponent(r2(e6[o6]));
      }).join(n5) : o5 ? encodeURIComponent(r2(o5)) + t4 + encodeURIComponent(r2(e6)) : "";
    };
    o2 = {};
    o2.decode = o2.parse = n2, o2.encode = o2.stringify = t2;
    o2.decode;
    o2.encode;
    o2.parse;
    o2.stringify;
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
function dew3() {
  if (_dewExec2)
    return exports$1;
  _dewExec2 = true;
  var process$1 = process2;
  function assertPath(path3) {
    if (typeof path3 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
    }
  }
  function normalizeStringPosix(path3, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i4 = 0; i4 <= path3.length; ++i4) {
      if (i4 < path3.length)
        code = path3.charCodeAt(i4);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i4 - 1 || dots === 1)
          ;
        else if (lastSlash !== i4 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i4;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i4;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path3.slice(lastSlash + 1, i4);
          else
            res = path3.slice(lastSlash + 1, i4);
          lastSegmentLength = i4 - lastSlash - 1;
        }
        lastSlash = i4;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i4 = arguments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--) {
        var path3;
        if (i4 >= 0)
          path3 = arguments[i4];
        else {
          if (cwd === void 0)
            cwd = process$1.cwd();
          path3 = cwd;
        }
        assertPath(path3);
        if (path3.length === 0) {
          continue;
        }
        resolvedPath = path3 + "/" + resolvedPath;
        resolvedAbsolute = path3.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var isAbsolute = path3.charCodeAt(0) === 47;
      var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
      path3 = normalizeStringPosix(path3, !isAbsolute);
      if (path3.length === 0 && !isAbsolute)
        path3 = ".";
      if (path3.length > 0 && trailingSeparator)
        path3 += "/";
      if (isAbsolute)
        return "/" + path3;
      return path3;
    },
    isAbsolute: function isAbsolute(path3) {
      assertPath(path3);
      return path3.length > 0 && path3.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i4 = 0; i4 < arguments.length; ++i4) {
        var arg = arguments[i4];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i4 = 0;
      for (; i4 <= length; ++i4) {
        if (i4 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i4) === 47) {
              return to.slice(toStart + i4 + 1);
            } else if (i4 === 0) {
              return to.slice(toStart + i4);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i4) === 47) {
              lastCommonSep = i4;
            } else if (i4 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i4);
        var toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i4;
      }
      var out = "";
      for (i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4) {
        if (i4 === fromEnd || from.charCodeAt(i4) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path3) {
      return path3;
    },
    dirname: function dirname(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var code = path3.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i4 = path3.length - 1; i4 >= 1; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            end = i4;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path3.slice(0, end);
    },
    basename: function basename(path3, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path3);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i4;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          var code = path3.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i4 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i4;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path3.length;
        return path3.slice(start, end);
      } else {
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          if (path3.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
          }
        }
        if (end === -1)
          return "";
        return path3.slice(start, end);
      }
    },
    extname: function extname(path3) {
      assertPath(path3);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i4 = path3.length - 1; i4 >= 0; --i4) {
        var code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path3.slice(startDot, end);
    },
    format: function format4(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path3) {
      assertPath(path3);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path3.length === 0)
        return ret;
      var code = path3.charCodeAt(0);
      var isAbsolute = code === 47;
      var start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i4 = path3.length - 1;
      var preDotState = 0;
      for (; i4 >= start; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path3.slice(1, end);
          else
            ret.base = ret.name = path3.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path3.slice(1, startDot);
          ret.base = path3.slice(1, end);
        } else {
          ret.name = path3.slice(startPart, startDot);
          ret.base = path3.slice(startPart, end);
        }
        ret.ext = path3.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path3.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports$1 = posix;
  return exports$1;
}
var exports$1, _dewExec2, exports3;
var init_chunk_23dbec7b = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
    init_chunk_2eac56ff();
    exports$1 = {};
    _dewExec2 = false;
    exports3 = dew3();
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/url.js
function r3() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O(t4, s2, h5) {
  if (t4 && a2.isObject(t4) && t4 instanceof r3)
    return t4;
  var e6 = new r3();
  return e6.parse(t4, s2, h5), e6;
}
function dew4() {
  if (_dewExec3)
    return exports4;
  _dewExec3 = true;
  var process3 = T;
  function assertPath(path3) {
    if (typeof path3 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
    }
  }
  function normalizeStringPosix(path3, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i4 = 0; i4 <= path3.length; ++i4) {
      if (i4 < path3.length)
        code = path3.charCodeAt(i4);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i4 - 1 || dots === 1)
          ;
        else if (lastSlash !== i4 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i4;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i4;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path3.slice(lastSlash + 1, i4);
          else
            res = path3.slice(lastSlash + 1, i4);
          lastSegmentLength = i4 - lastSlash - 1;
        }
        lastSlash = i4;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i4 = arguments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--) {
        var path3;
        if (i4 >= 0)
          path3 = arguments[i4];
        else {
          if (cwd === void 0)
            cwd = process3.cwd();
          path3 = cwd;
        }
        assertPath(path3);
        if (path3.length === 0) {
          continue;
        }
        resolvedPath = path3 + "/" + resolvedPath;
        resolvedAbsolute = path3.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var isAbsolute = path3.charCodeAt(0) === 47;
      var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
      path3 = normalizeStringPosix(path3, !isAbsolute);
      if (path3.length === 0 && !isAbsolute)
        path3 = ".";
      if (path3.length > 0 && trailingSeparator)
        path3 += "/";
      if (isAbsolute)
        return "/" + path3;
      return path3;
    },
    isAbsolute: function isAbsolute(path3) {
      assertPath(path3);
      return path3.length > 0 && path3.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i4 = 0; i4 < arguments.length; ++i4) {
        var arg = arguments[i4];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i4 = 0;
      for (; i4 <= length; ++i4) {
        if (i4 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i4) === 47) {
              return to.slice(toStart + i4 + 1);
            } else if (i4 === 0) {
              return to.slice(toStart + i4);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i4) === 47) {
              lastCommonSep = i4;
            } else if (i4 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i4);
        var toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i4;
      }
      var out = "";
      for (i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4) {
        if (i4 === fromEnd || from.charCodeAt(i4) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path3) {
      return path3;
    },
    dirname: function dirname(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var code = path3.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i4 = path3.length - 1; i4 >= 1; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            end = i4;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path3.slice(0, end);
    },
    basename: function basename(path3, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path3);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i4;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          var code = path3.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i4 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i4;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path3.length;
        return path3.slice(start, end);
      } else {
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          if (path3.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
          }
        }
        if (end === -1)
          return "";
        return path3.slice(start, end);
      }
    },
    extname: function extname(path3) {
      assertPath(path3);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i4 = path3.length - 1; i4 >= 0; --i4) {
        var code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path3.slice(startDot, end);
    },
    format: function format4(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path3) {
      assertPath(path3);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path3.length === 0)
        return ret;
      var code = path3.charCodeAt(0);
      var isAbsolute = code === 47;
      var start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i4 = path3.length - 1;
      var preDotState = 0;
      for (; i4 >= start; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path3.slice(1, end);
          else
            ret.base = ret.name = path3.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path3.slice(1, startDot);
          ret.base = path3.slice(1, end);
        } else {
          ret.name = path3.slice(startPart, startDot);
          ret.base = path3.slice(startPart, end);
        }
        ret.ext = path3.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path3.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports4 = posix;
  return exports4;
}
function fileURLToPath$1(path3) {
  if (typeof path3 === "string")
    path3 = new URL(path3);
  else if (!(path3 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path3.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path3) : getPathFromURLPosix$1(path3);
}
function getPathFromURLWin$1(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$1, "%25");
  if (!isWindows$1 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$1, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$1, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function fileURLToPath(path3) {
  if (typeof path3 === "string")
    path3 = new URL(path3);
  else if (!(path3 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path3.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path3) : getPathFromURLPosix(path3);
}
function getPathFromURLWin(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports3.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports3.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var h2, e3, a2, o3, n3, i2, l2, p2, c2, u2, f2, m, v, g, y, b, exports4, _dewExec3, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format, resolve, resolveObject, parse, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
var init_url = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/url.js"() {
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_5decc758();
    init_chunk_23dbec7b();
    init_chunk_2eac56ff();
    h2 = {};
    e3 = p;
    a2 = { isString: function(t4) {
      return "string" == typeof t4;
    }, isObject: function(t4) {
      return "object" == typeof t4 && null !== t4;
    }, isNull: function(t4) {
      return null === t4;
    }, isNullOrUndefined: function(t4) {
      return null == t4;
    } };
    h2.parse = O, h2.resolve = function(t4, s2) {
      return O(t4, false, true).resolve(s2);
    }, h2.resolveObject = function(t4, s2) {
      return t4 ? O(t4, false, true).resolveObject(s2) : s2;
    }, h2.format = function(t4) {
      a2.isString(t4) && (t4 = O(t4));
      return t4 instanceof r3 ? t4.format() : r3.prototype.format.call(t4);
    }, h2.Url = r3;
    o3 = /^([a-z0-9.+-]+:)/i;
    n3 = /:[0-9]*$/;
    i2 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    l2 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
    p2 = ["'"].concat(l2);
    c2 = ["%", "/", "?", ";", "#"].concat(p2);
    u2 = ["/", "?", "#"];
    f2 = /^[+a-z0-9A-Z_-]{0,63}$/;
    m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    v = { javascript: true, "javascript:": true };
    g = { javascript: true, "javascript:": true };
    y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    b = o2;
    r3.prototype.parse = function(t4, s2, h5) {
      if (!a2.isString(t4))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t4);
      var r6 = t4.indexOf("?"), n5 = -1 !== r6 && r6 < t4.indexOf("#") ? "?" : "#", l4 = t4.split(n5);
      l4[0] = l4[0].replace(/\\/g, "/");
      var O4 = t4 = l4.join(n5);
      if (O4 = O4.trim(), !h5 && 1 === t4.split("#").length) {
        var d3 = i2.exec(O4);
        if (d3)
          return this.path = O4, this.href = O4, this.pathname = d3[1], d3[2] ? (this.search = d3[2], this.query = s2 ? b.parse(this.search.substr(1)) : this.search.substr(1)) : s2 && (this.search = "", this.query = {}), this;
      }
      var j2 = o3.exec(O4);
      if (j2) {
        var q2 = (j2 = j2[0]).toLowerCase();
        this.protocol = q2, O4 = O4.substr(j2.length);
      }
      if (h5 || j2 || O4.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var x2 = "//" === O4.substr(0, 2);
        !x2 || j2 && g[j2] || (O4 = O4.substr(2), this.slashes = true);
      }
      if (!g[j2] && (x2 || j2 && !y[j2])) {
        for (var A2, C2, I2 = -1, w2 = 0; w2 < u2.length; w2++) {
          -1 !== (N2 = O4.indexOf(u2[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
        }
        -1 !== (C2 = -1 === I2 ? O4.lastIndexOf("@") : O4.lastIndexOf("@", I2)) && (A2 = O4.slice(0, C2), O4 = O4.slice(C2 + 1), this.auth = decodeURIComponent(A2)), I2 = -1;
        for (w2 = 0; w2 < c2.length; w2++) {
          var N2;
          -1 !== (N2 = O4.indexOf(c2[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
        }
        -1 === I2 && (I2 = O4.length), this.host = O4.slice(0, I2), O4 = O4.slice(I2), this.parseHost(), this.hostname = this.hostname || "";
        var U2 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!U2)
          for (var k2 = this.hostname.split(/\./), S2 = (w2 = 0, k2.length); w2 < S2; w2++) {
            var R2 = k2[w2];
            if (R2 && !R2.match(f2)) {
              for (var $2 = "", z2 = 0, H2 = R2.length; z2 < H2; z2++)
                R2.charCodeAt(z2) > 127 ? $2 += "x" : $2 += R2[z2];
              if (!$2.match(f2)) {
                var L2 = k2.slice(0, w2), Z2 = k2.slice(w2 + 1), _2 = R2.match(m);
                _2 && (L2.push(_2[1]), Z2.unshift(_2[2])), Z2.length && (O4 = "/" + Z2.join(".") + O4), this.hostname = L2.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U2 || (this.hostname = e3.toASCII(this.hostname));
        var E2 = this.port ? ":" + this.port : "", P2 = this.hostname || "";
        this.host = P2 + E2, this.href += this.host, U2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O4[0] && (O4 = "/" + O4));
      }
      if (!v[q2])
        for (w2 = 0, S2 = p2.length; w2 < S2; w2++) {
          var T3 = p2[w2];
          if (-1 !== O4.indexOf(T3)) {
            var B2 = encodeURIComponent(T3);
            B2 === T3 && (B2 = escape(T3)), O4 = O4.split(T3).join(B2);
          }
        }
      var D2 = O4.indexOf("#");
      -1 !== D2 && (this.hash = O4.substr(D2), O4 = O4.slice(0, D2));
      var F2 = O4.indexOf("?");
      if (-1 !== F2 ? (this.search = O4.substr(F2), this.query = O4.substr(F2 + 1), s2 && (this.query = b.parse(this.query)), O4 = O4.slice(0, F2)) : s2 && (this.search = "", this.query = {}), O4 && (this.pathname = O4), y[q2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        E2 = this.pathname || "";
        var G2 = this.search || "";
        this.path = E2 + G2;
      }
      return this.href = this.format(), this;
    }, r3.prototype.format = function() {
      var t4 = this.auth || "";
      t4 && (t4 = (t4 = encodeURIComponent(t4)).replace(/%3A/i, ":"), t4 += "@");
      var s2 = this.protocol || "", h5 = this.pathname || "", e6 = this.hash || "", r6 = false, o5 = "";
      this.host ? r6 = t4 + this.host : this.hostname && (r6 = t4 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r6 += ":" + this.port)), this.query && a2.isObject(this.query) && Object.keys(this.query).length && (o5 = b.stringify(this.query));
      var n5 = this.search || o5 && "?" + o5 || "";
      return s2 && ":" !== s2.substr(-1) && (s2 += ":"), this.slashes || (!s2 || y[s2]) && false !== r6 ? (r6 = "//" + (r6 || ""), h5 && "/" !== h5.charAt(0) && (h5 = "/" + h5)) : r6 || (r6 = ""), e6 && "#" !== e6.charAt(0) && (e6 = "#" + e6), n5 && "?" !== n5.charAt(0) && (n5 = "?" + n5), s2 + r6 + (h5 = h5.replace(/[?#]/g, function(t5) {
        return encodeURIComponent(t5);
      })) + (n5 = n5.replace("#", "%23")) + e6;
    }, r3.prototype.resolve = function(t4) {
      return this.resolveObject(O(t4, false, true)).format();
    }, r3.prototype.resolveObject = function(t4) {
      if (a2.isString(t4)) {
        var s2 = new r3();
        s2.parse(t4, false, true), t4 = s2;
      }
      for (var h5 = new r3(), e6 = Object.keys(this), o5 = 0; o5 < e6.length; o5++) {
        var n5 = e6[o5];
        h5[n5] = this[n5];
      }
      if (h5.hash = t4.hash, "" === t4.href)
        return h5.href = h5.format(), h5;
      if (t4.slashes && !t4.protocol) {
        for (var i4 = Object.keys(t4), l4 = 0; l4 < i4.length; l4++) {
          var p4 = i4[l4];
          "protocol" !== p4 && (h5[p4] = t4[p4]);
        }
        return y[h5.protocol] && h5.hostname && !h5.pathname && (h5.path = h5.pathname = "/"), h5.href = h5.format(), h5;
      }
      if (t4.protocol && t4.protocol !== h5.protocol) {
        if (!y[t4.protocol]) {
          for (var c4 = Object.keys(t4), u4 = 0; u4 < c4.length; u4++) {
            var f4 = c4[u4];
            h5[f4] = t4[f4];
          }
          return h5.href = h5.format(), h5;
        }
        if (h5.protocol = t4.protocol, t4.host || g[t4.protocol])
          h5.pathname = t4.pathname;
        else {
          for (var m4 = (t4.pathname || "").split("/"); m4.length && !(t4.host = m4.shift()); )
            ;
          t4.host || (t4.host = ""), t4.hostname || (t4.hostname = ""), "" !== m4[0] && m4.unshift(""), m4.length < 2 && m4.unshift(""), h5.pathname = m4.join("/");
        }
        if (h5.search = t4.search, h5.query = t4.query, h5.host = t4.host || "", h5.auth = t4.auth, h5.hostname = t4.hostname || t4.host, h5.port = t4.port, h5.pathname || h5.search) {
          var v4 = h5.pathname || "", b4 = h5.search || "";
          h5.path = v4 + b4;
        }
        return h5.slashes = h5.slashes || t4.slashes, h5.href = h5.format(), h5;
      }
      var O4 = h5.pathname && "/" === h5.pathname.charAt(0), d3 = t4.host || t4.pathname && "/" === t4.pathname.charAt(0), j2 = d3 || O4 || h5.host && t4.pathname, q2 = j2, x2 = h5.pathname && h5.pathname.split("/") || [], A2 = (m4 = t4.pathname && t4.pathname.split("/") || [], h5.protocol && !y[h5.protocol]);
      if (A2 && (h5.hostname = "", h5.port = null, h5.host && ("" === x2[0] ? x2[0] = h5.host : x2.unshift(h5.host)), h5.host = "", t4.protocol && (t4.hostname = null, t4.port = null, t4.host && ("" === m4[0] ? m4[0] = t4.host : m4.unshift(t4.host)), t4.host = null), j2 = j2 && ("" === m4[0] || "" === x2[0])), d3)
        h5.host = t4.host || "" === t4.host ? t4.host : h5.host, h5.hostname = t4.hostname || "" === t4.hostname ? t4.hostname : h5.hostname, h5.search = t4.search, h5.query = t4.query, x2 = m4;
      else if (m4.length)
        x2 || (x2 = []), x2.pop(), x2 = x2.concat(m4), h5.search = t4.search, h5.query = t4.query;
      else if (!a2.isNullOrUndefined(t4.search)) {
        if (A2)
          h5.hostname = h5.host = x2.shift(), (U2 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U2.shift(), h5.host = h5.hostname = U2.shift());
        return h5.search = t4.search, h5.query = t4.query, a2.isNull(h5.pathname) && a2.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.href = h5.format(), h5;
      }
      if (!x2.length)
        return h5.pathname = null, h5.search ? h5.path = "/" + h5.search : h5.path = null, h5.href = h5.format(), h5;
      for (var C2 = x2.slice(-1)[0], I2 = (h5.host || t4.host || x2.length > 1) && ("." === C2 || ".." === C2) || "" === C2, w2 = 0, N2 = x2.length; N2 >= 0; N2--)
        "." === (C2 = x2[N2]) ? x2.splice(N2, 1) : ".." === C2 ? (x2.splice(N2, 1), w2++) : w2 && (x2.splice(N2, 1), w2--);
      if (!j2 && !q2)
        for (; w2--; w2)
          x2.unshift("..");
      !j2 || "" === x2[0] || x2[0] && "/" === x2[0].charAt(0) || x2.unshift(""), I2 && "/" !== x2.join("/").substr(-1) && x2.push("");
      var U2, k2 = "" === x2[0] || x2[0] && "/" === x2[0].charAt(0);
      A2 && (h5.hostname = h5.host = k2 ? "" : x2.length ? x2.shift() : "", (U2 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U2.shift(), h5.host = h5.hostname = U2.shift()));
      return (j2 = j2 || h5.host && x2.length) && !k2 && x2.unshift(""), x2.length ? h5.pathname = x2.join("/") : (h5.pathname = null, h5.path = null), a2.isNull(h5.pathname) && a2.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.auth = t4.auth || h5.auth, h5.slashes = h5.slashes || t4.slashes, h5.href = h5.format(), h5;
    }, r3.prototype.parseHost = function() {
      var t4 = this.host, s2 = n3.exec(t4);
      s2 && (":" !== (s2 = s2[0]) && (this.port = s2.substr(1)), t4 = t4.substr(0, t4.length - s2.length)), t4 && (this.hostname = t4);
    };
    h2.Url;
    h2.format;
    h2.resolve;
    h2.resolveObject;
    exports4 = {};
    _dewExec3 = false;
    path = dew4();
    processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h2.URL = typeof URL !== "undefined" ? URL : null;
    h2.pathToFileURL = pathToFileURL$1;
    h2.fileURLToPath = fileURLToPath$1;
    h2.Url;
    h2.format;
    h2.resolve;
    h2.resolveObject;
    h2.URL;
    CHAR_BACKWARD_SLASH$1 = 92;
    CHAR_FORWARD_SLASH$1 = 47;
    CHAR_LOWERCASE_A$1 = 97;
    CHAR_LOWERCASE_Z$1 = 122;
    isWindows$1 = processPlatform$1 === "win32";
    forwardSlashRegEx$1 = /\//g;
    percentRegEx$1 = /%/g;
    backslashRegEx$1 = /\\/g;
    newlineRegEx$1 = /\n/g;
    carriageReturnRegEx$1 = /\r/g;
    tabRegEx$1 = /\t/g;
    processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h2.URL = typeof URL !== "undefined" ? URL : null;
    h2.pathToFileURL = pathToFileURL;
    h2.fileURLToPath = fileURLToPath;
    Url = h2.Url;
    format = h2.format;
    resolve = h2.resolve;
    resolveObject = h2.resolveObject;
    parse = h2.parse;
    _URL = h2.URL;
    CHAR_BACKWARD_SLASH = 92;
    CHAR_FORWARD_SLASH = 47;
    CHAR_LOWERCASE_A = 97;
    CHAR_LOWERCASE_Z = 122;
    isWindows = processPlatform === "win32";
    forwardSlashRegEx = /\//g;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
  }
});

// node-modules-polyfills:http
function dew$5() {
  if (_dewExec$5)
    return exports$6;
  _dewExec$5 = true;
  exports$6.fetch = isFunction2(_global$3.fetch) && isFunction2(_global$3.ReadableStream);
  exports$6.writableStream = isFunction2(_global$3.WritableStream);
  exports$6.abortController = isFunction2(_global$3.AbortController);
  var xhr;
  function getXHR() {
    if (xhr !== void 0)
      return xhr;
    if (_global$3.XMLHttpRequest) {
      xhr = new _global$3.XMLHttpRequest();
      try {
        xhr.open("GET", _global$3.XDomainRequest ? "/" : "https://example.com");
      } catch (e6) {
        xhr = null;
      }
    } else {
      xhr = null;
    }
    return xhr;
  }
  function checkTypeSupport(type2) {
    var xhr2 = getXHR();
    if (!xhr2)
      return false;
    try {
      xhr2.responseType = type2;
      return xhr2.responseType === type2;
    } catch (e6) {
    }
    return false;
  }
  exports$6.arraybuffer = exports$6.fetch || checkTypeSupport("arraybuffer");
  exports$6.msstream = !exports$6.fetch && checkTypeSupport("ms-stream");
  exports$6.mozchunkedarraybuffer = !exports$6.fetch && checkTypeSupport("moz-chunked-arraybuffer");
  exports$6.overrideMimeType = exports$6.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
  function isFunction2(value) {
    return typeof value === "function";
  }
  xhr = null;
  return exports$6;
}
function dew$4() {
  if (_dewExec$4)
    return exports$5;
  _dewExec$4 = true;
  var Buffer2 = buffer.Buffer;
  var process$1 = process2;
  var capability = dew$5();
  var inherits2 = dew$f();
  var stream = dew2();
  var rStates = exports$5.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };
  var IncomingMessage4 = exports$5.IncomingMessage = function(xhr, response, mode, resetTimers) {
    var self2 = this || _global$2;
    stream.Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process$1.nextTick(function() {
        self2.emit("close");
      });
    });
    if (mode === "fetch") {
      let read = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          resetTimers(result.done);
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(Buffer2.from(result.value));
          read();
        }).catch(function(err) {
          resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", err);
        });
      };
      self2._fetchResponse = response;
      self2.url = response.url;
      self2.statusCode = response.status;
      self2.statusMessage = response.statusText;
      response.headers.forEach(function(header, key) {
        self2.headers[key.toLowerCase()] = header;
        self2.rawHeaders.push(key, header);
      });
      if (capability.writableStream) {
        var writable = new WritableStream({
          write: function(chunk) {
            resetTimers(false);
            return new Promise(function(resolve3, reject) {
              if (self2._destroyed) {
                reject();
              } else if (self2.push(Buffer2.from(chunk))) {
                resolve3();
              } else {
                self2._resumeFetch = resolve3;
              }
            });
          },
          close: function() {
            resetTimers(true);
            if (!self2._destroyed)
              self2.push(null);
          },
          abort: function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          }
        });
        try {
          response.body.pipeTo(writable).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
          return;
        } catch (e6) {
        }
      }
      var reader = response.body.getReader();
      read();
    } else {
      self2._xhr = xhr;
      self2._pos = 0;
      self2.url = xhr.responseURL;
      self2.statusCode = xhr.status;
      self2.statusMessage = xhr.statusText;
      var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header) {
        var matches = header.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === "set-cookie") {
            if (self2.headers[key] === void 0) {
              self2.headers[key] = [];
            }
            self2.headers[key].push(matches[2]);
          } else if (self2.headers[key] !== void 0) {
            self2.headers[key] += ", " + matches[2];
          } else {
            self2.headers[key] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!capability.overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  };
  inherits2(IncomingMessage4, stream.Readable);
  IncomingMessage4.prototype._read = function() {
    var self2 = this || _global$2;
    var resolve3 = self2._resumeFetch;
    if (resolve3) {
      self2._resumeFetch = null;
      resolve3();
    }
  };
  IncomingMessage4.prototype._onXHRProgress = function(resetTimers) {
    var self2 = this || _global$2;
    var xhr = self2._xhr;
    var response = null;
    switch (self2._mode) {
      case "text":
        response = xhr.responseText;
        if (response.length > self2._pos) {
          var newData = response.substr(self2._pos);
          if (self2._charset === "x-user-defined") {
            var buffer2 = Buffer2.alloc(newData.length);
            for (var i4 = 0; i4 < newData.length; i4++)
              buffer2[i4] = newData.charCodeAt(i4) & 255;
            self2.push(buffer2);
          } else {
            self2.push(newData, self2._charset);
          }
          self2._pos = response.length;
        }
        break;
      case "arraybuffer":
        if (xhr.readyState !== rStates.DONE || !xhr.response)
          break;
        response = xhr.response;
        self2.push(Buffer2.from(new Uint8Array(response)));
        break;
      case "moz-chunked-arraybuffer":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING || !response)
          break;
        self2.push(Buffer2.from(new Uint8Array(response)));
        break;
      case "ms-stream":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING)
          break;
        var reader = new _global$2.MSStreamReader();
        reader.onprogress = function() {
          if (reader.result.byteLength > self2._pos) {
            self2.push(Buffer2.from(new Uint8Array(reader.result.slice(self2._pos))));
            self2._pos = reader.result.byteLength;
          }
        };
        reader.onload = function() {
          resetTimers(true);
          self2.push(null);
        };
        reader.readAsArrayBuffer(response);
        break;
    }
    if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
      resetTimers(true);
      self2.push(null);
    }
  };
  return exports$5;
}
function dew$32() {
  if (_dewExec$3)
    return exports$4;
  _dewExec$3 = true;
  var Buffer2 = buffer.Buffer;
  var process$1 = process2;
  var capability = dew$5();
  var inherits2 = dew$f();
  var response = dew$4();
  var stream = dew2();
  var IncomingMessage4 = response.IncomingMessage;
  var rStates = response.readyStates;
  function decideMode(preferBinary, useFetch) {
    if (capability.fetch && useFetch) {
      return "fetch";
    } else if (capability.mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (capability.msstream) {
      return "ms-stream";
    } else if (capability.arraybuffer && preferBinary) {
      return "arraybuffer";
    } else {
      return "text";
    }
  }
  var ClientRequest4 = exports$4 = function(opts) {
    var self2 = this || _global$1;
    stream.Writable.call(self2);
    self2._opts = opts;
    self2._body = [];
    self2._headers = {};
    if (opts.auth)
      self2.setHeader("Authorization", "Basic " + Buffer2.from(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
      self2.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts.mode === "allow-wrong-content-type") {
      preferBinary = !capability.overrideMimeType;
    } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2._fetchTimer = null;
    self2._socketTimeout = null;
    self2._socketTimer = null;
    self2.on("finish", function() {
      self2._onFinish();
    });
  };
  inherits2(ClientRequest4, stream.Writable);
  ClientRequest4.prototype.setHeader = function(name, value) {
    var self2 = this || _global$1;
    var lowerName = name.toLowerCase();
    if (unsafeHeaders.indexOf(lowerName) !== -1)
      return;
    self2._headers[lowerName] = {
      name,
      value
    };
  };
  ClientRequest4.prototype.getHeader = function(name) {
    var header = (this || _global$1)._headers[name.toLowerCase()];
    if (header)
      return header.value;
    return null;
  };
  ClientRequest4.prototype.removeHeader = function(name) {
    var self2 = this || _global$1;
    delete self2._headers[name.toLowerCase()];
  };
  ClientRequest4.prototype._onFinish = function() {
    var self2 = this || _global$1;
    if (self2._destroyed)
      return;
    var opts = self2._opts;
    if ("timeout" in opts && opts.timeout !== 0) {
      self2.setTimeout(opts.timeout);
    }
    var headersObj = self2._headers;
    var body = null;
    if (opts.method !== "GET" && opts.method !== "HEAD") {
      body = new Blob(self2._body, {
        type: (headersObj["content-type"] || {}).value || ""
      });
    }
    var headersList = [];
    Object.keys(headersObj).forEach(function(keyName) {
      var name = headersObj[keyName].name;
      var value = headersObj[keyName].value;
      if (Array.isArray(value)) {
        value.forEach(function(v4) {
          headersList.push([name, v4]);
        });
      } else {
        headersList.push([name, value]);
      }
    });
    if (self2._mode === "fetch") {
      var signal = null;
      if (capability.abortController) {
        var controller = new AbortController();
        signal = controller.signal;
        self2._fetchAbortController = controller;
        if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
          self2._fetchTimer = _global$1.setTimeout(function() {
            self2.emit("requestTimeout");
            if (self2._fetchAbortController)
              self2._fetchAbortController.abort();
          }, opts.requestTimeout);
        }
      }
      _global$1.fetch(self2._opts.url, {
        method: self2._opts.method,
        headers: headersList,
        body: body || void 0,
        mode: "cors",
        credentials: opts.withCredentials ? "include" : "same-origin",
        signal
      }).then(function(response2) {
        self2._fetchResponse = response2;
        self2._resetTimers(false);
        self2._connect();
      }, function(reason) {
        self2._resetTimers(true);
        if (!self2._destroyed)
          self2.emit("error", reason);
      });
    } else {
      var xhr = self2._xhr = new _global$1.XMLHttpRequest();
      try {
        xhr.open(self2._opts.method, self2._opts.url, true);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
      if ("responseType" in xhr)
        xhr.responseType = self2._mode;
      if ("withCredentials" in xhr)
        xhr.withCredentials = !!opts.withCredentials;
      if (self2._mode === "text" && "overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      if ("requestTimeout" in opts) {
        xhr.timeout = opts.requestTimeout;
        xhr.ontimeout = function() {
          self2.emit("requestTimeout");
        };
      }
      headersList.forEach(function(header) {
        xhr.setRequestHeader(header[0], header[1]);
      });
      self2._response = null;
      xhr.onreadystatechange = function() {
        switch (xhr.readyState) {
          case rStates.LOADING:
          case rStates.DONE:
            self2._onXHRProgress();
            break;
        }
      };
      if (self2._mode === "moz-chunked-arraybuffer") {
        xhr.onprogress = function() {
          self2._onXHRProgress();
        };
      }
      xhr.onerror = function() {
        if (self2._destroyed)
          return;
        self2._resetTimers(true);
        self2.emit("error", new Error("XHR error"));
      };
      try {
        xhr.send(body);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
    }
  };
  function statusValid(xhr) {
    try {
      var status = xhr.status;
      return status !== null && status !== 0;
    } catch (e6) {
      return false;
    }
  }
  ClientRequest4.prototype._onXHRProgress = function() {
    var self2 = this || _global$1;
    self2._resetTimers(false);
    if (!statusValid(self2._xhr) || self2._destroyed)
      return;
    if (!self2._response)
      self2._connect();
    self2._response._onXHRProgress(self2._resetTimers.bind(self2));
  };
  ClientRequest4.prototype._connect = function() {
    var self2 = this || _global$1;
    if (self2._destroyed)
      return;
    self2._response = new IncomingMessage4(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
    self2._response.on("error", function(err) {
      self2.emit("error", err);
    });
    self2.emit("response", self2._response);
  };
  ClientRequest4.prototype._write = function(chunk, encoding, cb) {
    var self2 = this || _global$1;
    self2._body.push(chunk);
    cb();
  };
  ClientRequest4.prototype._resetTimers = function(done) {
    var self2 = this || _global$1;
    _global$1.clearTimeout(self2._socketTimer);
    self2._socketTimer = null;
    if (done) {
      _global$1.clearTimeout(self2._fetchTimer);
      self2._fetchTimer = null;
    } else if (self2._socketTimeout) {
      self2._socketTimer = _global$1.setTimeout(function() {
        self2.emit("timeout");
      }, self2._socketTimeout);
    }
  };
  ClientRequest4.prototype.abort = ClientRequest4.prototype.destroy = function(err) {
    var self2 = this || _global$1;
    self2._destroyed = true;
    self2._resetTimers(true);
    if (self2._response)
      self2._response._destroyed = true;
    if (self2._xhr)
      self2._xhr.abort();
    else if (self2._fetchAbortController)
      self2._fetchAbortController.abort();
    if (err)
      self2.emit("error", err);
  };
  ClientRequest4.prototype.end = function(data, encoding, cb) {
    var self2 = this || _global$1;
    if (typeof data === "function") {
      cb = data;
      data = void 0;
    }
    stream.Writable.prototype.end.call(self2, data, encoding, cb);
  };
  ClientRequest4.prototype.setTimeout = function(timeout, cb) {
    var self2 = this || _global$1;
    if (cb)
      self2.once("timeout", cb);
    self2._socketTimeout = timeout;
    self2._resetTimers(false);
  };
  ClientRequest4.prototype.flushHeaders = function() {
  };
  ClientRequest4.prototype.setNoDelay = function() {
  };
  ClientRequest4.prototype.setSocketKeepAlive = function() {
  };
  var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  return exports$4;
}
function dew$22() {
  if (_dewExec$2)
    return exports$3;
  _dewExec$2 = true;
  exports$3 = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend() {
    var target = {};
    for (var i4 = 0; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  return exports$3;
}
function dew$12() {
  if (_dewExec$1)
    return exports$2;
  _dewExec$1 = true;
  exports$2 = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  return exports$2;
}
function dew5() {
  if (_dewExec4)
    return exports$12;
  _dewExec4 = true;
  var ClientRequest4 = dew$32();
  var response = dew$4();
  var extend = dew$22();
  var statusCodes = dew$12();
  var url = h2;
  var http = exports$12;
  http.request = function(opts, cb) {
    if (typeof opts === "string")
      opts = url.parse(opts);
    else
      opts = extend(opts);
    var defaultProtocol = _global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path3 = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path3;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new ClientRequest4(opts);
    if (cb)
      req.on("response", cb);
    return req;
  };
  http.get = function get5(opts, cb) {
    var req = http.request(opts, cb);
    req.end();
    return req;
  };
  http.ClientRequest = ClientRequest4;
  http.IncomingMessage = response.IncomingMessage;
  http.Agent = function() {
  };
  http.Agent.defaultMaxSockets = 4;
  http.globalAgent = new http.Agent();
  http.STATUS_CODES = statusCodes;
  http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  return exports$12;
}
var exports$6, _dewExec$5, _global$3, exports$5, _dewExec$4, _global$2, exports$4, _dewExec$3, _global$1, exports$3, _dewExec$2, exports$2, _dewExec$1, exports$12, _dewExec4, _global, exports5, Agent, ClientRequest, IncomingMessage, METHODS, STATUS_CODES, get, globalAgent, request;
var init_http = __esm({
  "node-modules-polyfills:http"() {
    init_chunk_44e51b61();
    init_chunk_c3d025d9();
    init_chunk_2eac56ff();
    init_url();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_4ccc3a29();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_23dbec7b();
    exports$6 = {};
    _dewExec$5 = false;
    _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$5 = {};
    _dewExec$4 = false;
    _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$4 = {};
    _dewExec$3 = false;
    _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$12 = {};
    _dewExec4 = false;
    _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports5 = dew5();
    Agent = exports5.Agent;
    ClientRequest = exports5.ClientRequest;
    IncomingMessage = exports5.IncomingMessage;
    METHODS = exports5.METHODS;
    STATUS_CODES = exports5.STATUS_CODES;
    get = exports5.get;
    globalAgent = exports5.globalAgent;
    request = exports5.request;
  }
});

// node-modules-polyfills-commonjs:http
var http_exports = {};
__export(http_exports, {
  Agent: () => Agent,
  ClientRequest: () => ClientRequest,
  IncomingMessage: () => IncomingMessage,
  METHODS: () => METHODS,
  STATUS_CODES: () => STATUS_CODES,
  get: () => get,
  globalAgent: () => globalAgent,
  request: () => request
});
var init_http2 = __esm({
  "node-modules-polyfills-commonjs:http"() {
    init_http();
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/http.js
function dew$52() {
  if (_dewExec$52)
    return exports$62;
  _dewExec$52 = true;
  exports$62.fetch = isFunction2(_global$32.fetch) && isFunction2(_global$32.ReadableStream);
  exports$62.writableStream = isFunction2(_global$32.WritableStream);
  exports$62.abortController = isFunction2(_global$32.AbortController);
  var xhr;
  function getXHR() {
    if (xhr !== void 0)
      return xhr;
    if (_global$32.XMLHttpRequest) {
      xhr = new _global$32.XMLHttpRequest();
      try {
        xhr.open("GET", _global$32.XDomainRequest ? "/" : "https://example.com");
      } catch (e6) {
        xhr = null;
      }
    } else {
      xhr = null;
    }
    return xhr;
  }
  function checkTypeSupport(type2) {
    var xhr2 = getXHR();
    if (!xhr2)
      return false;
    try {
      xhr2.responseType = type2;
      return xhr2.responseType === type2;
    } catch (e6) {
    }
    return false;
  }
  exports$62.arraybuffer = exports$62.fetch || checkTypeSupport("arraybuffer");
  exports$62.msstream = !exports$62.fetch && checkTypeSupport("ms-stream");
  exports$62.mozchunkedarraybuffer = !exports$62.fetch && checkTypeSupport("moz-chunked-arraybuffer");
  exports$62.overrideMimeType = exports$62.fetch || (getXHR() ? isFunction2(getXHR().overrideMimeType) : false);
  function isFunction2(value) {
    return typeof value === "function";
  }
  xhr = null;
  return exports$62;
}
function dew$42() {
  if (_dewExec$42)
    return exports$52;
  _dewExec$42 = true;
  var Buffer2 = buffer.Buffer;
  var process$1 = process2;
  var capability = dew$52();
  var inherits2 = dew$f();
  var stream = dew2();
  var rStates = exports$52.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };
  var IncomingMessage4 = exports$52.IncomingMessage = function(xhr, response, mode, resetTimers) {
    var self2 = this || _global$22;
    stream.Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process$1.nextTick(function() {
        self2.emit("close");
      });
    });
    if (mode === "fetch") {
      let read = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          resetTimers(result.done);
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(Buffer2.from(result.value));
          read();
        }).catch(function(err) {
          resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", err);
        });
      };
      self2._fetchResponse = response;
      self2.url = response.url;
      self2.statusCode = response.status;
      self2.statusMessage = response.statusText;
      response.headers.forEach(function(header, key) {
        self2.headers[key.toLowerCase()] = header;
        self2.rawHeaders.push(key, header);
      });
      if (capability.writableStream) {
        var writable = new WritableStream({
          write: function(chunk) {
            resetTimers(false);
            return new Promise(function(resolve3, reject) {
              if (self2._destroyed) {
                reject();
              } else if (self2.push(Buffer2.from(chunk))) {
                resolve3();
              } else {
                self2._resumeFetch = resolve3;
              }
            });
          },
          close: function() {
            resetTimers(true);
            if (!self2._destroyed)
              self2.push(null);
          },
          abort: function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          }
        });
        try {
          response.body.pipeTo(writable).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
          return;
        } catch (e6) {
        }
      }
      var reader = response.body.getReader();
      read();
    } else {
      self2._xhr = xhr;
      self2._pos = 0;
      self2.url = xhr.responseURL;
      self2.statusCode = xhr.status;
      self2.statusMessage = xhr.statusText;
      var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header) {
        var matches = header.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === "set-cookie") {
            if (self2.headers[key] === void 0) {
              self2.headers[key] = [];
            }
            self2.headers[key].push(matches[2]);
          } else if (self2.headers[key] !== void 0) {
            self2.headers[key] += ", " + matches[2];
          } else {
            self2.headers[key] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!capability.overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  };
  inherits2(IncomingMessage4, stream.Readable);
  IncomingMessage4.prototype._read = function() {
    var self2 = this || _global$22;
    var resolve3 = self2._resumeFetch;
    if (resolve3) {
      self2._resumeFetch = null;
      resolve3();
    }
  };
  IncomingMessage4.prototype._onXHRProgress = function(resetTimers) {
    var self2 = this || _global$22;
    var xhr = self2._xhr;
    var response = null;
    switch (self2._mode) {
      case "text":
        response = xhr.responseText;
        if (response.length > self2._pos) {
          var newData = response.substr(self2._pos);
          if (self2._charset === "x-user-defined") {
            var buffer2 = Buffer2.alloc(newData.length);
            for (var i4 = 0; i4 < newData.length; i4++)
              buffer2[i4] = newData.charCodeAt(i4) & 255;
            self2.push(buffer2);
          } else {
            self2.push(newData, self2._charset);
          }
          self2._pos = response.length;
        }
        break;
      case "arraybuffer":
        if (xhr.readyState !== rStates.DONE || !xhr.response)
          break;
        response = xhr.response;
        self2.push(Buffer2.from(new Uint8Array(response)));
        break;
      case "moz-chunked-arraybuffer":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING || !response)
          break;
        self2.push(Buffer2.from(new Uint8Array(response)));
        break;
      case "ms-stream":
        response = xhr.response;
        if (xhr.readyState !== rStates.LOADING)
          break;
        var reader = new _global$22.MSStreamReader();
        reader.onprogress = function() {
          if (reader.result.byteLength > self2._pos) {
            self2.push(Buffer2.from(new Uint8Array(reader.result.slice(self2._pos))));
            self2._pos = reader.result.byteLength;
          }
        };
        reader.onload = function() {
          resetTimers(true);
          self2.push(null);
        };
        reader.readAsArrayBuffer(response);
        break;
    }
    if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
      resetTimers(true);
      self2.push(null);
    }
  };
  return exports$52;
}
function dew$33() {
  if (_dewExec$32)
    return exports$42;
  _dewExec$32 = true;
  var Buffer2 = buffer.Buffer;
  var process$1 = process2;
  var capability = dew$52();
  var inherits2 = dew$f();
  var response = dew$42();
  var stream = dew2();
  var IncomingMessage4 = response.IncomingMessage;
  var rStates = response.readyStates;
  function decideMode(preferBinary, useFetch) {
    if (capability.fetch && useFetch) {
      return "fetch";
    } else if (capability.mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (capability.msstream) {
      return "ms-stream";
    } else if (capability.arraybuffer && preferBinary) {
      return "arraybuffer";
    } else {
      return "text";
    }
  }
  var ClientRequest4 = exports$42 = function(opts) {
    var self2 = this || _global$12;
    stream.Writable.call(self2);
    self2._opts = opts;
    self2._body = [];
    self2._headers = {};
    if (opts.auth)
      self2.setHeader("Authorization", "Basic " + Buffer2.from(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
      self2.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts.mode === "allow-wrong-content-type") {
      preferBinary = !capability.overrideMimeType;
    } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2._fetchTimer = null;
    self2._socketTimeout = null;
    self2._socketTimer = null;
    self2.on("finish", function() {
      self2._onFinish();
    });
  };
  inherits2(ClientRequest4, stream.Writable);
  ClientRequest4.prototype.setHeader = function(name, value) {
    var self2 = this || _global$12;
    var lowerName = name.toLowerCase();
    if (unsafeHeaders.indexOf(lowerName) !== -1)
      return;
    self2._headers[lowerName] = {
      name,
      value
    };
  };
  ClientRequest4.prototype.getHeader = function(name) {
    var header = (this || _global$12)._headers[name.toLowerCase()];
    if (header)
      return header.value;
    return null;
  };
  ClientRequest4.prototype.removeHeader = function(name) {
    var self2 = this || _global$12;
    delete self2._headers[name.toLowerCase()];
  };
  ClientRequest4.prototype._onFinish = function() {
    var self2 = this || _global$12;
    if (self2._destroyed)
      return;
    var opts = self2._opts;
    if ("timeout" in opts && opts.timeout !== 0) {
      self2.setTimeout(opts.timeout);
    }
    var headersObj = self2._headers;
    var body = null;
    if (opts.method !== "GET" && opts.method !== "HEAD") {
      body = new Blob(self2._body, {
        type: (headersObj["content-type"] || {}).value || ""
      });
    }
    var headersList = [];
    Object.keys(headersObj).forEach(function(keyName) {
      var name = headersObj[keyName].name;
      var value = headersObj[keyName].value;
      if (Array.isArray(value)) {
        value.forEach(function(v4) {
          headersList.push([name, v4]);
        });
      } else {
        headersList.push([name, value]);
      }
    });
    if (self2._mode === "fetch") {
      var signal = null;
      if (capability.abortController) {
        var controller = new AbortController();
        signal = controller.signal;
        self2._fetchAbortController = controller;
        if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
          self2._fetchTimer = _global$12.setTimeout(function() {
            self2.emit("requestTimeout");
            if (self2._fetchAbortController)
              self2._fetchAbortController.abort();
          }, opts.requestTimeout);
        }
      }
      _global$12.fetch(self2._opts.url, {
        method: self2._opts.method,
        headers: headersList,
        body: body || void 0,
        mode: "cors",
        credentials: opts.withCredentials ? "include" : "same-origin",
        signal
      }).then(function(response2) {
        self2._fetchResponse = response2;
        self2._resetTimers(false);
        self2._connect();
      }, function(reason) {
        self2._resetTimers(true);
        if (!self2._destroyed)
          self2.emit("error", reason);
      });
    } else {
      var xhr = self2._xhr = new _global$12.XMLHttpRequest();
      try {
        xhr.open(self2._opts.method, self2._opts.url, true);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
      if ("responseType" in xhr)
        xhr.responseType = self2._mode;
      if ("withCredentials" in xhr)
        xhr.withCredentials = !!opts.withCredentials;
      if (self2._mode === "text" && "overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      if ("requestTimeout" in opts) {
        xhr.timeout = opts.requestTimeout;
        xhr.ontimeout = function() {
          self2.emit("requestTimeout");
        };
      }
      headersList.forEach(function(header) {
        xhr.setRequestHeader(header[0], header[1]);
      });
      self2._response = null;
      xhr.onreadystatechange = function() {
        switch (xhr.readyState) {
          case rStates.LOADING:
          case rStates.DONE:
            self2._onXHRProgress();
            break;
        }
      };
      if (self2._mode === "moz-chunked-arraybuffer") {
        xhr.onprogress = function() {
          self2._onXHRProgress();
        };
      }
      xhr.onerror = function() {
        if (self2._destroyed)
          return;
        self2._resetTimers(true);
        self2.emit("error", new Error("XHR error"));
      };
      try {
        xhr.send(body);
      } catch (err) {
        process$1.nextTick(function() {
          self2.emit("error", err);
        });
        return;
      }
    }
  };
  function statusValid(xhr) {
    try {
      var status = xhr.status;
      return status !== null && status !== 0;
    } catch (e6) {
      return false;
    }
  }
  ClientRequest4.prototype._onXHRProgress = function() {
    var self2 = this || _global$12;
    self2._resetTimers(false);
    if (!statusValid(self2._xhr) || self2._destroyed)
      return;
    if (!self2._response)
      self2._connect();
    self2._response._onXHRProgress(self2._resetTimers.bind(self2));
  };
  ClientRequest4.prototype._connect = function() {
    var self2 = this || _global$12;
    if (self2._destroyed)
      return;
    self2._response = new IncomingMessage4(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
    self2._response.on("error", function(err) {
      self2.emit("error", err);
    });
    self2.emit("response", self2._response);
  };
  ClientRequest4.prototype._write = function(chunk, encoding, cb) {
    var self2 = this || _global$12;
    self2._body.push(chunk);
    cb();
  };
  ClientRequest4.prototype._resetTimers = function(done) {
    var self2 = this || _global$12;
    _global$12.clearTimeout(self2._socketTimer);
    self2._socketTimer = null;
    if (done) {
      _global$12.clearTimeout(self2._fetchTimer);
      self2._fetchTimer = null;
    } else if (self2._socketTimeout) {
      self2._socketTimer = _global$12.setTimeout(function() {
        self2.emit("timeout");
      }, self2._socketTimeout);
    }
  };
  ClientRequest4.prototype.abort = ClientRequest4.prototype.destroy = function(err) {
    var self2 = this || _global$12;
    self2._destroyed = true;
    self2._resetTimers(true);
    if (self2._response)
      self2._response._destroyed = true;
    if (self2._xhr)
      self2._xhr.abort();
    else if (self2._fetchAbortController)
      self2._fetchAbortController.abort();
    if (err)
      self2.emit("error", err);
  };
  ClientRequest4.prototype.end = function(data, encoding, cb) {
    var self2 = this || _global$12;
    if (typeof data === "function") {
      cb = data;
      data = void 0;
    }
    stream.Writable.prototype.end.call(self2, data, encoding, cb);
  };
  ClientRequest4.prototype.setTimeout = function(timeout, cb) {
    var self2 = this || _global$12;
    if (cb)
      self2.once("timeout", cb);
    self2._socketTimeout = timeout;
    self2._resetTimers(false);
  };
  ClientRequest4.prototype.flushHeaders = function() {
  };
  ClientRequest4.prototype.setNoDelay = function() {
  };
  ClientRequest4.prototype.setSocketKeepAlive = function() {
  };
  var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  return exports$42;
}
function dew$23() {
  if (_dewExec$22)
    return exports$32;
  _dewExec$22 = true;
  exports$32 = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend() {
    var target = {};
    for (var i4 = 0; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  return exports$32;
}
function dew$13() {
  if (_dewExec$12)
    return exports$22;
  _dewExec$12 = true;
  exports$22 = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Unordered Collection",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
  return exports$22;
}
function dew6() {
  if (_dewExec5)
    return exports$13;
  _dewExec5 = true;
  var ClientRequest4 = dew$33();
  var response = dew$42();
  var extend = dew$23();
  var statusCodes = dew$13();
  var url = h2;
  var http = exports$13;
  http.request = function(opts, cb) {
    if (typeof opts === "string")
      opts = url.parse(opts);
    else
      opts = extend(opts);
    var defaultProtocol = _global2.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path3 = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path3;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new ClientRequest4(opts);
    if (cb)
      req.on("response", cb);
    return req;
  };
  http.get = function get5(opts, cb) {
    var req = http.request(opts, cb);
    req.end();
    return req;
  };
  http.ClientRequest = ClientRequest4;
  http.IncomingMessage = response.IncomingMessage;
  http.Agent = function() {
  };
  http.Agent.defaultMaxSockets = 4;
  http.globalAgent = new http.Agent();
  http.STATUS_CODES = statusCodes;
  http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  return exports$13;
}
var exports$62, _dewExec$52, _global$32, exports$52, _dewExec$42, _global$22, exports$42, _dewExec$32, _global$12, exports$32, _dewExec$22, exports$22, _dewExec$12, exports$13, _dewExec5, _global2, exports6, Agent2, ClientRequest2, IncomingMessage2, METHODS2, STATUS_CODES2, get2, globalAgent2, request2;
var init_http3 = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/http.js"() {
    init_chunk_44e51b61();
    init_chunk_c3d025d9();
    init_chunk_2eac56ff();
    init_url();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_4ccc3a29();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_23dbec7b();
    exports$62 = {};
    _dewExec$52 = false;
    _global$32 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$52 = {};
    _dewExec$42 = false;
    _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$42 = {};
    _dewExec$32 = false;
    _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports$32 = {};
    _dewExec$22 = false;
    exports$22 = {};
    _dewExec$12 = false;
    exports$13 = {};
    _dewExec5 = false;
    _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports6 = dew6();
    Agent2 = exports6.Agent;
    ClientRequest2 = exports6.ClientRequest;
    IncomingMessage2 = exports6.IncomingMessage;
    METHODS2 = exports6.METHODS;
    STATUS_CODES2 = exports6.STATUS_CODES;
    get2 = exports6.get;
    globalAgent2 = exports6.globalAgent;
    request2 = exports6.request;
  }
});

// node-modules-polyfills:https
function dew7() {
  if (_dewExec6)
    return exports$14;
  _dewExec6 = true;
  var http = exports6;
  var url = h2;
  var https = exports$14;
  for (var key in http) {
    if (http.hasOwnProperty(key))
      https[key] = http[key];
  }
  https.request = function(params, cb) {
    params = validateParams(params);
    return http.request.call(this || _global3, params, cb);
  };
  https.get = function(params, cb) {
    params = validateParams(params);
    return http.get.call(this || _global3, params, cb);
  };
  function validateParams(params) {
    if (typeof params === "string") {
      params = url.parse(params);
    }
    if (!params.protocol) {
      params.protocol = "https:";
    }
    if (params.protocol !== "https:") {
      throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
    }
    return params;
  }
  return exports$14;
}
var exports$14, _dewExec6, _global3, exports7, Agent3, ClientRequest3, IncomingMessage3, METHODS3, STATUS_CODES3, get3, globalAgent3, request3;
var init_https = __esm({
  "node-modules-polyfills:https"() {
    init_http3();
    init_url();
    init_chunk_44e51b61();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_2eac56ff();
    init_chunk_4ccc3a29();
    init_chunk_c3d025d9();
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_23dbec7b();
    exports$14 = {};
    _dewExec6 = false;
    _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
    exports7 = dew7();
    Agent3 = exports7.Agent;
    ClientRequest3 = exports7.ClientRequest;
    IncomingMessage3 = exports7.IncomingMessage;
    METHODS3 = exports7.METHODS;
    STATUS_CODES3 = exports7.STATUS_CODES;
    get3 = exports7.get;
    globalAgent3 = exports7.globalAgent;
    request3 = exports7.request;
  }
});

// node-modules-polyfills-commonjs:https
var https_exports = {};
__export(https_exports, {
  Agent: () => Agent3,
  ClientRequest: () => ClientRequest3,
  IncomingMessage: () => IncomingMessage3,
  METHODS: () => METHODS3,
  STATUS_CODES: () => STATUS_CODES3,
  get: () => get3,
  globalAgent: () => globalAgent3,
  request: () => request3
});
var init_https2 = __esm({
  "node-modules-polyfills-commonjs:https"() {
    init_https();
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/stream.js
var Readable, Writable, Duplex2, Transform, PassThrough, finished, pipeline, Stream, promises;
var init_stream = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/stream.js"() {
    init_chunk_6c718bbe();
    init_chunk_6c718bbe();
    init_util();
    init_events();
    init_chunk_4bd36a8f();
    init_chunk_44e51b61();
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    init_chunk_2eac56ff();
    init_chunk_4ccc3a29();
    Readable = exports.Readable;
    Readable.wrap = function(src, options) {
      options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
      options.destroy = function(err, callback) {
        src.destroy(err);
        callback(err);
      };
      return new Readable(options).wrap(src);
    };
    Writable = exports.Writable;
    Duplex2 = exports.Duplex;
    Transform = exports.Transform;
    PassThrough = exports.PassThrough;
    finished = exports.finished;
    pipeline = exports.pipeline;
    Stream = exports.Stream;
    promises = {
      finished: promisify(exports.finished),
      pipeline: promisify(exports.pipeline)
    };
  }
});

// node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/assert.js
function e4(e6, r6) {
  if (null == e6)
    throw new TypeError("Cannot convert first argument to object");
  for (var t4 = Object(e6), n5 = 1; n5 < arguments.length; n5++) {
    var o5 = arguments[n5];
    if (null != o5)
      for (var a4 = Object.keys(Object(o5)), l4 = 0, i4 = a4.length; l4 < i4; l4++) {
        var c4 = a4[l4], b4 = Object.getOwnPropertyDescriptor(o5, c4);
        void 0 !== b4 && b4.enumerable && (t4[c4] = o5[c4]);
      }
  }
  return t4;
}
function i$5() {
  if (a$6)
    return c$4;
  function e6(t4) {
    return (e6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
      return typeof t5;
    } : function(t5) {
      return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
    })(t4);
  }
  function n5(t4, n6) {
    return !n6 || "object" !== e6(n6) && "function" != typeof n6 ? function(t5) {
      if (void 0 === t5)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t5;
    }(t4) : n6;
  }
  function r6(t4) {
    return (r6 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
      return t5.__proto__ || Object.getPrototypeOf(t5);
    })(t4);
  }
  function o5(t4, e7) {
    return (o5 = Object.setPrototypeOf || function(t5, e8) {
      return t5.__proto__ = e8, t5;
    })(t4, e7);
  }
  a$6 = true;
  var i4, u4, l4 = {};
  function f4(t4, e7, c4) {
    c4 || (c4 = Error);
    var a4 = function(c5) {
      function a5(o6, c6, i5) {
        var u5;
        return !function(t5, e8) {
          if (!(t5 instanceof e8))
            throw new TypeError("Cannot call a class as a function");
        }(this, a5), (u5 = n5(this, r6(a5).call(this, function(t5, n6, r7) {
          return "string" == typeof e7 ? e7 : e7(t5, n6, r7);
        }(o6, c6, i5)))).code = t4, u5;
      }
      return !function(t5, e8) {
        if ("function" != typeof e8 && null !== e8)
          throw new TypeError("Super expression must either be null or a function");
        t5.prototype = Object.create(e8 && e8.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e8 && o5(t5, e8);
      }(a5, c5), a5;
    }(c4);
    l4[t4] = a4;
  }
  function s2(t4, e7) {
    if (Array.isArray(t4)) {
      var n6 = t4.length;
      return t4 = t4.map(function(t5) {
        return String(t5);
      }), n6 > 2 ? "one of ".concat(e7, " ").concat(t4.slice(0, n6 - 1).join(", "), ", or ") + t4[n6 - 1] : 2 === n6 ? "one of ".concat(e7, " ").concat(t4[0], " or ").concat(t4[1]) : "of ".concat(e7, " ").concat(t4[0]);
    }
    return "of ".concat(e7, " ").concat(String(t4));
  }
  return f4("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f4("ERR_INVALID_ARG_TYPE", function(t4, n6, r7) {
    var o6, c4, u5;
    if (void 0 === i4 && (i4 = tt()), i4("string" == typeof t4, "'name' must be a string"), "string" == typeof n6 && (c4 = "not ", n6.substr(0, c4.length) === c4) ? (o6 = "must not be", n6 = n6.replace(/^not /, "")) : o6 = "must be", function(t5, e7, n7) {
      return (void 0 === n7 || n7 > t5.length) && (n7 = t5.length), t5.substring(n7 - e7.length, n7) === e7;
    }(t4, " argument"))
      u5 = "The ".concat(t4, " ").concat(o6, " ").concat(s2(n6, "type"));
    else {
      var l5 = function(t5, e7, n7) {
        return "number" != typeof n7 && (n7 = 0), !(n7 + e7.length > t5.length) && -1 !== t5.indexOf(e7, n7);
      }(t4, ".") ? "property" : "argument";
      u5 = 'The "'.concat(t4, '" ').concat(l5, " ").concat(o6, " ").concat(s2(n6, "type"));
    }
    return u5 += ". Received type ".concat(e6(r7));
  }, TypeError), f4("ERR_INVALID_ARG_VALUE", function(e7, n6) {
    var r7 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u4 && (u4 = X);
    var o6 = u4.inspect(n6);
    return o6.length > 128 && (o6 = "".concat(o6.slice(0, 128), "...")), "The argument '".concat(e7, "' ").concat(r7, ". Received ").concat(o6);
  }, TypeError), f4("ERR_INVALID_RETURN_VALUE", function(t4, n6, r7) {
    var o6;
    return o6 = r7 && r7.constructor && r7.constructor.name ? "instance of ".concat(r7.constructor.name) : "type ".concat(e6(r7)), "Expected ".concat(t4, ' to be returned from the "').concat(n6, '"') + " function but got ".concat(o6, ".");
  }, TypeError), f4("ERR_MISSING_ARGS", function() {
    for (var t4 = arguments.length, e7 = new Array(t4), n6 = 0; n6 < t4; n6++)
      e7[n6] = arguments[n6];
    void 0 === i4 && (i4 = tt()), i4(e7.length > 0, "At least one arg needs to be specified");
    var r7 = "The ", o6 = e7.length;
    switch (e7 = e7.map(function(t5) {
      return '"'.concat(t5, '"');
    }), o6) {
      case 1:
        r7 += "".concat(e7[0], " argument");
        break;
      case 2:
        r7 += "".concat(e7[0], " and ").concat(e7[1], " arguments");
        break;
      default:
        r7 += e7.slice(0, o6 - 1).join(", "), r7 += ", and ".concat(e7[o6 - 1], " arguments");
    }
    return "".concat(r7, " must be specified");
  }, TypeError), c$4.codes = l4, c$4;
}
function f$6() {
  if (l$6)
    return u$5;
  l$6 = true;
  var n5 = T;
  function r6(t4, e6, n6) {
    return e6 in t4 ? Object.defineProperty(t4, e6, { value: n6, enumerable: true, configurable: true, writable: true }) : t4[e6] = n6, t4;
  }
  function o5(t4, e6) {
    for (var n6 = 0; n6 < e6.length; n6++) {
      var r7 = e6[n6];
      r7.enumerable = r7.enumerable || false, r7.configurable = true, "value" in r7 && (r7.writable = true), Object.defineProperty(t4, r7.key, r7);
    }
  }
  function c4(t4, e6) {
    return !e6 || "object" !== y4(e6) && "function" != typeof e6 ? a4(t4) : e6;
  }
  function a4(t4) {
    if (void 0 === t4)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t4;
  }
  function f4(t4) {
    var e6 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f4 = function(t5) {
      if (null === t5 || (n6 = t5, -1 === Function.toString.call(n6).indexOf("[native code]")))
        return t5;
      var n6;
      if ("function" != typeof t5)
        throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e6) {
        if (e6.has(t5))
          return e6.get(t5);
        e6.set(t5, r7);
      }
      function r7() {
        return p4(t5, arguments, h5(this).constructor);
      }
      return r7.prototype = Object.create(t5.prototype, { constructor: { value: r7, enumerable: false, writable: true, configurable: true } }), g4(r7, t5);
    })(t4);
  }
  function s2() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t4) {
      return false;
    }
  }
  function p4(t4, e6, n6) {
    return (p4 = s2() ? Reflect.construct : function(t5, e7, n7) {
      var r7 = [null];
      r7.push.apply(r7, e7);
      var o6 = new (Function.bind.apply(t5, r7))();
      return n7 && g4(o6, n7.prototype), o6;
    }).apply(null, arguments);
  }
  function g4(t4, e6) {
    return (g4 = Object.setPrototypeOf || function(t5, e7) {
      return t5.__proto__ = e7, t5;
    })(t4, e6);
  }
  function h5(t4) {
    return (h5 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
      return t5.__proto__ || Object.getPrototypeOf(t5);
    })(t4);
  }
  function y4(t4) {
    return (y4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
      return typeof t5;
    } : function(t5) {
      return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
    })(t4);
  }
  var b4 = X.inspect, v4 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d3(t4, e6, n6) {
    return (void 0 === n6 || n6 > t4.length) && (n6 = t4.length), t4.substring(n6 - e6.length, n6) === e6;
  }
  var m4 = "", E2 = "", w2 = "", S2 = "", j2 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O4(t4) {
    var e6 = Object.keys(t4), n6 = Object.create(Object.getPrototypeOf(t4));
    return e6.forEach(function(e7) {
      n6[e7] = t4[e7];
    }), Object.defineProperty(n6, "message", { value: t4.message }), n6;
  }
  function x2(t4) {
    return b4(t4, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q2(t4, e6, r7) {
    var o6 = "", c5 = "", a5 = 0, i4 = "", u4 = false, l4 = x2(t4), f5 = l4.split("\n"), s3 = x2(e6).split("\n"), p5 = 0, g5 = "";
    if ("strictEqual" === r7 && "object" === y4(t4) && "object" === y4(e6) && null !== t4 && null !== e6 && (r7 = "strictEqualObject"), 1 === f5.length && 1 === s3.length && f5[0] !== s3[0]) {
      var h6 = f5[0].length + s3[0].length;
      if (h6 <= 10) {
        if (!("object" === y4(t4) && null !== t4 || "object" === y4(e6) && null !== e6 || 0 === t4 && 0 === e6))
          return "".concat(j2[r7], "\n\n") + "".concat(f5[0], " !== ").concat(s3[0], "\n");
      } else if ("strictEqualObject" !== r7) {
        if (h6 < (n5.stderr && n5.stderr.isTTY ? n5.stderr.columns : 80)) {
          for (; f5[0][p5] === s3[0][p5]; )
            p5++;
          p5 > 2 && (g5 = "\n  ".concat(function(t5, e7) {
            if (e7 = Math.floor(e7), 0 == t5.length || 0 == e7)
              return "";
            var n6 = t5.length * e7;
            for (e7 = Math.floor(Math.log(e7) / Math.log(2)); e7; )
              t5 += t5, e7--;
            return t5 += t5.substring(0, n6 - t5.length);
          }(" ", p5), "^"), p5 = 0);
        }
      }
    }
    for (var b5 = f5[f5.length - 1], v5 = s3[s3.length - 1]; b5 === v5 && (p5++ < 2 ? i4 = "\n  ".concat(b5).concat(i4) : o6 = b5, f5.pop(), s3.pop(), 0 !== f5.length && 0 !== s3.length); )
      b5 = f5[f5.length - 1], v5 = s3[s3.length - 1];
    var O5 = Math.max(f5.length, s3.length);
    if (0 === O5) {
      var q3 = l4.split("\n");
      if (q3.length > 30)
        for (q3[26] = "".concat(m4, "...").concat(S2); q3.length > 27; )
          q3.pop();
      return "".concat(j2.notIdentical, "\n\n").concat(q3.join("\n"), "\n");
    }
    p5 > 3 && (i4 = "\n".concat(m4, "...").concat(S2).concat(i4), u4 = true), "" !== o6 && (i4 = "\n  ".concat(o6).concat(i4), o6 = "");
    var R3 = 0, A2 = j2[r7] + "\n".concat(E2, "+ actual").concat(S2, " ").concat(w2, "- expected").concat(S2), k2 = " ".concat(m4, "...").concat(S2, " Lines skipped");
    for (p5 = 0; p5 < O5; p5++) {
      var _2 = p5 - a5;
      if (f5.length < p5 + 1)
        _2 > 1 && p5 > 2 && (_2 > 4 ? (c5 += "\n".concat(m4, "...").concat(S2), u4 = true) : _2 > 3 && (c5 += "\n  ".concat(s3[p5 - 2]), R3++), c5 += "\n  ".concat(s3[p5 - 1]), R3++), a5 = p5, o6 += "\n".concat(w2, "-").concat(S2, " ").concat(s3[p5]), R3++;
      else if (s3.length < p5 + 1)
        _2 > 1 && p5 > 2 && (_2 > 4 ? (c5 += "\n".concat(m4, "...").concat(S2), u4 = true) : _2 > 3 && (c5 += "\n  ".concat(f5[p5 - 2]), R3++), c5 += "\n  ".concat(f5[p5 - 1]), R3++), a5 = p5, c5 += "\n".concat(E2, "+").concat(S2, " ").concat(f5[p5]), R3++;
      else {
        var T3 = s3[p5], P2 = f5[p5], I2 = P2 !== T3 && (!d3(P2, ",") || P2.slice(0, -1) !== T3);
        I2 && d3(T3, ",") && T3.slice(0, -1) === P2 && (I2 = false, P2 += ","), I2 ? (_2 > 1 && p5 > 2 && (_2 > 4 ? (c5 += "\n".concat(m4, "...").concat(S2), u4 = true) : _2 > 3 && (c5 += "\n  ".concat(f5[p5 - 2]), R3++), c5 += "\n  ".concat(f5[p5 - 1]), R3++), a5 = p5, c5 += "\n".concat(E2, "+").concat(S2, " ").concat(P2), o6 += "\n".concat(w2, "-").concat(S2, " ").concat(T3), R3 += 2) : (c5 += o6, o6 = "", 1 !== _2 && 0 !== p5 || (c5 += "\n  ".concat(P2), R3++));
      }
      if (R3 > 20 && p5 < O5 - 2)
        return "".concat(A2).concat(k2, "\n").concat(c5, "\n").concat(m4, "...").concat(S2).concat(o6, "\n") + "".concat(m4, "...").concat(S2);
    }
    return "".concat(A2).concat(u4 ? k2 : "", "\n").concat(c5).concat(o6).concat(i4).concat(g5);
  }
  var R2 = function(t4) {
    function e6(t5) {
      var r7;
      if (!function(t6, e7) {
        if (!(t6 instanceof e7))
          throw new TypeError("Cannot call a class as a function");
      }(this, e6), "object" !== y4(t5) || null === t5)
        throw new v4("options", "Object", t5);
      var o6 = t5.message, i5 = t5.operator, u5 = t5.stackStartFn, l4 = t5.actual, f5 = t5.expected, s3 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o6)
        r7 = c4(this, h5(e6).call(this, String(o6)));
      else if (n5.stderr && n5.stderr.isTTY && (n5.stderr && n5.stderr.getColorDepth && 1 !== n5.stderr.getColorDepth() ? (m4 = "\x1B[34m", E2 = "\x1B[32m", S2 = "\x1B[39m", w2 = "\x1B[31m") : (m4 = "", E2 = "", S2 = "", w2 = "")), "object" === y4(l4) && null !== l4 && "object" === y4(f5) && null !== f5 && "stack" in l4 && l4 instanceof Error && "stack" in f5 && f5 instanceof Error && (l4 = O4(l4), f5 = O4(f5)), "deepStrictEqual" === i5 || "strictEqual" === i5)
        r7 = c4(this, h5(e6).call(this, q2(l4, f5, i5)));
      else if ("notDeepStrictEqual" === i5 || "notStrictEqual" === i5) {
        var p5 = j2[i5], g5 = x2(l4).split("\n");
        if ("notStrictEqual" === i5 && "object" === y4(l4) && null !== l4 && (p5 = j2.notStrictEqualObject), g5.length > 30)
          for (g5[26] = "".concat(m4, "...").concat(S2); g5.length > 27; )
            g5.pop();
        r7 = 1 === g5.length ? c4(this, h5(e6).call(this, "".concat(p5, " ").concat(g5[0]))) : c4(this, h5(e6).call(this, "".concat(p5, "\n\n").concat(g5.join("\n"), "\n")));
      } else {
        var b5 = x2(l4), d4 = "", R3 = j2[i5];
        "notDeepEqual" === i5 || "notEqual" === i5 ? (b5 = "".concat(j2[i5], "\n\n").concat(b5)).length > 1024 && (b5 = "".concat(b5.slice(0, 1021), "...")) : (d4 = "".concat(x2(f5)), b5.length > 512 && (b5 = "".concat(b5.slice(0, 509), "...")), d4.length > 512 && (d4 = "".concat(d4.slice(0, 509), "...")), "deepEqual" === i5 || "equal" === i5 ? b5 = "".concat(R3, "\n\n").concat(b5, "\n\nshould equal\n\n") : d4 = " ".concat(i5, " ").concat(d4)), r7 = c4(this, h5(e6).call(this, "".concat(b5).concat(d4)));
      }
      return Error.stackTraceLimit = s3, r7.generatedMessage = !o6, Object.defineProperty(a4(r7), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r7.code = "ERR_ASSERTION", r7.actual = l4, r7.expected = f5, r7.operator = i5, Error.captureStackTrace && Error.captureStackTrace(a4(r7), u5), r7.stack, r7.name = "AssertionError", c4(r7);
    }
    var i4, u4;
    return !function(t5, e7) {
      if ("function" != typeof e7 && null !== e7)
        throw new TypeError("Super expression must either be null or a function");
      t5.prototype = Object.create(e7 && e7.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e7 && g4(t5, e7);
    }(e6, t4), i4 = e6, (u4 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b4.custom, value: function(t5, e7) {
      return b4(this, function(t6) {
        for (var e8 = 1; e8 < arguments.length; e8++) {
          var n6 = null != arguments[e8] ? arguments[e8] : {}, o6 = Object.keys(n6);
          "function" == typeof Object.getOwnPropertySymbols && (o6 = o6.concat(Object.getOwnPropertySymbols(n6).filter(function(t7) {
            return Object.getOwnPropertyDescriptor(n6, t7).enumerable;
          }))), o6.forEach(function(e9) {
            r6(t6, e9, n6[e9]);
          });
        }
        return t6;
      }({}, e7, { customInspect: false, depth: 0 }));
    } }]) && o5(i4.prototype, u4), e6;
  }(f4(Error));
  return u$5 = R2;
}
function s$3(t4, e6) {
  return function(t5) {
    if (Array.isArray(t5))
      return t5;
  }(t4) || function(t5, e7) {
    var n5 = [], r6 = true, o5 = false, c4 = void 0;
    try {
      for (var a4, i4 = t5[Symbol.iterator](); !(r6 = (a4 = i4.next()).done) && (n5.push(a4.value), !e7 || n5.length !== e7); r6 = true)
        ;
    } catch (t6) {
      o5 = true, c4 = t6;
    } finally {
      try {
        r6 || null == i4.return || i4.return();
      } finally {
        if (o5)
          throw c4;
      }
    }
    return n5;
  }(t4, e6) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t4) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
    return typeof t5;
  } : function(t5) {
    return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
  })(t4);
}
function m$2(t4) {
  return t4.call.bind(t4);
}
function U(t4) {
  if (0 === t4.length || t4.length > 10)
    return true;
  for (var e6 = 0; e6 < t4.length; e6++) {
    var n5 = t4.charCodeAt(e6);
    if (n5 < 48 || n5 > 57)
      return true;
  }
  return 10 === t4.length && t4 >= Math.pow(2, 32);
}
function G(t4) {
  return Object.keys(t4).filter(U).concat(v$1(t4).filter(Object.prototype.propertyIsEnumerable.bind(t4)));
}
function V(t4, e6) {
  if (t4 === e6)
    return 0;
  for (var n5 = t4.length, r6 = e6.length, o5 = 0, c4 = Math.min(n5, r6); o5 < c4; ++o5)
    if (t4[o5] !== e6[o5]) {
      n5 = t4[o5], r6 = e6[o5];
      break;
    }
  return n5 < r6 ? -1 : r6 < n5 ? 1 : 0;
}
function B(t4, e6, n5, r6) {
  if (t4 === e6)
    return 0 !== t4 || (!n5 || b$1(t4, e6));
  if (n5) {
    if ("object" !== p$3(t4))
      return "number" == typeof t4 && d$1(t4) && d$1(e6);
    if ("object" !== p$3(e6) || null === t4 || null === e6)
      return false;
    if (Object.getPrototypeOf(t4) !== Object.getPrototypeOf(e6))
      return false;
  } else {
    if (null === t4 || "object" !== p$3(t4))
      return (null === e6 || "object" !== p$3(e6)) && t4 == e6;
    if (null === e6 || "object" !== p$3(e6))
      return false;
  }
  var o5, c4, a4, i4, u4 = S(t4);
  if (u4 !== S(e6))
    return false;
  if (Array.isArray(t4)) {
    if (t4.length !== e6.length)
      return false;
    var l4 = G(t4), f4 = G(e6);
    return l4.length === f4.length && C(t4, e6, n5, r6, 1, l4);
  }
  if ("[object Object]" === u4 && (!R(t4) && R(e6) || !k(t4) && k(e6)))
    return false;
  if (q(t4)) {
    if (!q(e6) || Date.prototype.getTime.call(t4) !== Date.prototype.getTime.call(e6))
      return false;
  } else if (A$1(t4)) {
    if (!A$1(e6) || (a4 = t4, i4 = e6, !(g$1 ? a4.source === i4.source && a4.flags === i4.flags : RegExp.prototype.toString.call(a4) === RegExp.prototype.toString.call(i4))))
      return false;
  } else if (_(t4) || t4 instanceof Error) {
    if (t4.message !== e6.message || t4.name !== e6.name)
      return false;
  } else {
    if (x(t4)) {
      if (n5 || !L(t4) && !M(t4)) {
        if (!function(t5, e7) {
          return t5.byteLength === e7.byteLength && 0 === V(new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength), new Uint8Array(e7.buffer, e7.byteOffset, e7.byteLength));
        }(t4, e6))
          return false;
      } else if (!function(t5, e7) {
        if (t5.byteLength !== e7.byteLength)
          return false;
        for (var n6 = 0; n6 < t5.byteLength; n6++)
          if (t5[n6] !== e7[n6])
            return false;
        return true;
      }(t4, e6))
        return false;
      var s2 = G(t4), h5 = G(e6);
      return s2.length === h5.length && C(t4, e6, n5, r6, 0, s2);
    }
    if (k(t4))
      return !(!k(e6) || t4.size !== e6.size) && C(t4, e6, n5, r6, 2);
    if (R(t4))
      return !(!R(e6) || t4.size !== e6.size) && C(t4, e6, n5, r6, 3);
    if (O2(t4)) {
      if (c4 = e6, (o5 = t4).byteLength !== c4.byteLength || 0 !== V(new Uint8Array(o5), new Uint8Array(c4)))
        return false;
    } else if (T2(t4) && !function(t5, e7) {
      return P$1(t5) ? P$1(e7) && b$1(Number.prototype.valueOf.call(t5), Number.prototype.valueOf.call(e7)) : I(t5) ? I(e7) && String.prototype.valueOf.call(t5) === String.prototype.valueOf.call(e7) : D(t5) ? D(e7) && Boolean.prototype.valueOf.call(t5) === Boolean.prototype.valueOf.call(e7) : F(t5) ? F(e7) && BigInt.prototype.valueOf.call(t5) === BigInt.prototype.valueOf.call(e7) : N$1(e7) && Symbol.prototype.valueOf.call(t5) === Symbol.prototype.valueOf.call(e7);
    }(t4, e6))
      return false;
  }
  return C(t4, e6, n5, r6, 0);
}
function z(t4, e6) {
  return e6.filter(function(e7) {
    return w$1(t4, e7);
  });
}
function C(t4, e6, n5, r6, o5, c4) {
  if (5 === arguments.length) {
    c4 = Object.keys(t4);
    var a4 = Object.keys(e6);
    if (c4.length !== a4.length)
      return false;
  }
  for (var i4 = 0; i4 < c4.length; i4++)
    if (!E(e6, c4[i4]))
      return false;
  if (n5 && 5 === arguments.length) {
    var u4 = v$1(t4);
    if (0 !== u4.length) {
      var l4 = 0;
      for (i4 = 0; i4 < u4.length; i4++) {
        var f4 = u4[i4];
        if (w$1(t4, f4)) {
          if (!w$1(e6, f4))
            return false;
          c4.push(f4), l4++;
        } else if (w$1(e6, f4))
          return false;
      }
      var s2 = v$1(e6);
      if (u4.length !== s2.length && z(e6, s2).length !== l4)
        return false;
    } else {
      var p4 = v$1(e6);
      if (0 !== p4.length && 0 !== z(e6, p4).length)
        return false;
    }
  }
  if (0 === c4.length && (0 === o5 || 1 === o5 && 0 === t4.length || 0 === t4.size))
    return true;
  if (void 0 === r6)
    r6 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g4 = r6.val1.get(t4);
    if (void 0 !== g4) {
      var h5 = r6.val2.get(e6);
      if (void 0 !== h5)
        return g4 === h5;
    }
    r6.position++;
  }
  r6.val1.set(t4, r6.position), r6.val2.set(e6, r6.position);
  var y4 = Q(t4, e6, n5, c4, r6, o5);
  return r6.val1.delete(t4), r6.val2.delete(e6), y4;
}
function Y(t4, e6, n5, r6) {
  for (var o5 = h$1(t4), c4 = 0; c4 < o5.length; c4++) {
    var a4 = o5[c4];
    if (B(e6, a4, n5, r6))
      return t4.delete(a4), true;
  }
  return false;
}
function W(t4) {
  switch (p$3(t4)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t4 = +t4;
    case "number":
      if (d$1(t4))
        return false;
  }
  return true;
}
function H(t4, e6, n5) {
  var r6 = W(n5);
  return null != r6 ? r6 : e6.has(r6) && !t4.has(r6);
}
function J(t4, e6, n5, r6, o5) {
  var c4 = W(n5);
  if (null != c4)
    return c4;
  var a4 = e6.get(c4);
  return !(void 0 === a4 && !e6.has(c4) || !B(r6, a4, false, o5)) && (!t4.has(c4) && B(r6, a4, false, o5));
}
function K(t4, e6, n5, r6, o5, c4) {
  for (var a4 = h$1(t4), i4 = 0; i4 < a4.length; i4++) {
    var u4 = a4[i4];
    if (B(n5, u4, o5, c4) && B(r6, e6.get(u4), o5, c4))
      return t4.delete(u4), true;
  }
  return false;
}
function Q(t4, e6, n5, r6, o5, c4) {
  var a4 = 0;
  if (2 === c4) {
    if (!function(t5, e7, n6, r7) {
      for (var o6 = null, c5 = h$1(t5), a5 = 0; a5 < c5.length; a5++) {
        var i5 = c5[a5];
        if ("object" === p$3(i5) && null !== i5)
          null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(i5);
        else if (!e7.has(i5)) {
          if (n6)
            return false;
          if (!H(t5, e7, i5))
            return false;
          null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(i5);
        }
      }
      if (null !== o6) {
        for (var u5 = h$1(e7), l5 = 0; l5 < u5.length; l5++) {
          var f4 = u5[l5];
          if ("object" === p$3(f4) && null !== f4) {
            if (!Y(o6, f4, n6, r7))
              return false;
          } else if (!n6 && !t5.has(f4) && !Y(o6, f4, n6, r7))
            return false;
        }
        return 0 === o6.size;
      }
      return true;
    }(t4, e6, n5, o5))
      return false;
  } else if (3 === c4) {
    if (!function(t5, e7, n6, r7) {
      for (var o6 = null, c5 = y$2(t5), a5 = 0; a5 < c5.length; a5++) {
        var i5 = s$3(c5[a5], 2), u5 = i5[0], l5 = i5[1];
        if ("object" === p$3(u5) && null !== u5)
          null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(u5);
        else {
          var f4 = e7.get(u5);
          if (void 0 === f4 && !e7.has(u5) || !B(l5, f4, n6, r7)) {
            if (n6)
              return false;
            if (!J(t5, e7, u5, l5, r7))
              return false;
            null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(u5);
          }
        }
      }
      if (null !== o6) {
        for (var g4 = y$2(e7), h5 = 0; h5 < g4.length; h5++) {
          var b4 = s$3(g4[h5], 2), v4 = (u5 = b4[0], b4[1]);
          if ("object" === p$3(u5) && null !== u5) {
            if (!K(o6, t5, u5, v4, n6, r7))
              return false;
          } else if (!(n6 || t5.has(u5) && B(t5.get(u5), v4, false, r7) || K(o6, t5, u5, v4, false, r7)))
            return false;
        }
        return 0 === o6.size;
      }
      return true;
    }(t4, e6, n5, o5))
      return false;
  } else if (1 === c4)
    for (; a4 < t4.length; a4++) {
      if (!E(t4, a4)) {
        if (E(e6, a4))
          return false;
        for (var i4 = Object.keys(t4); a4 < i4.length; a4++) {
          var u4 = i4[a4];
          if (!E(e6, u4) || !B(t4[u4], e6[u4], n5, o5))
            return false;
        }
        return i4.length === Object.keys(e6).length;
      }
      if (!E(e6, a4) || !B(t4[a4], e6[a4], n5, o5))
        return false;
    }
  for (a4 = 0; a4 < r6.length; a4++) {
    var l4 = r6[a4];
    if (!B(t4[l4], e6[l4], n5, o5))
      return false;
  }
  return true;
}
function tt() {
  if ($$1)
    return Z;
  $$1 = true;
  var o5 = T;
  function c4(t4) {
    return (c4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
      return typeof t5;
    } : function(t5) {
      return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
    })(t4);
  }
  var a4, u4, l4 = i$5().codes, s2 = l4.ERR_AMBIGUOUS_ARGUMENT, p4 = l4.ERR_INVALID_ARG_TYPE, g4 = l4.ERR_INVALID_ARG_VALUE, h5 = l4.ERR_INVALID_RETURN_VALUE, y4 = l4.ERR_MISSING_ARGS, b4 = f$6(), v4 = X.inspect, d3 = X.types, m$12 = d3.isPromise, E2 = d3.isRegExp, w2 = Object.assign ? Object.assign : r4.assign, S2 = Object.is ? Object.is : m2;
  function j2() {
    a4 = X2.isDeepEqual, u4 = X2.isDeepStrictEqual;
  }
  var O4 = false, x2 = Z = k2, q2 = {};
  function R2(t4) {
    if (t4.message instanceof Error)
      throw t4.message;
    throw new b4(t4);
  }
  function A2(t4, e6, n5, r6) {
    if (!n5) {
      var o6 = false;
      if (0 === e6)
        o6 = true, r6 = "No value argument passed to `assert.ok()`";
      else if (r6 instanceof Error)
        throw r6;
      var c5 = new b4({ actual: n5, expected: true, message: r6, operator: "==", stackStartFn: t4 });
      throw c5.generatedMessage = o6, c5;
    }
  }
  function k2() {
    for (var t4 = arguments.length, e6 = new Array(t4), n5 = 0; n5 < t4; n5++)
      e6[n5] = arguments[n5];
    A2.apply(void 0, [k2, e6.length].concat(e6));
  }
  x2.fail = function t4(e6, n5, r6, c5, a5) {
    var i4, u5 = arguments.length;
    if (0 === u5)
      i4 = "Failed";
    else if (1 === u5)
      r6 = e6, e6 = void 0;
    else {
      if (false === O4) {
        O4 = true;
        var l5 = o5.emitWarning ? o5.emitWarning : console.warn.bind(console);
        l5("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u5 && (c5 = "!=");
    }
    if (r6 instanceof Error)
      throw r6;
    var f4 = { actual: e6, expected: n5, operator: void 0 === c5 ? "fail" : c5, stackStartFn: a5 || t4 };
    void 0 !== r6 && (f4.message = r6);
    var s3 = new b4(f4);
    throw i4 && (s3.message = i4, s3.generatedMessage = true), s3;
  }, x2.AssertionError = b4, x2.ok = k2, x2.equal = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    e6 != n5 && R2({ actual: e6, expected: n5, message: r6, operator: "==", stackStartFn: t4 });
  }, x2.notEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    e6 == n5 && R2({ actual: e6, expected: n5, message: r6, operator: "!=", stackStartFn: t4 });
  }, x2.deepEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    void 0 === a4 && j2(), a4(e6, n5) || R2({ actual: e6, expected: n5, message: r6, operator: "deepEqual", stackStartFn: t4 });
  }, x2.notDeepEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    void 0 === a4 && j2(), a4(e6, n5) && R2({ actual: e6, expected: n5, message: r6, operator: "notDeepEqual", stackStartFn: t4 });
  }, x2.deepStrictEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    void 0 === a4 && j2(), u4(e6, n5) || R2({ actual: e6, expected: n5, message: r6, operator: "deepStrictEqual", stackStartFn: t4 });
  }, x2.notDeepStrictEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    void 0 === a4 && j2();
    u4(e6, n5) && R2({ actual: e6, expected: n5, message: r6, operator: "notDeepStrictEqual", stackStartFn: t4 });
  }, x2.strictEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    S2(e6, n5) || R2({ actual: e6, expected: n5, message: r6, operator: "strictEqual", stackStartFn: t4 });
  }, x2.notStrictEqual = function t4(e6, n5, r6) {
    if (arguments.length < 2)
      throw new y4("actual", "expected");
    S2(e6, n5) && R2({ actual: e6, expected: n5, message: r6, operator: "notStrictEqual", stackStartFn: t4 });
  };
  var _2 = function t4(e6, n5, r6) {
    var o6 = this;
    !function(t5, e7) {
      if (!(t5 instanceof e7))
        throw new TypeError("Cannot call a class as a function");
    }(this, t4), n5.forEach(function(t5) {
      t5 in e6 && (void 0 !== r6 && "string" == typeof r6[t5] && E2(e6[t5]) && e6[t5].test(r6[t5]) ? o6[t5] = r6[t5] : o6[t5] = e6[t5]);
    });
  };
  function T3(t4, e6, n5, r6, o6, c5) {
    if (!(n5 in t4) || !u4(t4[n5], e6[n5])) {
      if (!r6) {
        var a5 = new _2(t4, o6), i4 = new _2(e6, o6, t4), l5 = new b4({ actual: a5, expected: i4, operator: "deepStrictEqual", stackStartFn: c5 });
        throw l5.actual = t4, l5.expected = e6, l5.operator = c5.name, l5;
      }
      R2({ actual: t4, expected: e6, message: r6, operator: c5.name, stackStartFn: c5 });
    }
  }
  function P2(t4, e6, n5, r6) {
    if ("function" != typeof e6) {
      if (E2(e6))
        return e6.test(t4);
      if (2 === arguments.length)
        throw new p4("expected", ["Function", "RegExp"], e6);
      if ("object" !== c4(t4) || null === t4) {
        var o6 = new b4({ actual: t4, expected: e6, message: n5, operator: "deepStrictEqual", stackStartFn: r6 });
        throw o6.operator = r6.name, o6;
      }
      var i4 = Object.keys(e6);
      if (e6 instanceof Error)
        i4.push("name", "message");
      else if (0 === i4.length)
        throw new g4("error", e6, "may not be an empty object");
      return void 0 === a4 && j2(), i4.forEach(function(o7) {
        "string" == typeof t4[o7] && E2(e6[o7]) && e6[o7].test(t4[o7]) || T3(t4, e6, o7, n5, i4, r6);
      }), true;
    }
    return void 0 !== e6.prototype && t4 instanceof e6 || !Error.isPrototypeOf(e6) && true === e6.call({}, t4);
  }
  function I2(t4) {
    if ("function" != typeof t4)
      throw new p4("fn", "Function", t4);
    try {
      t4();
    } catch (t5) {
      return t5;
    }
    return q2;
  }
  function D2(t4) {
    return m$12(t4) || null !== t4 && "object" === c4(t4) && "function" == typeof t4.then && "function" == typeof t4.catch;
  }
  function F2(t4) {
    return Promise.resolve().then(function() {
      var e6;
      if ("function" == typeof t4) {
        if (!D2(e6 = t4()))
          throw new h5("instance of Promise", "promiseFn", e6);
      } else {
        if (!D2(t4))
          throw new p4("promiseFn", ["Function", "Promise"], t4);
        e6 = t4;
      }
      return Promise.resolve().then(function() {
        return e6;
      }).then(function() {
        return q2;
      }).catch(function(t5) {
        return t5;
      });
    });
  }
  function N2(t4, e6, n5, r6) {
    if ("string" == typeof n5) {
      if (4 === arguments.length)
        throw new p4("error", ["Object", "Error", "Function", "RegExp"], n5);
      if ("object" === c4(e6) && null !== e6) {
        if (e6.message === n5)
          throw new s2("error/message", 'The error message "'.concat(e6.message, '" is identical to the message.'));
      } else if (e6 === n5)
        throw new s2("error/message", 'The error "'.concat(e6, '" is identical to the message.'));
      r6 = n5, n5 = void 0;
    } else if (null != n5 && "object" !== c4(n5) && "function" != typeof n5)
      throw new p4("error", ["Object", "Error", "Function", "RegExp"], n5);
    if (e6 === q2) {
      var o6 = "";
      n5 && n5.name && (o6 += " (".concat(n5.name, ")")), o6 += r6 ? ": ".concat(r6) : ".";
      var a5 = "rejects" === t4.name ? "rejection" : "exception";
      R2({ actual: void 0, expected: n5, operator: t4.name, message: "Missing expected ".concat(a5).concat(o6), stackStartFn: t4 });
    }
    if (n5 && !P2(e6, n5, r6, t4))
      throw e6;
  }
  function L2(t4, e6, n5, r6) {
    if (e6 !== q2) {
      if ("string" == typeof n5 && (r6 = n5, n5 = void 0), !n5 || P2(e6, n5)) {
        var o6 = r6 ? ": ".concat(r6) : ".", c5 = "doesNotReject" === t4.name ? "rejection" : "exception";
        R2({ actual: e6, expected: n5, operator: t4.name, message: "Got unwanted ".concat(c5).concat(o6, "\n") + 'Actual message: "'.concat(e6 && e6.message, '"'), stackStartFn: t4 });
      }
      throw e6;
    }
  }
  function M2() {
    for (var t4 = arguments.length, e6 = new Array(t4), n5 = 0; n5 < t4; n5++)
      e6[n5] = arguments[n5];
    A2.apply(void 0, [M2, e6.length].concat(e6));
  }
  return x2.throws = function t4(e6) {
    for (var n5 = arguments.length, r6 = new Array(n5 > 1 ? n5 - 1 : 0), o6 = 1; o6 < n5; o6++)
      r6[o6 - 1] = arguments[o6];
    N2.apply(void 0, [t4, I2(e6)].concat(r6));
  }, x2.rejects = function t4(e6) {
    for (var n5 = arguments.length, r6 = new Array(n5 > 1 ? n5 - 1 : 0), o6 = 1; o6 < n5; o6++)
      r6[o6 - 1] = arguments[o6];
    return F2(e6).then(function(e7) {
      return N2.apply(void 0, [t4, e7].concat(r6));
    });
  }, x2.doesNotThrow = function t4(e6) {
    for (var n5 = arguments.length, r6 = new Array(n5 > 1 ? n5 - 1 : 0), o6 = 1; o6 < n5; o6++)
      r6[o6 - 1] = arguments[o6];
    L2.apply(void 0, [t4, I2(e6)].concat(r6));
  }, x2.doesNotReject = function t4(e6) {
    for (var n5 = arguments.length, r6 = new Array(n5 > 1 ? n5 - 1 : 0), o6 = 1; o6 < n5; o6++)
      r6[o6 - 1] = arguments[o6];
    return F2(e6).then(function(e7) {
      return L2.apply(void 0, [t4, e7].concat(r6));
    });
  }, x2.ifError = function t4(e6) {
    if (null != e6) {
      var n5 = "ifError got unwanted exception: ";
      "object" === c4(e6) && "string" == typeof e6.message ? 0 === e6.message.length && e6.constructor ? n5 += e6.constructor.name : n5 += e6.message : n5 += v4(e6);
      var r6 = new b4({ actual: e6, expected: null, operator: "ifError", message: n5, stackStartFn: t4 }), o6 = e6.stack;
      if ("string" == typeof o6) {
        var a5 = o6.split("\n");
        a5.shift();
        for (var i4 = r6.stack.split("\n"), u5 = 0; u5 < a5.length; u5++) {
          var l5 = i4.indexOf(a5[u5]);
          if (-1 !== l5) {
            i4 = i4.slice(0, l5);
            break;
          }
        }
        r6.stack = "".concat(i4.join("\n"), "\n").concat(a5.join("\n"));
      }
      throw r6;
    }
  }, x2.strict = w2(M2, x2, { equal: x2.strictEqual, deepEqual: x2.deepStrictEqual, notEqual: x2.notStrictEqual, notDeepEqual: x2.notDeepStrictEqual }), x2.strict.strict = x2.strict, Z;
}
var r4, t3, e$1, r$1, n5, o5, c4, l4, i4, a4, u4, f4, p4, s2, y2, b2, g2, h3, $, j, w, r$2, e$2, o$1, n$1, a$1, c$1, l$1, u$1, f$1, t$1, f$2, e$3, l$2, t$2, n$2, o$2, r$3, e$4, o$3, t$3, n$3, y$1, a$2, i$1, d2, f$3, u$2, A, l$3, v2, P, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$1, a$4, l$5, p$2, m2, N, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E, w$1, S, j$1, O2, x, q, R, A$1, k, _, T2, P$1, I, D, F, N$1, L, M, X2, Z, $$1, et, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws;
var init_assert = __esm({
  "node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/assert.js"() {
    init_chunk_b4205b57();
    init_chunk_5decc758();
    r4 = { assign: e4, polyfill: function() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e4 });
    } };
    e$1 = Object.prototype.toString;
    r$1 = function(t4) {
      var r6 = e$1.call(t4), n5 = "[object Arguments]" === r6;
      return n5 || (n5 = "[object Array]" !== r6 && null !== t4 && "object" == typeof t4 && "number" == typeof t4.length && t4.length >= 0 && "[object Function]" === e$1.call(t4.callee)), n5;
    };
    if (!Object.keys) {
      n5 = Object.prototype.hasOwnProperty, o5 = Object.prototype.toString, c4 = r$1, l4 = Object.prototype.propertyIsEnumerable, i4 = !l4.call({ toString: null }, "toString"), a4 = l4.call(function() {
      }, "prototype"), u4 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f4 = function(t4) {
        var e6 = t4.constructor;
        return e6 && e6.prototype === t4;
      }, p4 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s2 = function() {
        if ("undefined" == typeof window)
          return false;
        for (var t4 in window)
          try {
            if (!p4["$" + t4] && n5.call(window, t4) && null !== window[t4] && "object" == typeof window[t4])
              try {
                f4(window[t4]);
              } catch (t5) {
                return true;
              }
          } catch (t5) {
            return true;
          }
        return false;
      }();
      t3 = function(t4) {
        var e6 = null !== t4 && "object" == typeof t4, r6 = "[object Function]" === o5.call(t4), l5 = c4(t4), p5 = e6 && "[object String]" === o5.call(t4), y4 = [];
        if (!e6 && !r6 && !l5)
          throw new TypeError("Object.keys called on a non-object");
        var b4 = a4 && r6;
        if (p5 && t4.length > 0 && !n5.call(t4, 0))
          for (var g4 = 0; g4 < t4.length; ++g4)
            y4.push(String(g4));
        if (l5 && t4.length > 0)
          for (var h5 = 0; h5 < t4.length; ++h5)
            y4.push(String(h5));
        else
          for (var $2 in t4)
            b4 && "prototype" === $2 || !n5.call(t4, $2) || y4.push(String($2));
        if (i4)
          for (var j2 = function(t5) {
            if ("undefined" == typeof window || !s2)
              return f4(t5);
            try {
              return f4(t5);
            } catch (t6) {
              return false;
            }
          }(t4), w2 = 0; w2 < u4.length; ++w2)
            j2 && "constructor" === u4[w2] || !n5.call(t4, u4[w2]) || y4.push(u4[w2]);
        return y4;
      };
    }
    y2 = t3;
    b2 = Array.prototype.slice;
    g2 = r$1;
    h3 = Object.keys;
    $ = h3 ? function(t4) {
      return h3(t4);
    } : y2;
    j = Object.keys;
    $.shim = function() {
      Object.keys ? function() {
        var t4 = Object.keys(arguments);
        return t4 && t4.length === arguments.length;
      }(1, 2) || (Object.keys = function(t4) {
        return g2(t4) ? j(b2.call(t4)) : j(t4);
      }) : Object.keys = $;
      return Object.keys || $;
    };
    w = $;
    r$2 = w;
    e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
    o$1 = Object.prototype.toString;
    n$1 = Array.prototype.concat;
    a$1 = Object.defineProperty;
    c$1 = a$1 && function() {
      var t4 = {};
      try {
        for (var r6 in a$1(t4, "x", { enumerable: false, value: t4 }), t4)
          return false;
        return t4.x === t4;
      } catch (t5) {
        return false;
      }
    }();
    l$1 = function(t4, r6, e6, n5) {
      var l4;
      (!(r6 in t4) || "function" == typeof (l4 = n5) && "[object Function]" === o$1.call(l4) && n5()) && (c$1 ? a$1(t4, r6, { configurable: true, enumerable: false, value: e6, writable: true }) : t4[r6] = e6);
    };
    u$1 = function(t4, o5) {
      var a4 = arguments.length > 2 ? arguments[2] : {}, c4 = r$2(o5);
      e$2 && (c4 = n$1.call(c4, Object.getOwnPropertySymbols(o5)));
      for (var u4 = 0; u4 < c4.length; u4 += 1)
        l$1(t4, c4[u4], o5[c4[u4]], a4[c4[u4]]);
    };
    u$1.supportsDescriptors = !!c$1;
    f$1 = u$1;
    t$1 = function() {
      if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
        return false;
      if ("symbol" == typeof Symbol.iterator)
        return true;
      var t4 = {}, e6 = Symbol("test"), r6 = Object(e6);
      if ("string" == typeof e6)
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(e6))
        return false;
      if ("[object Symbol]" !== Object.prototype.toString.call(r6))
        return false;
      for (e6 in t4[e6] = 42, t4)
        return false;
      if ("function" == typeof Object.keys && 0 !== Object.keys(t4).length)
        return false;
      if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t4).length)
        return false;
      var o5 = Object.getOwnPropertySymbols(t4);
      if (1 !== o5.length || o5[0] !== e6)
        return false;
      if (!Object.prototype.propertyIsEnumerable.call(t4, e6))
        return false;
      if ("function" == typeof Object.getOwnPropertyDescriptor) {
        var n5 = Object.getOwnPropertyDescriptor(t4, e6);
        if (42 !== n5.value || true !== n5.enumerable)
          return false;
      }
      return true;
    };
    f$2 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis).Symbol;
    e$3 = t$1;
    l$2 = function() {
      return "function" == typeof f$2 && ("function" == typeof Symbol && ("symbol" == typeof f$2("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
    };
    t$2 = "Function.prototype.bind called on incompatible ";
    n$2 = Array.prototype.slice;
    o$2 = Object.prototype.toString;
    r$3 = function(r6) {
      var e6 = this;
      if ("function" != typeof e6 || "[object Function]" !== o$2.call(e6))
        throw new TypeError(t$2 + e6);
      for (var p4, i4 = n$2.call(arguments, 1), c4 = function() {
        if (this instanceof p4) {
          var t4 = e6.apply(this, i4.concat(n$2.call(arguments)));
          return Object(t4) === t4 ? t4 : this;
        }
        return e6.apply(r6, i4.concat(n$2.call(arguments)));
      }, a4 = Math.max(0, e6.length - i4.length), l4 = [], u4 = 0; u4 < a4; u4++)
        l4.push("$" + u4);
      if (p4 = Function("binder", "return function (" + l4.join(",") + "){ return binder.apply(this,arguments); }")(c4), e6.prototype) {
        var y4 = function() {
        };
        y4.prototype = e6.prototype, p4.prototype = new y4(), y4.prototype = null;
      }
      return p4;
    };
    e$4 = Function.prototype.bind || r$3;
    o$3 = TypeError;
    t$3 = Object.getOwnPropertyDescriptor;
    if (t$3)
      try {
        t$3({}, "");
      } catch (r6) {
        t$3 = null;
      }
    n$3 = function() {
      throw new o$3();
    };
    y$1 = t$3 ? function() {
      try {
        return arguments.callee, n$3;
      } catch (r6) {
        try {
          return t$3(arguments, "callee").get;
        } catch (r7) {
          return n$3;
        }
      }
    }() : n$3;
    a$2 = l$2();
    i$1 = Object.getPrototypeOf || function(r6) {
      return r6.__proto__;
    };
    d2 = "undefined" == typeof Uint8Array ? void 0 : i$1(Uint8Array);
    f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$2 ? i$1([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$2 ? i$1(i$1([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$2 ? i$1((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$2 ? i$1((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$2 ? i$1(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$2 ? Symbol : void 0, "%SymbolPrototype%": a$2 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d2, "%TypedArrayPrototype%": d2 ? d2.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
    u$2 = e$4.call(Function.call, String.prototype.replace);
    A = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    l$3 = /\\(\\)?/g;
    v2 = function(r6) {
      var e6 = [];
      return u$2(r6, A, function(r7, o5, t4, n5) {
        e6[e6.length] = t4 ? u$2(n5, l$3, "$1") : o5 || r7;
      }), e6;
    };
    P = function(r6, e6) {
      if (!(r6 in f$3))
        throw new SyntaxError("intrinsic " + r6 + " does not exist!");
      if (void 0 === f$3[r6] && !e6)
        throw new o$3("intrinsic " + r6 + " exists, but is not available. Please file an issue!");
      return f$3[r6];
    };
    c$2 = function(r6, e6) {
      if ("string" != typeof r6 || 0 === r6.length)
        throw new TypeError("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && "boolean" != typeof e6)
        throw new TypeError('"allowMissing" argument must be a boolean');
      for (var n5 = v2(r6), y4 = P("%" + (n5.length > 0 ? n5[0] : "") + "%", e6), a4 = 1; a4 < n5.length; a4 += 1)
        if (null != y4)
          if (t$3 && a4 + 1 >= n5.length) {
            var i4 = t$3(y4, n5[a4]);
            if (!e6 && !(n5[a4] in y4))
              throw new o$3("base intrinsic for " + r6 + " exists, but the property is not available.");
            y4 = i4 ? i4.get || i4.value : y4[n5[a4]];
          } else
            y4 = y4[n5[a4]];
      return y4;
    };
    p$1 = e$4;
    o$4 = c$2("%Function%");
    i$2 = o$4.apply;
    a$3 = o$4.call;
    (t$4 = function() {
      return p$1.apply(a$3, arguments);
    }).apply = function() {
      return p$1.apply(i$2, arguments);
    };
    l$4 = t$4;
    i$3 = function(t4) {
      return t4 != t4;
    };
    o$5 = (r$4 = function(t4, e6) {
      return 0 === t4 && 0 === e6 ? 1 / t4 == 1 / e6 : t4 === e6 || !(!i$3(t4) || !i$3(e6));
    }, r$4);
    c$3 = (n$4 = function() {
      return "function" == typeof Object.is ? Object.is : o$5;
    }, n$4);
    f$4 = f$1;
    u$3 = f$1;
    s$1 = r$4;
    a$4 = n$4;
    l$5 = function() {
      var t4 = c$3();
      return f$4(Object, { is: t4 }, { is: function() {
        return Object.is !== t4;
      } }), t4;
    };
    p$2 = l$4(a$4(), Object);
    u$3(p$2, { getPolyfill: a$4, implementation: s$1, shim: l$5 });
    m2 = p$2;
    N = function(r6) {
      return r6 != r6;
    };
    i$4 = N;
    n$5 = (e$5 = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
    }, f$1);
    t$5 = e$5;
    u$4 = f$1;
    a$5 = N;
    m$1 = e$5;
    o$6 = function() {
      var r6 = t$5();
      return n$5(Number, { isNaN: r6 }, { isNaN: function() {
        return Number.isNaN !== r6;
      } }), r6;
    };
    s$2 = m$1();
    u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
    f$5 = s$2;
    c$4 = {};
    a$6 = false;
    u$5 = {};
    l$6 = false;
    g$1 = void 0 !== /a/g.flags;
    h$1 = function(t4) {
      var e6 = [];
      return t4.forEach(function(t5) {
        return e6.push(t5);
      }), e6;
    };
    y$2 = function(t4) {
      var e6 = [];
      return t4.forEach(function(t5, n5) {
        return e6.push([n5, t5]);
      }), e6;
    };
    b$1 = Object.is ? Object.is : m2;
    v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    d$1 = Number.isNaN ? Number.isNaN : f$5;
    E = m$2(Object.prototype.hasOwnProperty);
    w$1 = m$2(Object.prototype.propertyIsEnumerable);
    S = m$2(Object.prototype.toString);
    j$1 = X.types;
    O2 = j$1.isAnyArrayBuffer;
    x = j$1.isArrayBufferView;
    q = j$1.isDate;
    R = j$1.isMap;
    A$1 = j$1.isRegExp;
    k = j$1.isSet;
    _ = j$1.isNativeError;
    T2 = j$1.isBoxedPrimitive;
    P$1 = j$1.isNumberObject;
    I = j$1.isStringObject;
    D = j$1.isBooleanObject;
    F = j$1.isBigIntObject;
    N$1 = j$1.isSymbolObject;
    L = j$1.isFloat32Array;
    M = j$1.isFloat64Array;
    X2 = { isDeepEqual: function(t4, e6) {
      return B(t4, e6, false);
    }, isDeepStrictEqual: function(t4, e6) {
      return B(t4, e6, true);
    } };
    Z = {};
    $$1 = false;
    et = tt();
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    et.AssertionError;
    et.deepEqual;
    et.deepStrictEqual;
    et.doesNotReject;
    et.doesNotThrow;
    et.equal;
    et.fail;
    et.ifError;
    et.notDeepEqual;
    et.notDeepStrictEqual;
    et.notEqual;
    et.notStrictEqual;
    et.ok;
    et.rejects;
    et.strict;
    et.strictEqual;
    et.throws;
    AssertionError = et.AssertionError;
    deepEqual = et.deepEqual;
    deepStrictEqual = et.deepStrictEqual;
    doesNotReject = et.doesNotReject;
    doesNotThrow = et.doesNotThrow;
    equal = et.equal;
    fail = et.fail;
    ifError = et.ifError;
    notDeepEqual = et.notDeepEqual;
    notDeepStrictEqual = et.notDeepStrictEqual;
    notEqual = et.notEqual;
    notStrictEqual = et.notStrictEqual;
    ok = et.ok;
    rejects = et.rejects;
    strict = et.strict;
    strictEqual = et.strictEqual;
    throws = et.throws;
  }
});

// node-modules-polyfills:zlib
function dew$c() {
  if (_dewExec$c)
    return exports$d;
  _dewExec$c = true;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  exports$d = ZStream;
  return exports$d;
}
function dew$b() {
  if (_dewExec$b)
    return exports$c;
  _dewExec$b = true;
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports$c.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p4 in source) {
        if (_has(source, p4)) {
          obj[p4] = source[p4];
        }
      }
    }
    return obj;
  };
  exports$c.shrinkBuf = function(buf, size2) {
    if (buf.length === size2) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size2);
    }
    buf.length = size2;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i4 = 0; i4 < len; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i4, l4, len, pos, chunk, result;
      len = 0;
      for (i4 = 0, l4 = chunks.length; i4 < l4; i4++) {
        len += chunks[i4].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i4 = 0, l4 = chunks.length; i4 < l4; i4++) {
        chunk = chunks[i4];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i4 = 0; i4 < len; i4++) {
        dest[dest_offs + i4] = src[src_offs + i4];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$c.setTyped = function(on) {
    if (on) {
      exports$c.Buf8 = Uint8Array;
      exports$c.Buf16 = Uint16Array;
      exports$c.Buf32 = Int32Array;
      exports$c.assign(exports$c, fnTyped);
    } else {
      exports$c.Buf8 = Array;
      exports$c.Buf16 = Array;
      exports$c.Buf32 = Array;
      exports$c.assign(exports$c, fnUntyped);
    }
  };
  exports$c.setTyped(TYPED_OK);
  return exports$c;
}
function dew$a() {
  if (_dewExec$a)
    return exports$b;
  _dewExec$a = true;
  var utils = dew$b();
  var Z_FIXED2 = 4;
  var Z_BINARY2 = 0;
  var Z_TEXT2 = 1;
  var Z_UNKNOWN2 = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s2, w2) {
    s2.pending_buf[s2.pending++] = w2 & 255;
    s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
  }
  function send_bits(s2, value, length) {
    if (s2.bi_valid > Buf_size - length) {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      put_short(s2, s2.bi_buf);
      s2.bi_buf = value >> Buf_size - s2.bi_valid;
      s2.bi_valid += length - Buf_size;
    } else {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      s2.bi_valid += length;
    }
  }
  function send_code(s2, c4, tree) {
    send_bits(
      s2,
      tree[c4 * 2],
      tree[c4 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s2) {
    if (s2.bi_valid === 16) {
      put_short(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  }
  function gen_bitlen(s2, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h5;
    var n5, m4;
    var bits;
    var xbits;
    var f4;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h5 = s2.heap_max + 1; h5 < HEAP_SIZE; h5++) {
      n5 = s2.heap[h5];
      bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n5 * 2 + 1] = bits;
      if (n5 > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n5 >= base) {
        xbits = extra[n5 - base];
      }
      f4 = tree[n5 * 2];
      s2.opt_len += f4 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f4 * (stree[n5 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n5 = s2.bl_count[bits];
      while (n5 !== 0) {
        m4 = s2.heap[--h5];
        if (m4 > max_code) {
          continue;
        }
        if (tree[m4 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m4 * 2 + 1]) * tree[m4 * 2];
          tree[m4 * 2 + 1] = bits;
        }
        n5--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n5;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n5 = 0; n5 <= max_code; n5++) {
      var len = tree[n5 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n5 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n5;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n5 = 0; n5 < 1 << extra_lbits[code]; n5++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n5 = 0; n5 < 1 << extra_dbits[code]; n5++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n5 = 0; n5 < 1 << extra_dbits[code] - 7; n5++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n5 = 0;
    while (n5 <= 143) {
      static_ltree[n5 * 2 + 1] = 8;
      n5++;
      bl_count[8]++;
    }
    while (n5 <= 255) {
      static_ltree[n5 * 2 + 1] = 9;
      n5++;
      bl_count[9]++;
    }
    while (n5 <= 279) {
      static_ltree[n5 * 2 + 1] = 7;
      n5++;
      bl_count[7]++;
    }
    while (n5 <= 287) {
      static_ltree[n5 * 2 + 1] = 8;
      n5++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n5 = 0; n5 < D_CODES; n5++) {
      static_dtree[n5 * 2 + 1] = 5;
      static_dtree[n5 * 2] = bi_reverse(n5, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s2) {
    var n5;
    for (n5 = 0; n5 < L_CODES; n5++) {
      s2.dyn_ltree[n5 * 2] = 0;
    }
    for (n5 = 0; n5 < D_CODES; n5++) {
      s2.dyn_dtree[n5 * 2] = 0;
    }
    for (n5 = 0; n5 < BL_CODES; n5++) {
      s2.bl_tree[n5 * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.last_lit = s2.matches = 0;
  }
  function bi_windup(s2) {
    if (s2.bi_valid > 8) {
      put_short(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  }
  function copy_block(s2, buf, len, header) {
    bi_windup(s2);
    if (header) {
      put_short(s2, len);
      put_short(s2, ~len);
    }
    utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
    s2.pending += len;
  }
  function smaller(tree, n5, m4, depth) {
    var _n2 = n5 * 2;
    var _m2 = m4 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m4];
  }
  function pqdownheap(s2, tree, k2) {
    var v4 = s2.heap[k2];
    var j2 = k2 << 1;
    while (j2 <= s2.heap_len) {
      if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
        j2++;
      }
      if (smaller(tree, v4, s2.heap[j2], s2.depth)) {
        break;
      }
      s2.heap[k2] = s2.heap[j2];
      k2 = j2;
      j2 <<= 1;
    }
    s2.heap[k2] = v4;
  }
  function compress_block(s2, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s2.last_lit !== 0) {
      do {
        dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
        lc = s2.pending_buf[s2.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s2, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s2, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s2, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s2, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s2, dist, extra);
          }
        }
      } while (lx < s2.last_lit);
    }
    send_code(s2, END_BLOCK, ltree);
  }
  function build_tree(s2, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n5, m4;
    var max_code = -1;
    var node;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE;
    for (n5 = 0; n5 < elems; n5++) {
      if (tree[n5 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n5;
        s2.depth[n5] = 0;
      } else {
        tree[n5 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s2.depth[node] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n5 = s2.heap_len >> 1; n5 >= 1; n5--) {
      pqdownheap(s2, tree, n5);
    }
    node = elems;
    do {
      n5 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[
        1
        /*SMALLEST*/
      ] = s2.heap[s2.heap_len--];
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
      m4 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[--s2.heap_max] = n5;
      s2.heap[--s2.heap_max] = m4;
      tree[node * 2] = tree[n5 * 2] + tree[m4 * 2];
      s2.depth[node] = (s2.depth[n5] >= s2.depth[m4] ? s2.depth[n5] : s2.depth[m4]) + 1;
      tree[n5 * 2 + 1] = tree[m4 * 2 + 1] = node;
      s2.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s2, desc);
    gen_codes(tree, max_code, s2.bl_count);
  }
  function scan_tree(s2, tree, max_code) {
    var n5;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n5 = 0; n5 <= max_code; n5++) {
      curlen = nextlen;
      nextlen = tree[(n5 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s2.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s2.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s2, tree, max_code) {
    var n5;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n5 = 0; n5 <= max_code; n5++) {
      curlen = nextlen;
      nextlen = tree[(n5 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s2, curlen, s2.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s2, curlen, s2.bl_tree);
          count--;
        }
        send_code(s2, REP_3_6, s2.bl_tree);
        send_bits(s2, count - 3, 2);
      } else if (count <= 10) {
        send_code(s2, REPZ_3_10, s2.bl_tree);
        send_bits(s2, count - 3, 3);
      } else {
        send_code(s2, REPZ_11_138, s2.bl_tree);
        send_bits(s2, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s2) {
    var max_blindex;
    scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree(s2, s2.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s2, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s2, lcodes - 257, 5);
    send_bits(s2, dcodes - 1, 5);
    send_bits(s2, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(
        s2,
        s2.bl_tree[bl_order[rank] * 2 + 1],
        3
      );
    }
    send_tree(s2, s2.dyn_ltree, lcodes - 1);
    send_tree(s2, s2.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s2) {
    var black_mask = 4093624447;
    var n5;
    for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
      if (black_mask & 1 && s2.dyn_ltree[n5 * 2] !== 0) {
        return Z_BINARY2;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT2;
    }
    for (n5 = 32; n5 < LITERALS; n5++) {
      if (s2.dyn_ltree[n5 * 2] !== 0) {
        return Z_TEXT2;
      }
    }
    return Z_BINARY2;
  }
  var static_init_done = false;
  function _tr_init(s2) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
    s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
    s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block(s2);
  }
  function _tr_stored_block(s2, buf, stored_len, last) {
    send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s2, buf, stored_len, true);
  }
  function _tr_align(s2) {
    send_bits(s2, STATIC_TREES << 1, 3);
    send_code(s2, END_BLOCK, static_ltree);
    bi_flush(s2);
  }
  function _tr_flush_block(s2, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN2) {
        s2.strm.data_type = detect_data_type(s2);
      }
      build_tree(s2, s2.l_desc);
      build_tree(s2, s2.d_desc);
      max_blindex = build_bl_tree(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s2, buf, stored_len, last);
    } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
      send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s2, static_ltree, static_dtree);
    } else {
      send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block(s2);
    if (last) {
      bi_windup(s2);
    }
  }
  function _tr_tally(s2, dist, lc) {
    s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
    s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
    s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
    s2.last_lit++;
    if (dist === 0) {
      s2.dyn_ltree[lc * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s2.dyn_dtree[d_code(dist) * 2]++;
    }
    return s2.last_lit === s2.lit_bufsize - 1;
  }
  exports$b._tr_init = _tr_init;
  exports$b._tr_stored_block = _tr_stored_block;
  exports$b._tr_flush_block = _tr_flush_block;
  exports$b._tr_tally = _tr_tally;
  exports$b._tr_align = _tr_align;
  return exports$b;
}
function dew$9() {
  if (_dewExec$9)
    return exports$a;
  _dewExec$9 = true;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n5 = 0;
    while (len !== 0) {
      n5 = len > 2e3 ? 2e3 : len;
      len -= n5;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n5);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  exports$a = adler32;
  return exports$a;
}
function dew$82() {
  if (_dewExec$8)
    return exports$9;
  _dewExec$8 = true;
  function makeTable() {
    var c4, table = [];
    for (var n5 = 0; n5 < 256; n5++) {
      c4 = n5;
      for (var k2 = 0; k2 < 8; k2++) {
        c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
      }
      table[n5] = c4;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t4 = crcTable, end = pos + len;
    crc ^= -1;
    for (var i4 = pos; i4 < end; i4++) {
      crc = crc >>> 8 ^ t4[(crc ^ buf[i4]) & 255];
    }
    return crc ^ -1;
  }
  exports$9 = crc32;
  return exports$9;
}
function dew$72() {
  if (_dewExec$7)
    return exports$8;
  _dewExec$7 = true;
  exports$8 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return exports$8;
}
function dew$62() {
  if (_dewExec$6)
    return exports$7;
  _dewExec$6 = true;
  var utils = dew$b();
  var trees = dew$a();
  var adler32 = dew$9();
  var crc32 = dew$82();
  var msg = dew$72();
  var Z_NO_FLUSH2 = 0;
  var Z_PARTIAL_FLUSH2 = 1;
  var Z_FULL_FLUSH2 = 3;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFAULT_COMPRESSION2 = -1;
  var Z_FILTERED2 = 1;
  var Z_HUFFMAN_ONLY2 = 2;
  var Z_RLE2 = 3;
  var Z_FIXED2 = 4;
  var Z_DEFAULT_STRATEGY2 = 0;
  var Z_UNKNOWN2 = 2;
  var Z_DEFLATED2 = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f4) {
    return (f4 << 1) - (f4 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s2 = strm.state;
    var len = s2.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
    strm.next_out += len;
    s2.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s2.pending -= len;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  }
  function flush_block_only(s2, last) {
    trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
    s2.block_start = s2.strstart;
    flush_pending(s2.strm);
  }
  function put_byte(s2, b4) {
    s2.pending_buf[s2.pending++] = b4;
  }
  function putShortMSB(s2, b4) {
    s2.pending_buf[s2.pending++] = b4 >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b4 & 255;
  }
  function read_buf(strm, buf, start, size2) {
    var len = strm.avail_in;
    if (len > size2) {
      len = size2;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s2, cur_match) {
    var chain_length = s2.max_chain_length;
    var scan = s2.strstart;
    var match;
    var len;
    var best_len = s2.prev_length;
    var nice_match = s2.nice_match;
    var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s2.window;
    var wmask = s2.w_mask;
    var prev = s2.prev;
    var strend = s2.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s2.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  }
  function fill_window(s2) {
    var _w_size = s2.w_size;
    var p4, n5, m4, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        n5 = s2.hash_size;
        p4 = n5;
        do {
          m4 = s2.head[--p4];
          s2.head[p4] = m4 >= _w_size ? m4 - _w_size : 0;
        } while (--n5);
        n5 = _w_size;
        p4 = n5;
        do {
          m4 = s2.prev[--p4];
          s2.prev[p4] = m4 >= _w_size ? m4 - _w_size : 0;
        } while (--n5);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n5 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n5;
      if (s2.lookahead + s2.insert >= MIN_MATCH) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
        while (s2.insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
  }
  function deflate_stored(s2, flush) {
    var max_block_size = 65535;
    if (max_block_size > s2.pending_buf_size - 5) {
      max_block_size = s2.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s2.lookahead <= 1) {
        fill_window(s2);
        if (s2.lookahead === 0 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.strstart += s2.lookahead;
      s2.lookahead = 0;
      var max_start = s2.block_start + max_block_size;
      if (s2.strstart === 0 || s2.strstart >= max_start) {
        s2.lookahead = s2.strstart - max_start;
        s2.strstart = max_start;
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.strstart > s2.block_start) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s2, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s2, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s2, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s2.window;
    for (; ; ) {
      if (s2.lookahead <= MAX_MATCH) {
        fill_window(s2);
        if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s2, flush) {
    var bflush;
    for (; ; ) {
      if (s2.lookahead === 0) {
        fill_window(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.last_lit) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func2) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func2;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s2) {
    s2.window_size = 2 * s2.w_size;
    zero(s2.head);
    s2.max_lazy_match = configuration_table[s2.level].max_lazy;
    s2.good_match = configuration_table[s2.level].good_length;
    s2.nice_match = configuration_table[s2.level].nice_length;
    s2.max_chain_length = configuration_table[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s2;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN2;
    s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = Z_NO_FLUSH2;
    trees._tr_init(s2);
    return Z_OK2;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK2) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR2;
    }
    strm.state.gzhead = head;
    return Z_OK2;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION2) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
      return err(strm, Z_STREAM_ERROR2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s2 = new DeflateState();
    strm.state = s2;
    s2.strm = strm;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s2.window = new utils.Buf8(s2.w_size * 2);
    s2.head = new utils.Buf16(s2.hash_size);
    s2.prev = new utils.Buf16(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
    s2.d_buf = 1 * s2.lit_bufsize;
    s2.l_buf = (1 + 2) * s2.lit_bufsize;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED2, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY2);
  }
  function deflate2(strm, flush) {
    var old_flush, s2;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
    }
    s2 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH2) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
    }
    s2.strm = strm;
    old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.status === INIT_STATE) {
      if (s2.wrap === 2) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
        } else {
          put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s2.status = BUSY_STATE;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s2.status === EXTRA_STATE) {
      if (s2.gzhead.extra) {
        beg = s2.pending;
        while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              break;
            }
          }
          put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
          s2.gzindex++;
        }
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (s2.gzindex === s2.gzhead.extra.length) {
          s2.gzindex = 0;
          s2.status = NAME_STATE;
        }
      } else {
        s2.status = NAME_STATE;
      }
    }
    if (s2.status === NAME_STATE) {
      if (s2.gzhead.name) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.gzindex = 0;
          s2.status = COMMENT_STATE;
        }
      } else {
        s2.status = COMMENT_STATE;
      }
    }
    if (s2.status === COMMENT_STATE) {
      if (s2.gzhead.comment) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.status = HCRC_STATE;
        }
      } else {
        s2.status = HCRC_STATE;
      }
    }
    if (s2.status === HCRC_STATE) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending(strm);
        }
        if (s2.pending + 2 <= s2.pending_buf_size) {
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
          s2.status = BUSY_STATE;
        }
      } else {
        s2.status = BUSY_STATE;
      }
    }
    if (s2.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH2) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE) {
      var bstate = s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s2.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH2) {
          trees._tr_align(s2);
        } else if (flush !== Z_BLOCK2) {
          trees._tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH2) {
            zero(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush !== Z_FINISH2) {
      return Z_OK2;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END2;
    }
    if (s2.wrap === 2) {
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      put_byte(s2, strm.adler >> 16 & 255);
      put_byte(s2, strm.adler >> 24 & 255);
      put_byte(s2, strm.total_in & 255);
      put_byte(s2, strm.total_in >> 8 & 255);
      put_byte(s2, strm.total_in >> 16 & 255);
      put_byte(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR2) : Z_OK2;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s2;
    var str, n5;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    s2 = strm.state;
    wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
      return Z_STREAM_ERROR2;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      tmpDict = new utils.Buf8(s2.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
      dictionary = tmpDict;
      dictLength = s2.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s2);
    while (s2.lookahead >= MIN_MATCH) {
      str = s2.strstart;
      n5 = s2.lookahead - (MIN_MATCH - 1);
      do {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n5);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH - 1;
      fill_window(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK2;
  }
  exports$7.deflateInit = deflateInit;
  exports$7.deflateInit2 = deflateInit2;
  exports$7.deflateReset = deflateReset;
  exports$7.deflateResetKeep = deflateResetKeep;
  exports$7.deflateSetHeader = deflateSetHeader;
  exports$7.deflate = deflate2;
  exports$7.deflateEnd = deflateEnd;
  exports$7.deflateSetDictionary = deflateSetDictionary;
  exports$7.deflateInfo = "pako deflate (from Nodeca project)";
  return exports$7;
}
function dew$53() {
  if (_dewExec$53)
    return exports$63;
  _dewExec$53 = true;
  var BAD = 30;
  var TYPE = 12;
  exports$63 = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return exports$63;
}
function dew$43() {
  if (_dewExec$43)
    return exports$53;
  _dewExec$43 = true;
  var utils = dew$b();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  exports$53 = function inflate_table(type2, lens, lens_index, codes2, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min2 = 0, max2 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask2;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max2 = MAXBITS; max2 >= 1; max2--) {
      if (count[max2] !== 0) {
        break;
      }
    }
    if (root > max2) {
      root = max2;
    }
    if (max2 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min2 = 1; min2 < max2; min2++) {
      if (count[min2] !== 0) {
        break;
      }
    }
    if (root < min2) {
      root = min2;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min2;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask2 = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min2 = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask2) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min2;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask2;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return exports$53;
}
function dew$34() {
  if (_dewExec$33)
    return exports$43;
  _dewExec$33 = true;
  var utils = dew$b();
  var adler32 = dew$9();
  var crc32 = dew$82();
  var inflate_fast = dew$53();
  var inflate_table = dew$43();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_TREES2 = 6;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_NEED_DICT2 = 2;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFLATED2 = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q2) {
    return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK2;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR2;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK2) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate2(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n5;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK2;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT2;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK2 || flush === Z_TREES2) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES2) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n5 = here_bits + 2;
                  while (bits < n5) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n5 = here_bits + 3;
                  while (bits < n5) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n5 = here_bits + 7;
                  while (bits < n5) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {
              bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n5 = state.extra;
              while (bits < n5) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n5 = state.extra;
              while (bits < n5) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END2;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR2;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR2;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH2)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
        ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
      ret = Z_BUF_ERROR2;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK2;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR2;
    }
    state.head = head;
    head.done = false;
    return Z_OK2;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR2;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR2;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK2;
  }
  exports$43.inflateReset = inflateReset;
  exports$43.inflateReset2 = inflateReset2;
  exports$43.inflateResetKeep = inflateResetKeep;
  exports$43.inflateInit = inflateInit;
  exports$43.inflateInit2 = inflateInit2;
  exports$43.inflate = inflate2;
  exports$43.inflateEnd = inflateEnd;
  exports$43.inflateGetHeader = inflateGetHeader;
  exports$43.inflateSetDictionary = inflateSetDictionary;
  exports$43.inflateInfo = "pako inflate (from Nodeca project)";
  return exports$43;
}
function dew$24() {
  if (_dewExec$23)
    return exports$33;
  _dewExec$23 = true;
  exports$33 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return exports$33;
}
function dew$14() {
  if (_dewExec$13)
    return exports$23;
  _dewExec$13 = true;
  var Buffer2 = buffer.Buffer;
  var process$1 = process2;
  var assert2 = et;
  var Zstream = dew$c();
  var zlib_deflate = dew$62();
  var zlib_inflate = dew$34();
  var constants = dew$24();
  for (var key in constants) {
    exports$23[key] = constants[key];
  }
  exports$23.NONE = 0;
  exports$23.DEFLATE = 1;
  exports$23.INFLATE = 2;
  exports$23.GZIP = 3;
  exports$23.GUNZIP = 4;
  exports$23.DEFLATERAW = 5;
  exports$23.INFLATERAW = 6;
  exports$23.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib2(mode) {
    if (typeof mode !== "number" || mode < exports$23.DEFLATE || mode > exports$23.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib2.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports$23.UNZIP);
    if (this.mode === exports$23.DEFLATE || this.mode === exports$23.GZIP || this.mode === exports$23.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports$23.INFLATE || this.mode === exports$23.GUNZIP || this.mode === exports$23.INFLATERAW || this.mode === exports$23.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports$23.NONE;
    this.dictionary = null;
  };
  Zlib2.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports$23.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports$23.Z_NO_FLUSH && flush !== exports$23.Z_PARTIAL_FLUSH && flush !== exports$23.Z_SYNC_FLUSH && flush !== exports$23.Z_FULL_FLUSH && flush !== exports$23.Z_FINISH && flush !== exports$23.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    process$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib2.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib2.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports$23.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports$23.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports$23.GUNZIP;
            } else {
              this.mode = exports$23.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports$23.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports$23.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports$23.Z_DATA_ERROR) {
            this.err = exports$23.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports$23.GUNZIP && this.err === exports$23.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib2.prototype._checkError = function() {
    switch (this.err) {
      case exports$23.Z_OK:
      case exports$23.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports$23.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports$23.Z_STREAM_END:
        break;
      case exports$23.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib2.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports$23.Z_FILTERED || strategy === exports$23.Z_HUFFMAN_ONLY || strategy === exports$23.Z_RLE || strategy === exports$23.Z_FIXED || strategy === exports$23.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib2.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib2.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib2.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports$23.Z_NO_FLUSH;
    this.err = exports$23.Z_OK;
    if (this.mode === exports$23.GZIP || this.mode === exports$23.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports$23.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports$23.DEFLATERAW || this.mode === exports$23.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports$23.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
      case exports$23.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib2.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib2.prototype._reset = function() {
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
      case exports$23.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports$23.INFLATE:
      case exports$23.INFLATERAW:
      case exports$23.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports$23.Zlib = Zlib2;
  return exports$23;
}
function dew8() {
  if (_dewExec7)
    return exports$15;
  _dewExec7 = true;
  var process$1 = process2;
  var Buffer2 = buffer.Buffer;
  var Transform2 = exports.Transform;
  var binding = dew$14();
  var util = X;
  var assert2 = et.ok;
  var kMaxLength = buffer.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
  binding.Z_MIN_WINDOWBITS = 8;
  binding.Z_MAX_WINDOWBITS = 15;
  binding.Z_DEFAULT_WINDOWBITS = 15;
  binding.Z_MIN_CHUNK = 64;
  binding.Z_MAX_CHUNK = Infinity;
  binding.Z_DEFAULT_CHUNK = 16 * 1024;
  binding.Z_MIN_MEMLEVEL = 1;
  binding.Z_MAX_MEMLEVEL = 9;
  binding.Z_DEFAULT_MEMLEVEL = 8;
  binding.Z_MIN_LEVEL = -1;
  binding.Z_MAX_LEVEL = 9;
  binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports$15, bkey, {
        enumerable: true,
        value: binding[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding.Z_OK,
    Z_STREAM_END: binding.Z_STREAM_END,
    Z_NEED_DICT: binding.Z_NEED_DICT,
    Z_ERRNO: binding.Z_ERRNO,
    Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding.Z_DATA_ERROR,
    Z_MEM_ERROR: binding.Z_MEM_ERROR,
    Z_BUF_ERROR: binding.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports$15, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports$15.Deflate = Deflate2;
  exports$15.Inflate = Inflate2;
  exports$15.Gzip = Gzip2;
  exports$15.Gunzip = Gunzip2;
  exports$15.DeflateRaw = DeflateRaw2;
  exports$15.InflateRaw = InflateRaw2;
  exports$15.Unzip = Unzip2;
  exports$15.createDeflate = function(o5) {
    return new Deflate2(o5);
  };
  exports$15.createInflate = function(o5) {
    return new Inflate2(o5);
  };
  exports$15.createDeflateRaw = function(o5) {
    return new DeflateRaw2(o5);
  };
  exports$15.createInflateRaw = function(o5) {
    return new InflateRaw2(o5);
  };
  exports$15.createGzip = function(o5) {
    return new Gzip2(o5);
  };
  exports$15.createGunzip = function(o5) {
    return new Gunzip2(o5);
  };
  exports$15.createUnzip = function(o5) {
    return new Unzip2(o5);
  };
  exports$15.deflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Deflate2(opts), buffer2, callback);
  };
  exports$15.deflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Deflate2(opts), buffer2);
  };
  exports$15.gzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gzip2(opts), buffer2, callback);
  };
  exports$15.gzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gzip2(opts), buffer2);
  };
  exports$15.deflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new DeflateRaw2(opts), buffer2, callback);
  };
  exports$15.deflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new DeflateRaw2(opts), buffer2);
  };
  exports$15.unzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Unzip2(opts), buffer2, callback);
  };
  exports$15.unzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Unzip2(opts), buffer2);
  };
  exports$15.inflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Inflate2(opts), buffer2, callback);
  };
  exports$15.inflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Inflate2(opts), buffer2);
  };
  exports$15.gunzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gunzip2(opts), buffer2, callback);
  };
  exports$15.gunzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gunzip2(opts), buffer2);
  };
  exports$15.inflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new InflateRaw2(opts), buffer2, callback);
  };
  exports$15.inflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new InflateRaw2(opts), buffer2);
  };
  function zlibBuffer(engine, buffer2, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError);
    engine.on("end", onEnd);
    engine.end(buffer2);
    flow();
    function flow() {
      var chunk;
      while (null !== (chunk = engine.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine.once("readable", flow);
    }
    function onError(err) {
      engine.removeListener("end", onEnd);
      engine.removeListener("readable", flow);
      callback(err);
    }
    function onEnd() {
      var buf;
      var err = null;
      if (nread >= kMaxLength) {
        err = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer2.concat(buffers, nread);
      }
      buffers = [];
      engine.close();
      callback(err, buf);
    }
  }
  function zlibBufferSync(engine, buffer2) {
    if (typeof buffer2 === "string")
      buffer2 = Buffer2.from(buffer2);
    if (!Buffer2.isBuffer(buffer2))
      throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer2, flushFlag);
  }
  function Deflate2(opts) {
    if (!(this instanceof Deflate2))
      return new Deflate2(opts);
    Zlib2.call(this, opts, binding.DEFLATE);
  }
  function Inflate2(opts) {
    if (!(this instanceof Inflate2))
      return new Inflate2(opts);
    Zlib2.call(this, opts, binding.INFLATE);
  }
  function Gzip2(opts) {
    if (!(this instanceof Gzip2))
      return new Gzip2(opts);
    Zlib2.call(this, opts, binding.GZIP);
  }
  function Gunzip2(opts) {
    if (!(this instanceof Gunzip2))
      return new Gunzip2(opts);
    Zlib2.call(this, opts, binding.GUNZIP);
  }
  function DeflateRaw2(opts) {
    if (!(this instanceof DeflateRaw2))
      return new DeflateRaw2(opts);
    Zlib2.call(this, opts, binding.DEFLATERAW);
  }
  function InflateRaw2(opts) {
    if (!(this instanceof InflateRaw2))
      return new InflateRaw2(opts);
    Zlib2.call(this, opts, binding.INFLATERAW);
  }
  function Unzip2(opts) {
    if (!(this instanceof Unzip2))
      return new Unzip2(opts);
    Zlib2.call(this, opts, binding.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
  }
  function Zlib2(opts, mode) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || exports$15.Z_DEFAULT_CHUNK;
    Transform2.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
      throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
    if (opts.chunkSize) {
      if (opts.chunkSize < exports$15.Z_MIN_CHUNK || opts.chunkSize > exports$15.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts.chunkSize);
      }
    }
    if (opts.windowBits) {
      if (opts.windowBits < exports$15.Z_MIN_WINDOWBITS || opts.windowBits > exports$15.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts.windowBits);
      }
    }
    if (opts.level) {
      if (opts.level < exports$15.Z_MIN_LEVEL || opts.level > exports$15.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts.level);
      }
    }
    if (opts.memLevel) {
      if (opts.memLevel < exports$15.Z_MIN_MEMLEVEL || opts.memLevel > exports$15.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts.memLevel);
      }
    }
    if (opts.strategy) {
      if (opts.strategy != exports$15.Z_FILTERED && opts.strategy != exports$15.Z_HUFFMAN_ONLY && opts.strategy != exports$15.Z_RLE && opts.strategy != exports$15.Z_FIXED && opts.strategy != exports$15.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts.strategy);
      }
    }
    if (opts.dictionary) {
      if (!Buffer2.isBuffer(opts.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports$15.codes[errno];
      self2.emit("error", error);
    };
    var level = exports$15.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number")
      level = opts.level;
    var strategy = exports$15.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number")
      strategy = opts.strategy;
    this._handle.init(opts.windowBits || exports$15.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports$15.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer2.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib2, Transform2);
  Zlib2.prototype.params = function(level, strategy, callback) {
    if (level < exports$15.Z_MIN_LEVEL || level > exports$15.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports$15.Z_FILTERED && strategy != exports$15.Z_HUFFMAN_ONLY && strategy != exports$15.Z_RLE && strategy != exports$15.Z_FIXED && strategy != exports$15.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback)
            callback();
        }
      });
    } else {
      process$1.nextTick(callback);
    }
  };
  Zlib2.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib2.prototype._flush = function(callback) {
    this._transform(Buffer2.alloc(0), "", callback);
  };
  Zlib2.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback)
        process$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback)
        this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer2.alloc(0), "", callback);
    }
  };
  Zlib2.prototype.close = function(callback) {
    _close(this, callback);
    process$1.nextTick(emitCloseNT, this);
  };
  function _close(engine, callback) {
    if (callback)
      process$1.nextTick(callback);
    if (!engine._handle)
      return;
    engine._handle.close();
    engine._handle = null;
  }
  function emitCloseNT(self2) {
    self2.emit("close");
  }
  Zlib2.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer2.isBuffer(chunk))
      return cb(new Error("invalid input"));
    if (!this._handle)
      return cb(new Error("zlib binding closed"));
    if (last)
      flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib2.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer2.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError)
        return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async)
          return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async)
        return false;
      cb();
    }
  };
  util.inherits(Deflate2, Zlib2);
  util.inherits(Inflate2, Zlib2);
  util.inherits(Gzip2, Zlib2);
  util.inherits(Gunzip2, Zlib2);
  util.inherits(DeflateRaw2, Zlib2);
  util.inherits(InflateRaw2, Zlib2);
  util.inherits(Unzip2, Zlib2);
  return exports$15;
}
var exports$d, _dewExec$c, exports$c, _dewExec$b, exports$b, _dewExec$a, exports$a, _dewExec$9, exports$9, _dewExec$8, exports$8, _dewExec$7, exports$7, _dewExec$6, exports$63, _dewExec$53, exports$53, _dewExec$43, exports$43, _dewExec$33, exports$33, _dewExec$23, exports$23, _dewExec$13, exports$15, _dewExec7, exports8, Deflate, DeflateRaw, Gunzip, Gzip, Inflate, InflateRaw, Unzip, Z_BEST_COMPRESSION, Z_BEST_SPEED, Z_BINARY, Z_BLOCK, Z_BUF_ERROR, Z_DATA_ERROR, Z_DEFAULT_CHUNK, Z_DEFAULT_COMPRESSION, Z_DEFAULT_LEVEL, Z_DEFAULT_MEMLEVEL, Z_DEFAULT_STRATEGY, Z_DEFAULT_WINDOWBITS, Z_DEFLATED, Z_ERRNO, Z_FILTERED, Z_FINISH, Z_FIXED, Z_FULL_FLUSH, Z_HUFFMAN_ONLY, Z_MAX_CHUNK, Z_MAX_LEVEL, Z_MAX_MEMLEVEL, Z_MAX_WINDOWBITS, Z_MIN_CHUNK, Z_MIN_LEVEL, Z_MIN_MEMLEVEL, Z_MIN_WINDOWBITS, Z_NEED_DICT, Z_NO_COMPRESSION, Z_NO_FLUSH, Z_OK, Z_PARTIAL_FLUSH, Z_RLE, Z_STREAM_END, Z_STREAM_ERROR, Z_SYNC_FLUSH, Z_TEXT, Z_TREES, Z_UNKNOWN, Zlib, codes, createDeflate, createDeflateRaw, createGunzip, createGzip, createInflate, createInflateRaw, createUnzip, deflate, deflateRaw, deflateRawSync, deflateSync, gunzip, gunzipSync, gzip, gzipSync, inflate, inflateRaw, inflateRawSync, inflateSync, unzip, unzipSync;
var init_zlib = __esm({
  "node-modules-polyfills:zlib"() {
    init_chunk_44e51b61();
    init_stream();
    init_assert();
    init_chunk_2eac56ff();
    init_util();
    init_chunk_6c718bbe();
    init_chunk_b4205b57();
    init_chunk_4bd36a8f();
    init_chunk_ce0fbc82();
    init_chunk_5decc758();
    init_chunk_4ccc3a29();
    init_events();
    exports$d = {};
    _dewExec$c = false;
    exports$c = {};
    _dewExec$b = false;
    exports$b = {};
    _dewExec$a = false;
    exports$a = {};
    _dewExec$9 = false;
    exports$9 = {};
    _dewExec$8 = false;
    exports$8 = {};
    _dewExec$7 = false;
    exports$7 = {};
    _dewExec$6 = false;
    exports$63 = {};
    _dewExec$53 = false;
    exports$53 = {};
    _dewExec$43 = false;
    exports$43 = {};
    _dewExec$33 = false;
    exports$33 = {};
    _dewExec$23 = false;
    exports$23 = {};
    _dewExec$13 = false;
    exports$15 = {};
    _dewExec7 = false;
    exports8 = dew8();
    exports8["codes"];
    exports8["Deflate"];
    exports8["Inflate"];
    exports8["Gzip"];
    exports8["Gunzip"];
    exports8["DeflateRaw"];
    exports8["InflateRaw"];
    exports8["Unzip"];
    exports8["createDeflate"];
    exports8["createInflate"];
    exports8["createDeflateRaw"];
    exports8["createInflateRaw"];
    exports8["createGzip"];
    exports8["createGunzip"];
    exports8["createUnzip"];
    exports8["deflate"];
    exports8["deflateSync"];
    exports8["gzip"];
    exports8["gzipSync"];
    exports8["deflateRaw"];
    exports8["deflateRawSync"];
    exports8["unzip"];
    exports8["unzipSync"];
    exports8["inflate"];
    exports8["inflateSync"];
    exports8["gunzip"];
    exports8["gunzipSync"];
    exports8["inflateRaw"];
    exports8["inflateRawSync"];
    Deflate = exports8.Deflate;
    DeflateRaw = exports8.DeflateRaw;
    Gunzip = exports8.Gunzip;
    Gzip = exports8.Gzip;
    Inflate = exports8.Inflate;
    InflateRaw = exports8.InflateRaw;
    Unzip = exports8.Unzip;
    Z_BEST_COMPRESSION = exports8.Z_BEST_COMPRESSION;
    Z_BEST_SPEED = exports8.Z_BEST_SPEED;
    Z_BINARY = exports8.Z_BINARY;
    Z_BLOCK = exports8.Z_BLOCK;
    Z_BUF_ERROR = exports8.Z_BUF_ERROR;
    Z_DATA_ERROR = exports8.Z_DATA_ERROR;
    Z_DEFAULT_CHUNK = exports8.Z_DEFAULT_CHUNK;
    Z_DEFAULT_COMPRESSION = exports8.Z_DEFAULT_COMPRESSION;
    Z_DEFAULT_LEVEL = exports8.Z_DEFAULT_LEVEL;
    Z_DEFAULT_MEMLEVEL = exports8.Z_DEFAULT_MEMLEVEL;
    Z_DEFAULT_STRATEGY = exports8.Z_DEFAULT_STRATEGY;
    Z_DEFAULT_WINDOWBITS = exports8.Z_DEFAULT_WINDOWBITS;
    Z_DEFLATED = exports8.Z_DEFLATED;
    Z_ERRNO = exports8.Z_ERRNO;
    Z_FILTERED = exports8.Z_FILTERED;
    Z_FINISH = exports8.Z_FINISH;
    Z_FIXED = exports8.Z_FIXED;
    Z_FULL_FLUSH = exports8.Z_FULL_FLUSH;
    Z_HUFFMAN_ONLY = exports8.Z_HUFFMAN_ONLY;
    Z_MAX_CHUNK = exports8.Z_MAX_CHUNK;
    Z_MAX_LEVEL = exports8.Z_MAX_LEVEL;
    Z_MAX_MEMLEVEL = exports8.Z_MAX_MEMLEVEL;
    Z_MAX_WINDOWBITS = exports8.Z_MAX_WINDOWBITS;
    Z_MIN_CHUNK = exports8.Z_MIN_CHUNK;
    Z_MIN_LEVEL = exports8.Z_MIN_LEVEL;
    Z_MIN_MEMLEVEL = exports8.Z_MIN_MEMLEVEL;
    Z_MIN_WINDOWBITS = exports8.Z_MIN_WINDOWBITS;
    Z_NEED_DICT = exports8.Z_NEED_DICT;
    Z_NO_COMPRESSION = exports8.Z_NO_COMPRESSION;
    Z_NO_FLUSH = exports8.Z_NO_FLUSH;
    Z_OK = exports8.Z_OK;
    Z_PARTIAL_FLUSH = exports8.Z_PARTIAL_FLUSH;
    Z_RLE = exports8.Z_RLE;
    Z_STREAM_END = exports8.Z_STREAM_END;
    Z_STREAM_ERROR = exports8.Z_STREAM_ERROR;
    Z_SYNC_FLUSH = exports8.Z_SYNC_FLUSH;
    Z_TEXT = exports8.Z_TEXT;
    Z_TREES = exports8.Z_TREES;
    Z_UNKNOWN = exports8.Z_UNKNOWN;
    Zlib = exports8.Zlib;
    codes = exports8.codes;
    createDeflate = exports8.createDeflate;
    createDeflateRaw = exports8.createDeflateRaw;
    createGunzip = exports8.createGunzip;
    createGzip = exports8.createGzip;
    createInflate = exports8.createInflate;
    createInflateRaw = exports8.createInflateRaw;
    createUnzip = exports8.createUnzip;
    deflate = exports8.deflate;
    deflateRaw = exports8.deflateRaw;
    deflateRawSync = exports8.deflateRawSync;
    deflateSync = exports8.deflateSync;
    gunzip = exports8.gunzip;
    gunzipSync = exports8.gunzipSync;
    gzip = exports8.gzip;
    gzipSync = exports8.gzipSync;
    inflate = exports8.inflate;
    inflateRaw = exports8.inflateRaw;
    inflateRawSync = exports8.inflateRawSync;
    inflateSync = exports8.inflateSync;
    unzip = exports8.unzip;
    unzipSync = exports8.unzipSync;
  }
});

// node-modules-polyfills-commonjs:zlib
var zlib_exports = {};
__export(zlib_exports, {
  Deflate: () => Deflate,
  DeflateRaw: () => DeflateRaw,
  Gunzip: () => Gunzip,
  Gzip: () => Gzip,
  Inflate: () => Inflate,
  InflateRaw: () => InflateRaw,
  Unzip: () => Unzip,
  Z_BEST_COMPRESSION: () => Z_BEST_COMPRESSION,
  Z_BEST_SPEED: () => Z_BEST_SPEED,
  Z_BINARY: () => Z_BINARY,
  Z_BLOCK: () => Z_BLOCK,
  Z_BUF_ERROR: () => Z_BUF_ERROR,
  Z_DATA_ERROR: () => Z_DATA_ERROR,
  Z_DEFAULT_CHUNK: () => Z_DEFAULT_CHUNK,
  Z_DEFAULT_COMPRESSION: () => Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_LEVEL: () => Z_DEFAULT_LEVEL,
  Z_DEFAULT_MEMLEVEL: () => Z_DEFAULT_MEMLEVEL,
  Z_DEFAULT_STRATEGY: () => Z_DEFAULT_STRATEGY,
  Z_DEFAULT_WINDOWBITS: () => Z_DEFAULT_WINDOWBITS,
  Z_DEFLATED: () => Z_DEFLATED,
  Z_ERRNO: () => Z_ERRNO,
  Z_FILTERED: () => Z_FILTERED,
  Z_FINISH: () => Z_FINISH,
  Z_FIXED: () => Z_FIXED,
  Z_FULL_FLUSH: () => Z_FULL_FLUSH,
  Z_HUFFMAN_ONLY: () => Z_HUFFMAN_ONLY,
  Z_MAX_CHUNK: () => Z_MAX_CHUNK,
  Z_MAX_LEVEL: () => Z_MAX_LEVEL,
  Z_MAX_MEMLEVEL: () => Z_MAX_MEMLEVEL,
  Z_MAX_WINDOWBITS: () => Z_MAX_WINDOWBITS,
  Z_MIN_CHUNK: () => Z_MIN_CHUNK,
  Z_MIN_LEVEL: () => Z_MIN_LEVEL,
  Z_MIN_MEMLEVEL: () => Z_MIN_MEMLEVEL,
  Z_MIN_WINDOWBITS: () => Z_MIN_WINDOWBITS,
  Z_NEED_DICT: () => Z_NEED_DICT,
  Z_NO_COMPRESSION: () => Z_NO_COMPRESSION,
  Z_NO_FLUSH: () => Z_NO_FLUSH,
  Z_OK: () => Z_OK,
  Z_PARTIAL_FLUSH: () => Z_PARTIAL_FLUSH,
  Z_RLE: () => Z_RLE,
  Z_STREAM_END: () => Z_STREAM_END,
  Z_STREAM_ERROR: () => Z_STREAM_ERROR,
  Z_SYNC_FLUSH: () => Z_SYNC_FLUSH,
  Z_TEXT: () => Z_TEXT,
  Z_TREES: () => Z_TREES,
  Z_UNKNOWN: () => Z_UNKNOWN,
  Zlib: () => Zlib,
  codes: () => codes,
  createDeflate: () => createDeflate,
  createDeflateRaw: () => createDeflateRaw,
  createGunzip: () => createGunzip,
  createGzip: () => createGzip,
  createInflate: () => createInflate,
  createInflateRaw: () => createInflateRaw,
  createUnzip: () => createUnzip,
  deflate: () => deflate,
  deflateRaw: () => deflateRaw,
  deflateRawSync: () => deflateRawSync,
  deflateSync: () => deflateSync,
  gunzip: () => gunzip,
  gunzipSync: () => gunzipSync,
  gzip: () => gzip,
  gzipSync: () => gzipSync,
  inflate: () => inflate,
  inflateRaw: () => inflateRaw,
  inflateRawSync: () => inflateRawSync,
  inflateSync: () => inflateSync,
  unzip: () => unzip,
  unzipSync: () => unzipSync
});
var init_zlib2 = __esm({
  "node-modules-polyfills-commonjs:zlib"() {
    init_zlib();
  }
});

// node-modules-polyfills:util
var _extend, callbackify, debuglog, deprecate, format2, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject2, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify2, types, TextEncoder2, TextDecoder2;
var init_util2 = __esm({
  "node-modules-polyfills:util"() {
    init_chunk_ce0fbc82();
    init_chunk_b4205b57();
    init_chunk_b4205b57();
    init_chunk_5decc758();
    _extend = X._extend;
    callbackify = X.callbackify;
    debuglog = X.debuglog;
    deprecate = X.deprecate;
    format2 = X.format;
    inherits = X.inherits;
    inspect = X.inspect;
    isArray = X.isArray;
    isBoolean = X.isBoolean;
    isBuffer = X.isBuffer;
    isDate = X.isDate;
    isError = X.isError;
    isFunction = X.isFunction;
    isNull = X.isNull;
    isNullOrUndefined = X.isNullOrUndefined;
    isNumber = X.isNumber;
    isObject2 = X.isObject;
    isPrimitive = X.isPrimitive;
    isRegExp = X.isRegExp;
    isString = X.isString;
    isSymbol = X.isSymbol;
    isUndefined = X.isUndefined;
    log = X.log;
    promisify2 = X.promisify;
    types = X.types;
    TextEncoder2 = X.TextEncoder = globalThis.TextEncoder;
    TextDecoder2 = X.TextDecoder = globalThis.TextDecoder;
  }
});

// node-modules-polyfills-commonjs:util
var util_exports = {};
__export(util_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2,
  _extend: () => _extend,
  callbackify: () => callbackify,
  debuglog: () => debuglog,
  deprecate: () => deprecate,
  format: () => format2,
  inherits: () => inherits,
  inspect: () => inspect,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isBuffer: () => isBuffer,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction,
  isNull: () => isNull,
  isNullOrUndefined: () => isNullOrUndefined,
  isNumber: () => isNumber,
  isObject: () => isObject2,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isUndefined: () => isUndefined,
  log: () => log,
  promisify: () => promisify2,
  types: () => types
});
var init_util3 = __esm({
  "node-modules-polyfills-commonjs:util"() {
    init_util2();
  }
});

// node-modules-polyfills:url
function r5() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function O3(t4, s2, h5) {
  if (t4 && a3.isObject(t4) && t4 instanceof r5)
    return t4;
  var e6 = new r5();
  return e6.parse(t4, s2, h5), e6;
}
function dew9() {
  if (_dewExec8)
    return exports9;
  _dewExec8 = true;
  var process3 = T;
  function assertPath(path3) {
    if (typeof path3 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path3));
    }
  }
  function normalizeStringPosix(path3, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i4 = 0; i4 <= path3.length; ++i4) {
      if (i4 < path3.length)
        code = path3.charCodeAt(i4);
      else if (code === 47)
        break;
      else
        code = 47;
      if (code === 47) {
        if (lastSlash === i4 - 1 || dots === 1)
          ;
        else if (lastSlash !== i4 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i4;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i4;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path3.slice(lastSlash + 1, i4);
          else
            res = path3.slice(lastSlash + 1, i4);
          lastSegmentLength = i4 - lastSlash - 1;
        }
        lastSlash = i4;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd;
      for (var i4 = arguments.length - 1; i4 >= -1 && !resolvedAbsolute; i4--) {
        var path3;
        if (i4 >= 0)
          path3 = arguments[i4];
        else {
          if (cwd === void 0)
            cwd = process3.cwd();
          path3 = cwd;
        }
        assertPath(path3);
        if (path3.length === 0) {
          continue;
        }
        resolvedPath = path3 + "/" + resolvedPath;
        resolvedAbsolute = path3.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
          return "/" + resolvedPath;
        else
          return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var isAbsolute = path3.charCodeAt(0) === 47;
      var trailingSeparator = path3.charCodeAt(path3.length - 1) === 47;
      path3 = normalizeStringPosix(path3, !isAbsolute);
      if (path3.length === 0 && !isAbsolute)
        path3 = ".";
      if (path3.length > 0 && trailingSeparator)
        path3 += "/";
      if (isAbsolute)
        return "/" + path3;
      return path3;
    },
    isAbsolute: function isAbsolute(path3) {
      assertPath(path3);
      return path3.length > 0 && path3.charCodeAt(0) === 47;
    },
    join: function join() {
      if (arguments.length === 0)
        return ".";
      var joined;
      for (var i4 = 0; i4 < arguments.length; ++i4) {
        var arg = arguments[i4];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0)
            joined = arg;
          else
            joined += "/" + arg;
        }
      }
      if (joined === void 0)
        return ".";
      return posix.normalize(joined);
    },
    relative: function relative(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to)
        return "";
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to)
        return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47)
          break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47)
          break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i4 = 0;
      for (; i4 <= length; ++i4) {
        if (i4 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i4) === 47) {
              return to.slice(toStart + i4 + 1);
            } else if (i4 === 0) {
              return to.slice(toStart + i4);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i4) === 47) {
              lastCommonSep = i4;
            } else if (i4 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i4);
        var toCode = to.charCodeAt(toStart + i4);
        if (fromCode !== toCode)
          break;
        else if (fromCode === 47)
          lastCommonSep = i4;
      }
      var out = "";
      for (i4 = fromStart + lastCommonSep + 1; i4 <= fromEnd; ++i4) {
        if (i4 === fromEnd || from.charCodeAt(i4) === 47) {
          if (out.length === 0)
            out += "..";
          else
            out += "/..";
        }
      }
      if (out.length > 0)
        return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47)
          ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong(path3) {
      return path3;
    },
    dirname: function dirname(path3) {
      assertPath(path3);
      if (path3.length === 0)
        return ".";
      var code = path3.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i4 = path3.length - 1; i4 >= 1; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            end = i4;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path3.slice(0, end);
    },
    basename: function basename(path3, ext) {
      if (ext !== void 0 && typeof ext !== "string")
        throw new TypeError('"ext" argument must be a string');
      assertPath(path3);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i4;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path3.length) {
        if (ext.length === path3.length && ext === path3)
          return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          var code = path3.charCodeAt(i4);
          if (code === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i4 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i4;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end)
          end = firstNonSlashEnd;
        else if (end === -1)
          end = path3.length;
        return path3.slice(start, end);
      } else {
        for (i4 = path3.length - 1; i4 >= 0; --i4) {
          if (path3.charCodeAt(i4) === 47) {
            if (!matchedSlash) {
              start = i4 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i4 + 1;
          }
        }
        if (end === -1)
          return "";
        return path3.slice(start, end);
      }
    },
    extname: function extname(path3) {
      assertPath(path3);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i4 = path3.length - 1; i4 >= 0; --i4) {
        var code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path3.slice(startDot, end);
    },
    format: function format4(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path3) {
      assertPath(path3);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path3.length === 0)
        return ret;
      var code = path3.charCodeAt(0);
      var isAbsolute = code === 47;
      var start;
      if (isAbsolute) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i4 = path3.length - 1;
      var preDotState = 0;
      for (; i4 >= start; --i4) {
        code = path3.charCodeAt(i4);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i4 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i4 + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i4;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path3.slice(1, end);
          else
            ret.base = ret.name = path3.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path3.slice(1, startDot);
          ret.base = path3.slice(1, end);
        } else {
          ret.name = path3.slice(startPart, startDot);
          ret.base = path3.slice(startPart, end);
        }
        ret.ext = path3.slice(startDot, end);
      }
      if (startPart > 0)
        ret.dir = path3.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.posix = posix;
  exports9 = posix;
  return exports9;
}
function fileURLToPath$12(path3) {
  if (typeof path3 === "string")
    path3 = new URL(path3);
  else if (!(path3 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path3.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$12 ? getPathFromURLWin$12(path3) : getPathFromURLPosix$12(path3);
}
function getPathFromURLWin$12(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$12, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep = pathname[2];
    if (letter < CHAR_LOWERCASE_A$12 || letter > CHAR_LOWERCASE_Z$12 || // a..z A..Z
    sep !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$12(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$12(filepath) {
  let resolved = path2.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$12 || isWindows$12 && filePathLast === CHAR_BACKWARD_SLASH$12) && resolved[resolved.length - 1] !== path2.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx$12, "%25");
  if (!isWindows$12 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$12, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx$12, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$12, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx$12, "%09");
  outURL.pathname = resolved;
  return outURL;
}
function fileURLToPath2(path3) {
  if (typeof path3 === "string")
    path3 = new URL(path3);
  else if (!(path3 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path3.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows2 ? getPathFromURLWin2(path3) : getPathFromURLPosix2(path3);
}
function getPathFromURLWin2(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n5 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx2, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep = pathname[2];
    if (letter < CHAR_LOWERCASE_A2 || letter > CHAR_LOWERCASE_Z2 || // a..z A..Z
    sep !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix2(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n5 = 0; n5 < pathname.length; n5++) {
    if (pathname[n5] === "%") {
      const third = pathname.codePointAt(n5 + 2) || 32;
      if (pathname[n5 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL2(filepath) {
  let resolved = exports3.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH2 || isWindows2 && filePathLast === CHAR_BACKWARD_SLASH2) && resolved[resolved.length - 1] !== exports3.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%"))
    resolved = resolved.replace(percentRegEx2, "%25");
  if (!isWindows2 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx2, "%5C");
  }
  if (resolved.includes("\n"))
    resolved = resolved.replace(newlineRegEx2, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx2, "%0D");
  }
  if (resolved.includes("	"))
    resolved = resolved.replace(tabRegEx2, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var h4, e5, a3, o4, n4, i3, l3, p3, c3, u3, f3, m3, v3, g3, y3, b3, exports9, _dewExec8, path2, processPlatform$12, CHAR_BACKWARD_SLASH$12, CHAR_FORWARD_SLASH$12, CHAR_LOWERCASE_A$12, CHAR_LOWERCASE_Z$12, isWindows$12, forwardSlashRegEx$12, percentRegEx$12, backslashRegEx$12, newlineRegEx$12, carriageReturnRegEx$12, tabRegEx$12, processPlatform2, Url2, format3, resolve2, resolveObject2, parse2, _URL2, CHAR_BACKWARD_SLASH2, CHAR_FORWARD_SLASH2, CHAR_LOWERCASE_A2, CHAR_LOWERCASE_Z2, isWindows2, forwardSlashRegEx2, percentRegEx2, backslashRegEx2, newlineRegEx2, carriageReturnRegEx2, tabRegEx2;
var init_url2 = __esm({
  "node-modules-polyfills:url"() {
    init_chunk_924bb2e1();
    init_chunk_b04e620d();
    init_chunk_5decc758();
    init_chunk_23dbec7b();
    init_chunk_2eac56ff();
    h4 = {};
    e5 = p;
    a3 = { isString: function(t4) {
      return "string" == typeof t4;
    }, isObject: function(t4) {
      return "object" == typeof t4 && null !== t4;
    }, isNull: function(t4) {
      return null === t4;
    }, isNullOrUndefined: function(t4) {
      return null == t4;
    } };
    h4.parse = O3, h4.resolve = function(t4, s2) {
      return O3(t4, false, true).resolve(s2);
    }, h4.resolveObject = function(t4, s2) {
      return t4 ? O3(t4, false, true).resolveObject(s2) : s2;
    }, h4.format = function(t4) {
      a3.isString(t4) && (t4 = O3(t4));
      return t4 instanceof r5 ? t4.format() : r5.prototype.format.call(t4);
    }, h4.Url = r5;
    o4 = /^([a-z0-9.+-]+:)/i;
    n4 = /:[0-9]*$/;
    i3 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    l3 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
    p3 = ["'"].concat(l3);
    c3 = ["%", "/", "?", ";", "#"].concat(p3);
    u3 = ["/", "?", "#"];
    f3 = /^[+a-z0-9A-Z_-]{0,63}$/;
    m3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    v3 = { javascript: true, "javascript:": true };
    g3 = { javascript: true, "javascript:": true };
    y3 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
    b3 = o2;
    r5.prototype.parse = function(t4, s2, h5) {
      if (!a3.isString(t4))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t4);
      var r6 = t4.indexOf("?"), n5 = -1 !== r6 && r6 < t4.indexOf("#") ? "?" : "#", l4 = t4.split(n5);
      l4[0] = l4[0].replace(/\\/g, "/");
      var O4 = t4 = l4.join(n5);
      if (O4 = O4.trim(), !h5 && 1 === t4.split("#").length) {
        var d3 = i3.exec(O4);
        if (d3)
          return this.path = O4, this.href = O4, this.pathname = d3[1], d3[2] ? (this.search = d3[2], this.query = s2 ? b3.parse(this.search.substr(1)) : this.search.substr(1)) : s2 && (this.search = "", this.query = {}), this;
      }
      var j2 = o4.exec(O4);
      if (j2) {
        var q2 = (j2 = j2[0]).toLowerCase();
        this.protocol = q2, O4 = O4.substr(j2.length);
      }
      if (h5 || j2 || O4.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var x2 = "//" === O4.substr(0, 2);
        !x2 || j2 && g3[j2] || (O4 = O4.substr(2), this.slashes = true);
      }
      if (!g3[j2] && (x2 || j2 && !y3[j2])) {
        for (var A2, C2, I2 = -1, w2 = 0; w2 < u3.length; w2++) {
          -1 !== (N2 = O4.indexOf(u3[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
        }
        -1 !== (C2 = -1 === I2 ? O4.lastIndexOf("@") : O4.lastIndexOf("@", I2)) && (A2 = O4.slice(0, C2), O4 = O4.slice(C2 + 1), this.auth = decodeURIComponent(A2)), I2 = -1;
        for (w2 = 0; w2 < c3.length; w2++) {
          var N2;
          -1 !== (N2 = O4.indexOf(c3[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
        }
        -1 === I2 && (I2 = O4.length), this.host = O4.slice(0, I2), O4 = O4.slice(I2), this.parseHost(), this.hostname = this.hostname || "";
        var U2 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!U2)
          for (var k2 = this.hostname.split(/\./), S2 = (w2 = 0, k2.length); w2 < S2; w2++) {
            var R2 = k2[w2];
            if (R2 && !R2.match(f3)) {
              for (var $2 = "", z2 = 0, H2 = R2.length; z2 < H2; z2++)
                R2.charCodeAt(z2) > 127 ? $2 += "x" : $2 += R2[z2];
              if (!$2.match(f3)) {
                var L2 = k2.slice(0, w2), Z2 = k2.slice(w2 + 1), _2 = R2.match(m3);
                _2 && (L2.push(_2[1]), Z2.unshift(_2[2])), Z2.length && (O4 = "/" + Z2.join(".") + O4), this.hostname = L2.join(".");
                break;
              }
            }
          }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U2 || (this.hostname = e5.toASCII(this.hostname));
        var E2 = this.port ? ":" + this.port : "", P2 = this.hostname || "";
        this.host = P2 + E2, this.href += this.host, U2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O4[0] && (O4 = "/" + O4));
      }
      if (!v3[q2])
        for (w2 = 0, S2 = p3.length; w2 < S2; w2++) {
          var T3 = p3[w2];
          if (-1 !== O4.indexOf(T3)) {
            var B2 = encodeURIComponent(T3);
            B2 === T3 && (B2 = escape(T3)), O4 = O4.split(T3).join(B2);
          }
        }
      var D2 = O4.indexOf("#");
      -1 !== D2 && (this.hash = O4.substr(D2), O4 = O4.slice(0, D2));
      var F2 = O4.indexOf("?");
      if (-1 !== F2 ? (this.search = O4.substr(F2), this.query = O4.substr(F2 + 1), s2 && (this.query = b3.parse(this.query)), O4 = O4.slice(0, F2)) : s2 && (this.search = "", this.query = {}), O4 && (this.pathname = O4), y3[q2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        E2 = this.pathname || "";
        var G2 = this.search || "";
        this.path = E2 + G2;
      }
      return this.href = this.format(), this;
    }, r5.prototype.format = function() {
      var t4 = this.auth || "";
      t4 && (t4 = (t4 = encodeURIComponent(t4)).replace(/%3A/i, ":"), t4 += "@");
      var s2 = this.protocol || "", h5 = this.pathname || "", e6 = this.hash || "", r6 = false, o5 = "";
      this.host ? r6 = t4 + this.host : this.hostname && (r6 = t4 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r6 += ":" + this.port)), this.query && a3.isObject(this.query) && Object.keys(this.query).length && (o5 = b3.stringify(this.query));
      var n5 = this.search || o5 && "?" + o5 || "";
      return s2 && ":" !== s2.substr(-1) && (s2 += ":"), this.slashes || (!s2 || y3[s2]) && false !== r6 ? (r6 = "//" + (r6 || ""), h5 && "/" !== h5.charAt(0) && (h5 = "/" + h5)) : r6 || (r6 = ""), e6 && "#" !== e6.charAt(0) && (e6 = "#" + e6), n5 && "?" !== n5.charAt(0) && (n5 = "?" + n5), s2 + r6 + (h5 = h5.replace(/[?#]/g, function(t5) {
        return encodeURIComponent(t5);
      })) + (n5 = n5.replace("#", "%23")) + e6;
    }, r5.prototype.resolve = function(t4) {
      return this.resolveObject(O3(t4, false, true)).format();
    }, r5.prototype.resolveObject = function(t4) {
      if (a3.isString(t4)) {
        var s2 = new r5();
        s2.parse(t4, false, true), t4 = s2;
      }
      for (var h5 = new r5(), e6 = Object.keys(this), o5 = 0; o5 < e6.length; o5++) {
        var n5 = e6[o5];
        h5[n5] = this[n5];
      }
      if (h5.hash = t4.hash, "" === t4.href)
        return h5.href = h5.format(), h5;
      if (t4.slashes && !t4.protocol) {
        for (var i4 = Object.keys(t4), l4 = 0; l4 < i4.length; l4++) {
          var p4 = i4[l4];
          "protocol" !== p4 && (h5[p4] = t4[p4]);
        }
        return y3[h5.protocol] && h5.hostname && !h5.pathname && (h5.path = h5.pathname = "/"), h5.href = h5.format(), h5;
      }
      if (t4.protocol && t4.protocol !== h5.protocol) {
        if (!y3[t4.protocol]) {
          for (var c4 = Object.keys(t4), u4 = 0; u4 < c4.length; u4++) {
            var f4 = c4[u4];
            h5[f4] = t4[f4];
          }
          return h5.href = h5.format(), h5;
        }
        if (h5.protocol = t4.protocol, t4.host || g3[t4.protocol])
          h5.pathname = t4.pathname;
        else {
          for (var m4 = (t4.pathname || "").split("/"); m4.length && !(t4.host = m4.shift()); )
            ;
          t4.host || (t4.host = ""), t4.hostname || (t4.hostname = ""), "" !== m4[0] && m4.unshift(""), m4.length < 2 && m4.unshift(""), h5.pathname = m4.join("/");
        }
        if (h5.search = t4.search, h5.query = t4.query, h5.host = t4.host || "", h5.auth = t4.auth, h5.hostname = t4.hostname || t4.host, h5.port = t4.port, h5.pathname || h5.search) {
          var v4 = h5.pathname || "", b4 = h5.search || "";
          h5.path = v4 + b4;
        }
        return h5.slashes = h5.slashes || t4.slashes, h5.href = h5.format(), h5;
      }
      var O4 = h5.pathname && "/" === h5.pathname.charAt(0), d3 = t4.host || t4.pathname && "/" === t4.pathname.charAt(0), j2 = d3 || O4 || h5.host && t4.pathname, q2 = j2, x2 = h5.pathname && h5.pathname.split("/") || [], A2 = (m4 = t4.pathname && t4.pathname.split("/") || [], h5.protocol && !y3[h5.protocol]);
      if (A2 && (h5.hostname = "", h5.port = null, h5.host && ("" === x2[0] ? x2[0] = h5.host : x2.unshift(h5.host)), h5.host = "", t4.protocol && (t4.hostname = null, t4.port = null, t4.host && ("" === m4[0] ? m4[0] = t4.host : m4.unshift(t4.host)), t4.host = null), j2 = j2 && ("" === m4[0] || "" === x2[0])), d3)
        h5.host = t4.host || "" === t4.host ? t4.host : h5.host, h5.hostname = t4.hostname || "" === t4.hostname ? t4.hostname : h5.hostname, h5.search = t4.search, h5.query = t4.query, x2 = m4;
      else if (m4.length)
        x2 || (x2 = []), x2.pop(), x2 = x2.concat(m4), h5.search = t4.search, h5.query = t4.query;
      else if (!a3.isNullOrUndefined(t4.search)) {
        if (A2)
          h5.hostname = h5.host = x2.shift(), (U2 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U2.shift(), h5.host = h5.hostname = U2.shift());
        return h5.search = t4.search, h5.query = t4.query, a3.isNull(h5.pathname) && a3.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.href = h5.format(), h5;
      }
      if (!x2.length)
        return h5.pathname = null, h5.search ? h5.path = "/" + h5.search : h5.path = null, h5.href = h5.format(), h5;
      for (var C2 = x2.slice(-1)[0], I2 = (h5.host || t4.host || x2.length > 1) && ("." === C2 || ".." === C2) || "" === C2, w2 = 0, N2 = x2.length; N2 >= 0; N2--)
        "." === (C2 = x2[N2]) ? x2.splice(N2, 1) : ".." === C2 ? (x2.splice(N2, 1), w2++) : w2 && (x2.splice(N2, 1), w2--);
      if (!j2 && !q2)
        for (; w2--; w2)
          x2.unshift("..");
      !j2 || "" === x2[0] || x2[0] && "/" === x2[0].charAt(0) || x2.unshift(""), I2 && "/" !== x2.join("/").substr(-1) && x2.push("");
      var U2, k2 = "" === x2[0] || x2[0] && "/" === x2[0].charAt(0);
      A2 && (h5.hostname = h5.host = k2 ? "" : x2.length ? x2.shift() : "", (U2 = !!(h5.host && h5.host.indexOf("@") > 0) && h5.host.split("@")) && (h5.auth = U2.shift(), h5.host = h5.hostname = U2.shift()));
      return (j2 = j2 || h5.host && x2.length) && !k2 && x2.unshift(""), x2.length ? h5.pathname = x2.join("/") : (h5.pathname = null, h5.path = null), a3.isNull(h5.pathname) && a3.isNull(h5.search) || (h5.path = (h5.pathname ? h5.pathname : "") + (h5.search ? h5.search : "")), h5.auth = t4.auth || h5.auth, h5.slashes = h5.slashes || t4.slashes, h5.href = h5.format(), h5;
    }, r5.prototype.parseHost = function() {
      var t4 = this.host, s2 = n4.exec(t4);
      s2 && (":" !== (s2 = s2[0]) && (this.port = s2.substr(1)), t4 = t4.substr(0, t4.length - s2.length)), t4 && (this.hostname = t4);
    };
    h4.Url;
    h4.format;
    h4.resolve;
    h4.resolveObject;
    exports9 = {};
    _dewExec8 = false;
    path2 = dew9();
    processPlatform$12 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h4.URL = typeof URL !== "undefined" ? URL : null;
    h4.pathToFileURL = pathToFileURL$12;
    h4.fileURLToPath = fileURLToPath$12;
    h4.Url;
    h4.format;
    h4.resolve;
    h4.resolveObject;
    h4.URL;
    CHAR_BACKWARD_SLASH$12 = 92;
    CHAR_FORWARD_SLASH$12 = 47;
    CHAR_LOWERCASE_A$12 = 97;
    CHAR_LOWERCASE_Z$12 = 122;
    isWindows$12 = processPlatform$12 === "win32";
    forwardSlashRegEx$12 = /\//g;
    percentRegEx$12 = /%/g;
    backslashRegEx$12 = /\\/g;
    newlineRegEx$12 = /\n/g;
    carriageReturnRegEx$12 = /\r/g;
    tabRegEx$12 = /\t/g;
    processPlatform2 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
    h4.URL = typeof URL !== "undefined" ? URL : null;
    h4.pathToFileURL = pathToFileURL2;
    h4.fileURLToPath = fileURLToPath2;
    Url2 = h4.Url;
    format3 = h4.format;
    resolve2 = h4.resolve;
    resolveObject2 = h4.resolveObject;
    parse2 = h4.parse;
    _URL2 = h4.URL;
    CHAR_BACKWARD_SLASH2 = 92;
    CHAR_FORWARD_SLASH2 = 47;
    CHAR_LOWERCASE_A2 = 97;
    CHAR_LOWERCASE_Z2 = 122;
    isWindows2 = processPlatform2 === "win32";
    forwardSlashRegEx2 = /\//g;
    percentRegEx2 = /%/g;
    backslashRegEx2 = /\\/g;
    newlineRegEx2 = /\n/g;
    carriageReturnRegEx2 = /\r/g;
    tabRegEx2 = /\t/g;
  }
});

// node-modules-polyfills-commonjs:url
var url_exports = {};
__export(url_exports, {
  URL: () => _URL2,
  Url: () => Url2,
  fileURLToPath: () => fileURLToPath2,
  format: () => format3,
  parse: () => parse2,
  pathToFileURL: () => pathToFileURL2,
  resolve: () => resolve2,
  resolveObject: () => resolveObject2
});
var init_url3 = __esm({
  "node-modules-polyfills-commonjs:url"() {
    init_url2();
  }
});

// node_modules/.pnpm/micro-ftch@0.3.1/node_modules/micro-ftch/index.js
var require_micro_ftch = __commonJS({
  "node_modules/.pnpm/micro-ftch@0.3.1/node_modules/micro-ftch/index.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.InvalidStatusCodeError = exports10.InvalidCertError = void 0;
    var DEFAULT_OPT = Object.freeze({
      redirect: true,
      expectStatusCode: 200,
      headers: {},
      full: false,
      keepAlive: true,
      cors: false,
      referrer: false,
      sslAllowSelfSigned: false,
      _redirectCount: 0
    });
    var InvalidCertError = class extends Error {
      constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
      }
    };
    exports10.InvalidCertError = InvalidCertError;
    var InvalidStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    exports10.InvalidStatusCodeError = InvalidStatusCodeError;
    function detectType(b4, type2) {
      if (!type2 || type2 === "text" || type2 === "json") {
        try {
          let text = new TextDecoder("utf8", { fatal: true }).decode(b4);
          if (type2 === "text")
            return text;
          try {
            return JSON.parse(text);
          } catch (err) {
            if (type2 === "json")
              throw err;
            return text;
          }
        } catch (err) {
          if (type2 === "text" || type2 === "json")
            throw err;
        }
      }
      return b4;
    }
    var agents = {};
    function fetchNode(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const http = (init_http2(), __toCommonJS(http_exports));
      const https = (init_https2(), __toCommonJS(https_exports));
      const zlib = (init_zlib2(), __toCommonJS(zlib_exports));
      const { promisify: promisify3 } = (init_util3(), __toCommonJS(util_exports));
      const { resolve: urlResolve } = (init_url3(), __toCommonJS(url_exports));
      const isSecure = !!/^https/.test(url);
      let opts = {
        method: options.method || "GET",
        headers: { "Accept-Encoding": "gzip, deflate, br" }
      };
      const compactFP = (s2) => s2.replace(/:| /g, "").toLowerCase();
      if (options.keepAlive) {
        const agentOpt = {
          keepAlive: true,
          keepAliveMsecs: 30 * 1e3,
          maxFreeSockets: 1024,
          maxCachedSessions: 1024
        };
        const agentKey = [
          isSecure,
          isSecure && options.sslPinnedCertificates?.map((i4) => compactFP(i4)).sort()
        ].join();
        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
      }
      if (options.type === "json")
        opts.headers["Content-Type"] = "application/json";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      opts.headers = { ...opts.headers, ...options.headers };
      if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
      const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers["location"]) {
          if (options._redirectCount == 10)
            throw new Error("Request failed. Too much redirects.");
          options._redirectCount += 1;
          return await fetchNode(urlResolve(url, res.headers["location"]), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
          res.resume();
          throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
          buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers["content-encoding"];
        if (encoding === "br")
          bytes = await promisify3(zlib.brotliDecompress)(bytes);
        if (encoding === "gzip" || encoding === "deflate")
          bytes = await promisify3(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
          return { headers: res.headers, status, body };
        return body;
      };
      return new Promise((resolve3, reject) => {
        const handleError = async (err) => {
          if (err && err.code === "DEPTH_ZERO_SELF_SIGNED_CERT") {
            try {
              await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
            } catch (e6) {
              if (e6 && e6.fingerprint256) {
                err = new InvalidCertError(`Self-signed SSL certificate: ${e6.fingerprint256}`, e6.fingerprint256);
              }
            }
          }
          reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
          res.on("error", handleError);
          (async () => {
            try {
              resolve3(await handleRes(res));
            } catch (error) {
              reject(error);
            }
          })();
        });
        req.on("error", handleError);
        const pinned = options.sslPinnedCertificates?.map((i4) => compactFP(i4));
        const mfetchSecureConnect = (socket) => {
          const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || "");
          if (!fp256 && socket.isSessionReused())
            return;
          if (pinned.includes(fp256))
            return;
          req.emit("error", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
          return req.abort();
        };
        if (options.sslPinnedCertificates) {
          req.on("socket", (socket) => {
            const hasListeners = socket.listeners("secureConnect").map((i4) => (i4.name || "").replace("bound ", "")).includes("mfetchSecureConnect");
            if (hasListeners)
              return;
            socket.on("secureConnect", mfetchSecureConnect.bind(null, socket));
          });
        }
        if (options.keepAlive)
          req.setNoDelay(true);
        if (opts.body)
          req.write(opts.body);
        req.end();
      });
    }
    var SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((i4) => i4.toLowerCase()));
    var FORBIDDEN_HEADERS = new Set([
      "Accept-Charset",
      "Accept-Encoding",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Connection",
      "Content-Length",
      "Cookie",
      "Cookie2",
      "Date",
      "DNT",
      "Expect",
      "Host",
      "Keep-Alive",
      "Origin",
      "Referer",
      "TE",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Via"
    ].map((i4) => i4.toLowerCase()));
    async function fetchBrowser(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const headers = new Headers();
      if (options.type === "json")
        headers.set("Content-Type", "application/json");
      let parsed = new URL(url);
      if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set("Authorization", `Basic ${auth}`);
        parsed.username = "";
        parsed.password = "";
      }
      url = "" + parsed;
      for (let k2 in options.headers) {
        const name = k2.toLowerCase();
        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name))
          headers.set(k2, options.headers[k2]);
      }
      let opts = { headers, redirect: options.redirect ? "follow" : "manual" };
      if (!options.referrer)
        opts.referrerPolicy = "no-referrer";
      if (options.cors)
        opts.mode = "cors";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      const res = await fetch(url, opts);
      if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
      const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
      if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
      return body;
    }
    var IS_NODE = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    function fetchUrl(url, options) {
      const fn = IS_NODE ? fetchNode : fetchBrowser;
      return fn(url, options);
    }
    exports10.default = fetchUrl;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/provider.js
var require_provider = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/provider.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.getProvider = exports10.fetchFromProvider = void 0;
    var micro_ftch_1 = require_micro_ftch();
    var fetchFromProvider = async (url, params) => {
      const res = await (0, micro_ftch_1.default)(url, {
        headers: {
          "content-type": "application/json"
        },
        type: "json",
        data: {
          method: params.method,
          params: params.params,
          jsonrpc: "2.0",
          id: 1
        }
      });
      return res.result;
    };
    exports10.fetchFromProvider = fetchFromProvider;
    var getProvider = (provider) => {
      if (typeof provider === "string") {
        return provider;
      } else if (provider?.connection?.url !== void 0) {
        return provider.connection.url;
      } else {
        throw new Error("Must provide valid provider URL or Web3Provider");
      }
    };
    exports10.getProvider = getProvider;
  }
});

// node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/.pnpm/@ethereumjs+util@8.1.0/node_modules/@ethereumjs/util/dist/index.js"(exports10) {
    "use strict";
    var __createBinding = exports10 && exports10.__createBinding || (Object.create ? function(o5, m4, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m4, k2);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k2];
        } };
      }
      Object.defineProperty(o5, k22, desc);
    } : function(o5, m4, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o5[k22] = m4[k2];
    });
    var __exportStar = exports10 && exports10.__exportStar || function(m4, exports11) {
      for (var p4 in m4)
        if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports11, p4))
          __createBinding(exports11, m4, p4);
    };
    Object.defineProperty(exports10, "__esModule", { value: true });
    exports10.toAscii = exports10.stripHexPrefix = exports10.padToEven = exports10.isHexString = exports10.isHexPrefixed = exports10.getKeys = exports10.getBinarySize = exports10.fromUtf8 = exports10.fromAscii = exports10.arrayContainsArray = void 0;
    __exportStar(require_constants(), exports10);
    __exportStar(require_units(), exports10);
    __exportStar(require_account(), exports10);
    __exportStar(require_address(), exports10);
    __exportStar(require_withdrawal(), exports10);
    __exportStar(require_signature(), exports10);
    __exportStar(require_bytes2(), exports10);
    __exportStar(require_types(), exports10);
    __exportStar(require_encoding(), exports10);
    __exportStar(require_asyncEventEmitter(), exports10);
    var internal_1 = require_internal();
    Object.defineProperty(exports10, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports10, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports10, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports10, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports10, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports10, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports10, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
    Object.defineProperty(exports10, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports10, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports10, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    __exportStar(require_lock(), exports10);
    __exportStar(require_provider(), exports10);
  }
});

// node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js"(exports10, module) {
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module === "object" && module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports10, function() {
      "use strict";
      var noop2 = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e6) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop2;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i4 = 0; i4 < logMethods.length; i4++) {
          var methodName = logMethods[i4];
          this[methodName] = i4 < level ? noop2 : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location2 = cookie.indexOf(cookieName + "=");
              if (location2 !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location2 + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/.pnpm/bowser@2.11.0/node_modules/bowser/es5.js
var require_es5 = __commonJS({
  "node_modules/.pnpm/bowser@2.11.0/node_modules/bowser/es5.js"(exports10, module) {
    !function(e6, t4) {
      "object" == typeof exports10 && "object" == typeof module ? module.exports = t4() : "function" == typeof define && define.amd ? define([], t4) : "object" == typeof exports10 ? exports10.bowser = t4() : e6.bowser = t4();
    }(exports10, function() {
      return function(e6) {
        var t4 = {};
        function r6(n5) {
          if (t4[n5])
            return t4[n5].exports;
          var i4 = t4[n5] = { i: n5, l: false, exports: {} };
          return e6[n5].call(i4.exports, i4, i4.exports, r6), i4.l = true, i4.exports;
        }
        return r6.m = e6, r6.c = t4, r6.d = function(e7, t5, n5) {
          r6.o(e7, t5) || Object.defineProperty(e7, t5, { enumerable: true, get: n5 });
        }, r6.r = function(e7) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e7, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e7, "__esModule", { value: true });
        }, r6.t = function(e7, t5) {
          if (1 & t5 && (e7 = r6(e7)), 8 & t5)
            return e7;
          if (4 & t5 && "object" == typeof e7 && e7 && e7.__esModule)
            return e7;
          var n5 = /* @__PURE__ */ Object.create(null);
          if (r6.r(n5), Object.defineProperty(n5, "default", { enumerable: true, value: e7 }), 2 & t5 && "string" != typeof e7)
            for (var i4 in e7)
              r6.d(n5, i4, function(t6) {
                return e7[t6];
              }.bind(null, i4));
          return n5;
        }, r6.n = function(e7) {
          var t5 = e7 && e7.__esModule ? function() {
            return e7.default;
          } : function() {
            return e7;
          };
          return r6.d(t5, "a", t5), t5;
        }, r6.o = function(e7, t5) {
          return Object.prototype.hasOwnProperty.call(e7, t5);
        }, r6.p = "", r6(r6.s = 90);
      }({ 17: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5 = r6(18), i4 = function() {
          function e7() {
          }
          return e7.getFirstMatch = function(e8, t5) {
            var r7 = t5.match(e8);
            return r7 && r7.length > 0 && r7[1] || "";
          }, e7.getSecondMatch = function(e8, t5) {
            var r7 = t5.match(e8);
            return r7 && r7.length > 1 && r7[2] || "";
          }, e7.matchAndReturnConst = function(e8, t5, r7) {
            if (e8.test(t5))
              return r7;
          }, e7.getWindowsVersionName = function(e8) {
            switch (e8) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e7.getMacOSVersionName = function(e8) {
            var t5 = e8.split(".").splice(0, 2).map(function(e9) {
              return parseInt(e9, 10) || 0;
            });
            if (t5.push(0), 10 === t5[0])
              switch (t5[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
          }, e7.getAndroidVersionName = function(e8) {
            var t5 = e8.split(".").splice(0, 2).map(function(e9) {
              return parseInt(e9, 10) || 0;
            });
            if (t5.push(0), !(1 === t5[0] && t5[1] < 5))
              return 1 === t5[0] && t5[1] < 6 ? "Cupcake" : 1 === t5[0] && t5[1] >= 6 ? "Donut" : 2 === t5[0] && t5[1] < 2 ? "Eclair" : 2 === t5[0] && 2 === t5[1] ? "Froyo" : 2 === t5[0] && t5[1] > 2 ? "Gingerbread" : 3 === t5[0] ? "Honeycomb" : 4 === t5[0] && t5[1] < 1 ? "Ice Cream Sandwich" : 4 === t5[0] && t5[1] < 4 ? "Jelly Bean" : 4 === t5[0] && t5[1] >= 4 ? "KitKat" : 5 === t5[0] ? "Lollipop" : 6 === t5[0] ? "Marshmallow" : 7 === t5[0] ? "Nougat" : 8 === t5[0] ? "Oreo" : 9 === t5[0] ? "Pie" : void 0;
          }, e7.getVersionPrecision = function(e8) {
            return e8.split(".").length;
          }, e7.compareVersions = function(t5, r7, n6) {
            void 0 === n6 && (n6 = false);
            var i5 = e7.getVersionPrecision(t5), s2 = e7.getVersionPrecision(r7), a4 = Math.max(i5, s2), o5 = 0, u4 = e7.map([t5, r7], function(t6) {
              var r8 = a4 - e7.getVersionPrecision(t6), n7 = t6 + new Array(r8 + 1).join(".0");
              return e7.map(n7.split("."), function(e8) {
                return new Array(20 - e8.length).join("0") + e8;
              }).reverse();
            });
            for (n6 && (o5 = a4 - Math.min(i5, s2)), a4 -= 1; a4 >= o5; ) {
              if (u4[0][a4] > u4[1][a4])
                return 1;
              if (u4[0][a4] === u4[1][a4]) {
                if (a4 === o5)
                  return 0;
                a4 -= 1;
              } else if (u4[0][a4] < u4[1][a4])
                return -1;
            }
          }, e7.map = function(e8, t5) {
            var r7, n6 = [];
            if (Array.prototype.map)
              return Array.prototype.map.call(e8, t5);
            for (r7 = 0; r7 < e8.length; r7 += 1)
              n6.push(t5(e8[r7]));
            return n6;
          }, e7.find = function(e8, t5) {
            var r7, n6;
            if (Array.prototype.find)
              return Array.prototype.find.call(e8, t5);
            for (r7 = 0, n6 = e8.length; r7 < n6; r7 += 1) {
              var i5 = e8[r7];
              if (t5(i5, r7))
                return i5;
            }
          }, e7.assign = function(e8) {
            for (var t5, r7, n6 = e8, i5 = arguments.length, s2 = new Array(i5 > 1 ? i5 - 1 : 0), a4 = 1; a4 < i5; a4++)
              s2[a4 - 1] = arguments[a4];
            if (Object.assign)
              return Object.assign.apply(Object, [e8].concat(s2));
            var o5 = function() {
              var e9 = s2[t5];
              "object" == typeof e9 && null !== e9 && Object.keys(e9).forEach(function(t6) {
                n6[t6] = e9[t6];
              });
            };
            for (t5 = 0, r7 = s2.length; t5 < r7; t5 += 1)
              o5();
            return e8;
          }, e7.getBrowserAlias = function(e8) {
            return n5.BROWSER_ALIASES_MAP[e8];
          }, e7.getBrowserTypeByAlias = function(e8) {
            return n5.BROWSER_MAP[e8] || "";
          }, e7;
        }();
        t4.default = i4, e6.exports = t4.default;
      }, 18: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.ENGINE_MAP = t4.OS_MAP = t4.PLATFORMS_MAP = t4.BROWSER_MAP = t4.BROWSER_ALIASES_MAP = void 0;
        t4.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
        t4.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
        t4.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
        t4.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
        t4.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
      }, 90: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5, i4 = (n5 = r6(91)) && n5.__esModule ? n5 : { default: n5 }, s2 = r6(18);
        function a4(e7, t5) {
          for (var r7 = 0; r7 < t5.length; r7++) {
            var n6 = t5[r7];
            n6.enumerable = n6.enumerable || false, n6.configurable = true, "value" in n6 && (n6.writable = true), Object.defineProperty(e7, n6.key, n6);
          }
        }
        var o5 = function() {
          function e7() {
          }
          var t5, r7, n6;
          return e7.getParser = function(e8, t6) {
            if (void 0 === t6 && (t6 = false), "string" != typeof e8)
              throw new Error("UserAgent should be a string");
            return new i4.default(e8, t6);
          }, e7.parse = function(e8) {
            return new i4.default(e8).getResult();
          }, t5 = e7, n6 = [{ key: "BROWSER_MAP", get: function() {
            return s2.BROWSER_MAP;
          } }, { key: "ENGINE_MAP", get: function() {
            return s2.ENGINE_MAP;
          } }, { key: "OS_MAP", get: function() {
            return s2.OS_MAP;
          } }, { key: "PLATFORMS_MAP", get: function() {
            return s2.PLATFORMS_MAP;
          } }], (r7 = null) && a4(t5.prototype, r7), n6 && a4(t5, n6), e7;
        }();
        t4.default = o5, e6.exports = t4.default;
      }, 91: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5 = u4(r6(92)), i4 = u4(r6(93)), s2 = u4(r6(94)), a4 = u4(r6(95)), o5 = u4(r6(17));
        function u4(e7) {
          return e7 && e7.__esModule ? e7 : { default: e7 };
        }
        var d3 = function() {
          function e7(e8, t6) {
            if (void 0 === t6 && (t6 = false), null == e8 || "" === e8)
              throw new Error("UserAgent parameter can't be empty");
            this._ua = e8, this.parsedResult = {}, true !== t6 && this.parse();
          }
          var t5 = e7.prototype;
          return t5.getUA = function() {
            return this._ua;
          }, t5.test = function(e8) {
            return e8.test(this._ua);
          }, t5.parseBrowser = function() {
            var e8 = this;
            this.parsedResult.browser = {};
            var t6 = o5.default.find(n5.default, function(t7) {
              if ("function" == typeof t7.test)
                return t7.test(e8);
              if (t7.test instanceof Array)
                return t7.test.some(function(t8) {
                  return e8.test(t8);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t6 && (this.parsedResult.browser = t6.describe(this.getUA())), this.parsedResult.browser;
          }, t5.getBrowser = function() {
            return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
          }, t5.getBrowserName = function(e8) {
            return e8 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
          }, t5.getBrowserVersion = function() {
            return this.getBrowser().version;
          }, t5.getOS = function() {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }, t5.parseOS = function() {
            var e8 = this;
            this.parsedResult.os = {};
            var t6 = o5.default.find(i4.default, function(t7) {
              if ("function" == typeof t7.test)
                return t7.test(e8);
              if (t7.test instanceof Array)
                return t7.test.some(function(t8) {
                  return e8.test(t8);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t6 && (this.parsedResult.os = t6.describe(this.getUA())), this.parsedResult.os;
          }, t5.getOSName = function(e8) {
            var t6 = this.getOS().name;
            return e8 ? String(t6).toLowerCase() || "" : t6 || "";
          }, t5.getOSVersion = function() {
            return this.getOS().version;
          }, t5.getPlatform = function() {
            return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
          }, t5.getPlatformType = function(e8) {
            void 0 === e8 && (e8 = false);
            var t6 = this.getPlatform().type;
            return e8 ? String(t6).toLowerCase() || "" : t6 || "";
          }, t5.parsePlatform = function() {
            var e8 = this;
            this.parsedResult.platform = {};
            var t6 = o5.default.find(s2.default, function(t7) {
              if ("function" == typeof t7.test)
                return t7.test(e8);
              if (t7.test instanceof Array)
                return t7.test.some(function(t8) {
                  return e8.test(t8);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t6 && (this.parsedResult.platform = t6.describe(this.getUA())), this.parsedResult.platform;
          }, t5.getEngine = function() {
            return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
          }, t5.getEngineName = function(e8) {
            return e8 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
          }, t5.parseEngine = function() {
            var e8 = this;
            this.parsedResult.engine = {};
            var t6 = o5.default.find(a4.default, function(t7) {
              if ("function" == typeof t7.test)
                return t7.test(e8);
              if (t7.test instanceof Array)
                return t7.test.some(function(t8) {
                  return e8.test(t8);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t6 && (this.parsedResult.engine = t6.describe(this.getUA())), this.parsedResult.engine;
          }, t5.parse = function() {
            return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
          }, t5.getResult = function() {
            return o5.default.assign({}, this.parsedResult);
          }, t5.satisfies = function(e8) {
            var t6 = this, r7 = {}, n6 = 0, i5 = {}, s3 = 0;
            if (Object.keys(e8).forEach(function(t7) {
              var a6 = e8[t7];
              "string" == typeof a6 ? (i5[t7] = a6, s3 += 1) : "object" == typeof a6 && (r7[t7] = a6, n6 += 1);
            }), n6 > 0) {
              var a5 = Object.keys(r7), u5 = o5.default.find(a5, function(e9) {
                return t6.isOS(e9);
              });
              if (u5) {
                var d4 = this.satisfies(r7[u5]);
                if (void 0 !== d4)
                  return d4;
              }
              var c4 = o5.default.find(a5, function(e9) {
                return t6.isPlatform(e9);
              });
              if (c4) {
                var f4 = this.satisfies(r7[c4]);
                if (void 0 !== f4)
                  return f4;
              }
            }
            if (s3 > 0) {
              var l4 = Object.keys(i5), h5 = o5.default.find(l4, function(e9) {
                return t6.isBrowser(e9, true);
              });
              if (void 0 !== h5)
                return this.compareVersion(i5[h5]);
            }
          }, t5.isBrowser = function(e8, t6) {
            void 0 === t6 && (t6 = false);
            var r7 = this.getBrowserName().toLowerCase(), n6 = e8.toLowerCase(), i5 = o5.default.getBrowserTypeByAlias(n6);
            return t6 && i5 && (n6 = i5.toLowerCase()), n6 === r7;
          }, t5.compareVersion = function(e8) {
            var t6 = [0], r7 = e8, n6 = false, i5 = this.getBrowserVersion();
            if ("string" == typeof i5)
              return ">" === e8[0] || "<" === e8[0] ? (r7 = e8.substr(1), "=" === e8[1] ? (n6 = true, r7 = e8.substr(2)) : t6 = [], ">" === e8[0] ? t6.push(1) : t6.push(-1)) : "=" === e8[0] ? r7 = e8.substr(1) : "~" === e8[0] && (n6 = true, r7 = e8.substr(1)), t6.indexOf(o5.default.compareVersions(i5, r7, n6)) > -1;
          }, t5.isOS = function(e8) {
            return this.getOSName(true) === String(e8).toLowerCase();
          }, t5.isPlatform = function(e8) {
            return this.getPlatformType(true) === String(e8).toLowerCase();
          }, t5.isEngine = function(e8) {
            return this.getEngineName(true) === String(e8).toLowerCase();
          }, t5.is = function(e8, t6) {
            return void 0 === t6 && (t6 = false), this.isBrowser(e8, t6) || this.isOS(e8) || this.isPlatform(e8);
          }, t5.some = function(e8) {
            var t6 = this;
            return void 0 === e8 && (e8 = []), e8.some(function(e9) {
              return t6.is(e9);
            });
          }, e7;
        }();
        t4.default = d3, e6.exports = t4.default;
      }, 92: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5, i4 = (n5 = r6(17)) && n5.__esModule ? n5 : { default: n5 };
        var s2 = /version\/(\d+(\.?_?\d+)+)/i, a4 = [{ test: [/googlebot/i], describe: function(e7) {
          var t5 = { name: "Googlebot" }, r7 = i4.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/opera/i], describe: function(e7) {
          var t5 = { name: "Opera" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/opr\/|opios/i], describe: function(e7) {
          var t5 = { name: "Opera" }, r7 = i4.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/SamsungBrowser/i], describe: function(e7) {
          var t5 = { name: "Samsung Internet for Android" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/Whale/i], describe: function(e7) {
          var t5 = { name: "NAVER Whale Browser" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/MZBrowser/i], describe: function(e7) {
          var t5 = { name: "MZ Browser" }, r7 = i4.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/focus/i], describe: function(e7) {
          var t5 = { name: "Focus" }, r7 = i4.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/swing/i], describe: function(e7) {
          var t5 = { name: "Swing" }, r7 = i4.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/coast/i], describe: function(e7) {
          var t5 = { name: "Opera Coast" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e7) {
          var t5 = { name: "Opera Touch" }, r7 = i4.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/yabrowser/i], describe: function(e7) {
          var t5 = { name: "Yandex Browser" }, r7 = i4.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/ucbrowser/i], describe: function(e7) {
          var t5 = { name: "UC Browser" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/Maxthon|mxios/i], describe: function(e7) {
          var t5 = { name: "Maxthon" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/epiphany/i], describe: function(e7) {
          var t5 = { name: "Epiphany" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/puffin/i], describe: function(e7) {
          var t5 = { name: "Puffin" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/sleipnir/i], describe: function(e7) {
          var t5 = { name: "Sleipnir" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/k-meleon/i], describe: function(e7) {
          var t5 = { name: "K-Meleon" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/micromessenger/i], describe: function(e7) {
          var t5 = { name: "WeChat" }, r7 = i4.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/qqbrowser/i], describe: function(e7) {
          var t5 = { name: /qqbrowserlite/i.test(e7) ? "QQ Browser Lite" : "QQ Browser" }, r7 = i4.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/msie|trident/i], describe: function(e7) {
          var t5 = { name: "Internet Explorer" }, r7 = i4.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/\sedg\//i], describe: function(e7) {
          var t5 = { name: "Microsoft Edge" }, r7 = i4.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/edg([ea]|ios)/i], describe: function(e7) {
          var t5 = { name: "Microsoft Edge" }, r7 = i4.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/vivaldi/i], describe: function(e7) {
          var t5 = { name: "Vivaldi" }, r7 = i4.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/seamonkey/i], describe: function(e7) {
          var t5 = { name: "SeaMonkey" }, r7 = i4.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/sailfish/i], describe: function(e7) {
          var t5 = { name: "Sailfish" }, r7 = i4.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/silk/i], describe: function(e7) {
          var t5 = { name: "Amazon Silk" }, r7 = i4.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/phantom/i], describe: function(e7) {
          var t5 = { name: "PhantomJS" }, r7 = i4.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/slimerjs/i], describe: function(e7) {
          var t5 = { name: "SlimerJS" }, r7 = i4.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e7) {
          var t5 = { name: "BlackBerry" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e7) {
          var t5 = { name: "WebOS Browser" }, r7 = i4.default.getFirstMatch(s2, e7) || i4.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/bada/i], describe: function(e7) {
          var t5 = { name: "Bada" }, r7 = i4.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/tizen/i], describe: function(e7) {
          var t5 = { name: "Tizen" }, r7 = i4.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/qupzilla/i], describe: function(e7) {
          var t5 = { name: "QupZilla" }, r7 = i4.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e7) {
          var t5 = { name: "Firefox" }, r7 = i4.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/electron/i], describe: function(e7) {
          var t5 = { name: "Electron" }, r7 = i4.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/MiuiBrowser/i], describe: function(e7) {
          var t5 = { name: "Miui" }, r7 = i4.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/chromium/i], describe: function(e7) {
          var t5 = { name: "Chromium" }, r7 = i4.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e7) || i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/chrome|crios|crmo/i], describe: function(e7) {
          var t5 = { name: "Chrome" }, r7 = i4.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/GSA/i], describe: function(e7) {
          var t5 = { name: "Google Search" }, r7 = i4.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: function(e7) {
          var t5 = !e7.test(/like android/i), r7 = e7.test(/android/i);
          return t5 && r7;
        }, describe: function(e7) {
          var t5 = { name: "Android Browser" }, r7 = i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/playstation 4/i], describe: function(e7) {
          var t5 = { name: "PlayStation 4" }, r7 = i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/safari|applewebkit/i], describe: function(e7) {
          var t5 = { name: "Safari" }, r7 = i4.default.getFirstMatch(s2, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/.*/i], describe: function(e7) {
          var t5 = -1 !== e7.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
          return { name: i4.default.getFirstMatch(t5, e7), version: i4.default.getSecondMatch(t5, e7) };
        } }];
        t4.default = a4, e6.exports = t4.default;
      }, 93: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5, i4 = (n5 = r6(17)) && n5.__esModule ? n5 : { default: n5 }, s2 = r6(18);
        var a4 = [{ test: [/Roku\/DVP/], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e7);
          return { name: s2.OS_MAP.Roku, version: t5 };
        } }, { test: [/windows phone/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e7);
          return { name: s2.OS_MAP.WindowsPhone, version: t5 };
        } }, { test: [/windows /i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e7), r7 = i4.default.getWindowsVersionName(t5);
          return { name: s2.OS_MAP.Windows, version: t5, versionName: r7 };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e7) {
          var t5 = { name: s2.OS_MAP.iOS }, r7 = i4.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/macintosh/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e7).replace(/[_\s]/g, "."), r7 = i4.default.getMacOSVersionName(t5), n6 = { name: s2.OS_MAP.MacOS, version: t5 };
          return r7 && (n6.versionName = r7), n6;
        } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e7).replace(/[_\s]/g, ".");
          return { name: s2.OS_MAP.iOS, version: t5 };
        } }, { test: function(e7) {
          var t5 = !e7.test(/like android/i), r7 = e7.test(/android/i);
          return t5 && r7;
        }, describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e7), r7 = i4.default.getAndroidVersionName(t5), n6 = { name: s2.OS_MAP.Android, version: t5 };
          return r7 && (n6.versionName = r7), n6;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e7), r7 = { name: s2.OS_MAP.WebOS };
          return t5 && t5.length && (r7.version = t5), r7;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e7) || i4.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e7) || i4.default.getFirstMatch(/\bbb(\d+)/i, e7);
          return { name: s2.OS_MAP.BlackBerry, version: t5 };
        } }, { test: [/bada/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e7);
          return { name: s2.OS_MAP.Bada, version: t5 };
        } }, { test: [/tizen/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e7);
          return { name: s2.OS_MAP.Tizen, version: t5 };
        } }, { test: [/linux/i], describe: function() {
          return { name: s2.OS_MAP.Linux };
        } }, { test: [/CrOS/], describe: function() {
          return { name: s2.OS_MAP.ChromeOS };
        } }, { test: [/PlayStation 4/], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e7);
          return { name: s2.OS_MAP.PlayStation4, version: t5 };
        } }];
        t4.default = a4, e6.exports = t4.default;
      }, 94: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5, i4 = (n5 = r6(17)) && n5.__esModule ? n5 : { default: n5 }, s2 = r6(18);
        var a4 = [{ test: [/googlebot/i], describe: function() {
          return { type: "bot", vendor: "Google" };
        } }, { test: [/huawei/i], describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/(can-l01)/i, e7) && "Nova", r7 = { type: s2.PLATFORMS_MAP.mobile, vendor: "Huawei" };
          return t5 && (r7.model = t5), r7;
        } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Nexus" };
        } }, { test: [/ipad/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/kftt build/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
        } }, { test: [/silk/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon" };
        } }, { test: [/tablet(?! pc)/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e7) {
          var t5 = e7.test(/ipod|iphone/i), r7 = e7.test(/like (ipod|iphone)/i);
          return t5 && !r7;
        }, describe: function(e7) {
          var t5 = i4.default.getFirstMatch(/(ipod|iphone)/i, e7);
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Apple", model: t5 };
        } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Nexus" };
        } }, { test: [/[^-]mobi/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e7) {
          return "blackberry" === e7.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
        } }, { test: function(e7) {
          return "bada" === e7.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e7) {
          return "windows phone" === e7.getBrowserName();
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
        } }, { test: function(e7) {
          var t5 = Number(String(e7.getOSVersion()).split(".")[0]);
          return "android" === e7.getOSName(true) && t5 >= 3;
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e7) {
          return "android" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e7) {
          return "macos" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop, vendor: "Apple" };
        } }, { test: function(e7) {
          return "windows" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e7) {
          return "linux" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e7) {
          return "playstation 4" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }, { test: function(e7) {
          return "roku" === e7.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }];
        t4.default = a4, e6.exports = t4.default;
      }, 95: function(e6, t4, r6) {
        "use strict";
        t4.__esModule = true, t4.default = void 0;
        var n5, i4 = (n5 = r6(17)) && n5.__esModule ? n5 : { default: n5 }, s2 = r6(18);
        var a4 = [{ test: function(e7) {
          return "microsoft edge" === e7.getBrowserName(true);
        }, describe: function(e7) {
          if (/\sedg\//i.test(e7))
            return { name: s2.ENGINE_MAP.Blink };
          var t5 = i4.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e7);
          return { name: s2.ENGINE_MAP.EdgeHTML, version: t5 };
        } }, { test: [/trident/i], describe: function(e7) {
          var t5 = { name: s2.ENGINE_MAP.Trident }, r7 = i4.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: function(e7) {
          return e7.test(/presto/i);
        }, describe: function(e7) {
          var t5 = { name: s2.ENGINE_MAP.Presto }, r7 = i4.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: function(e7) {
          var t5 = e7.test(/gecko/i), r7 = e7.test(/like gecko/i);
          return t5 && !r7;
        }, describe: function(e7) {
          var t5 = { name: s2.ENGINE_MAP.Gecko }, r7 = i4.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
          return { name: s2.ENGINE_MAP.Blink };
        } }, { test: [/(apple)?webkit/i], describe: function(e7) {
          var t5 = { name: s2.ENGINE_MAP.WebKit }, r7 = i4.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e7);
          return r7 && (t5.version = r7), t5;
        } }];
        t4.default = a4, e6.exports = t4.default;
      } });
    });
  }
});

// node_modules/.pnpm/lodash.merge@4.6.2/node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.merge@4.6.2/node_modules/lodash.merge/index.js"(exports10, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports10 == "object" && exports10 && !exports10.nodeType && exports10;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e6) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func2, thisArg, args) {
      switch (args.length) {
        case 0:
          return func2.call(thisArg);
        case 1:
          return func2.call(thisArg, args[0]);
        case 2:
          return func2.call(thisArg, args[0], args[1]);
        case 3:
          return func2.call(thisArg, args[0], args[1], args[2]);
      }
      return func2.apply(thisArg, args);
    }
    function baseTimes(n5, iteratee) {
      var index = -1, result = Array(n5);
      while (++index < n5) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func2 = getNative(Object, "defineProperty");
        func2({}, "", {});
        return func2;
      } catch (e6) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object2) {
      if (!isObject3(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject3(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject3(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    function baseRest(func2, start) {
      return setToString(overRest(func2, start, identity), func2 + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func2, string2) {
      return defineProperty(func2, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array2) {
      var index = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index < length) {
        array2[index] = source[index];
      }
      return array2;
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object2 = Object(object2);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object2, source, index, customizer);
          }
        }
        return object2;
      });
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e6) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object2) {
      if (!isObject3(object2)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
        return eq(object2[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func2, start, transform) {
      start = nativeMax(start === void 0 ? func2.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array2);
        return apply(func2, this, otherArgs);
      };
    }
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func2) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func2.apply(void 0, arguments);
      };
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e6) {
        }
        try {
          return func2 + "";
        } catch (e6) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject3(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var merge2 = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var require_lodash2 = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js"(exports10, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports10 == "object" && exports10 && !exports10.nodeType && exports10;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e6) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func2, thisArg, args) {
        switch (args.length) {
          case 0:
            return func2.call(thisArg);
          case 1:
            return func2.call(thisArg, args[0]);
          case 2:
            return func2.call(thisArg, args[0], args[1]);
          case 3:
            return func2.call(thisArg, args[0], args[1], args[2]);
        }
        return func2.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current = iteratee(array2[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n5, iteratee) {
        var index = -1, result = Array(n5);
        while (++index < n5) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func2) {
        return function(value) {
          return func2(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key) {
        return object2 == null ? undefined2 : object2[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func2, transform) {
        return function(arg) {
          return func2(transform(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func2 = getNative(Object2, "defineProperty");
            func2({}, "", {});
            return func2;
          } catch (e6) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject3(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size3 = data.size;
          data.set(key, value);
          this.size += data.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array2, n5) {
          return shuffleSelf(copyArray(array2), baseClamp(n5, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined2 && !eq(object2[key], value) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get5(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject3(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value = object2[key];
            if (value === undefined2 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func2, wait, args) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func2.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value = array2[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object2[key]);
          });
        }
        function baseGet(object2, path3) {
          path3 = castPath(path3, object2);
          var index = 0, length = path3.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey(path3[index++])];
          }
          return index && index == length ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray2(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number2, start, end) {
          return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key, object3) {
            setter(accumulator, iteratee2(value), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path3, args) {
          path3 = castPath(path3, object2);
          object2 = parent(object2, path3);
          var func2 = object2 == null ? object2 : object2[toKey(last(path3))];
          return func2 == null ? undefined2 : apply(func2, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object2)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject3(value) || isMasked(value)) {
            return false;
          }
          var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern2.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject3(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path3, srcValue) {
          if (isKey(path3) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path3), srcValue);
          }
          return function(object2) {
            var objValue = get5(object2, path3);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path3) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject3(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject3(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n5) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n5 += n5 < 0 ? length : 0;
          return isIndex(n5, length) ? array2[n5] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path3) {
            return hasIn(object2, path3);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path3 = paths[index], value = baseGet(object2, path3);
            if (predicate(value, path3)) {
              baseSet(result2, castPath(path3, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path3) {
          return function(object2) {
            return baseGet(object2, path3);
          };
        }
        function basePullAll(array2, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
          if (array2 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n5) {
          var result2 = "";
          if (!string2 || n5 < 1 || n5 > MAX_SAFE_INTEGER2) {
            return result2;
          }
          do {
            if (n5 % 2) {
              result2 += string2;
            }
            n5 = nativeFloor(n5 / 2);
            if (n5) {
              string2 += string2;
            }
          } while (n5);
          return result2;
        }
        function baseRest(func2, start) {
          return setToString(overRest(func2, start, identity), func2 + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n5) {
          var array2 = values(collection);
          return shuffleSelf(array2, baseClamp(n5, 0, array2.length));
        }
        function baseSet(object2, path3, value, customizer) {
          if (!isObject3(object2)) {
            return object2;
          }
          path3 = castPath(path3, object2);
          var index = -1, length = path3.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey(path3[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject3(objValue) ? objValue : isIndex(path3[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity : function(func2, data) {
          metaMap.set(func2, data);
          return func2;
        };
        var baseSetToString = !defineProperty ? identity : function(func2, string2) {
          return defineProperty(func2, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array2);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path3) {
          path3 = castPath(path3, object2);
          object2 = parent(object2, path3);
          return object2 == null || delete object2[toKey(last(path3))];
        }
        function baseUpdate(object2, path3, updater, customizer) {
          return baseSet(object2, path3, updater(baseGet(object2, path3)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object2) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp2) {
          var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
          result2.lastIndex = regexp2.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func2 = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func2(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func2, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject3(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func2, bitmask, arity) {
          var Ctor = createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func2 = funcs[index];
              if (typeof func2 != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func2 = funcs[index];
              var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func2] : func2;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func2, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func2,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func2)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func2, bitmask);
        }
        function createRound(methodName) {
          var func2 = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString(number2) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func2(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func2);
          var newData = [
            func2,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func2 = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func2.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func2, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func2, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func2, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func2, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject3(objValue) && isObject3(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined2 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func2) {
          return setToString(overRest(func2, undefined2, flatten), func2 + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func2) {
          return metaMap.get(func2);
        };
        function getFuncName(func2) {
          var result2 = func2.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func2) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func2) {
          var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func2;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length = result2.length;
          while (length--) {
            var key = result2[length], value = object2[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value = getValue(object2, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e6) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size3 = data.size;
            switch (data.type) {
              case "drop":
                start += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start + size3);
                break;
              case "takeRight":
                start = nativeMax(start, end - size3);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path3, hasFunc) {
          path3 = castPath(path3, object2);
          var index = -1, length = path3.length, result2 = false;
          while (++index < length) {
            var key = toKey(path3[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject3(object2)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray2(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func2) {
          var funcName = getFuncName(func2), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func2 === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func2 === data[0];
        }
        function isMasked(func2) {
          return !!maskSrcKey && maskSrcKey in func2;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject3(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
          };
        }
        function memoizeCapped(func2) {
          var result2 = memoize(func2, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func2, start, transform2) {
          start = nativeMax(start === undefined2 ? func2.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array2);
            return apply(func2, this, otherArgs);
          };
        }
        function parent(object2, path3) {
          return path3.length < 2 ? object2 : baseGet(object2, baseSlice(path3, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func2, wait) {
          return root.setTimeout(func2, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func2) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func2.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size3) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size3 = size3 === undefined2 ? length : size3;
          while (++index < size3) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size3;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func2) {
          if (func2 != null) {
            try {
              return funcToString.call(func2);
            } catch (e6) {
            }
            try {
              return func2 + "";
            } catch (e6) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size3, guard) {
          if (guard ? isIterateeCall(array2, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size3);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n5, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          return baseSlice(array2, n5 < 0 ? 0 : n5, length);
        }
        function dropRight(array2, n5, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          n5 = length - n5;
          return baseSlice(array2, 0, n5 < 0 ? 0 : n5);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined2;
        }
        function lastIndexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n5) {
          return array2 && array2.length ? baseNth(array2, toInteger(n5)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
        }
        function pullAllBy(array2, values2, iteratee2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values2, comparator) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value);
            if (index < length && eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take(array2, n5, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          return baseSlice(array2, 0, n5 < 0 ? 0 : n5);
        }
        function takeRight(array2, n5, guard) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          n5 = length - n5;
          return baseSlice(array2, n5 < 0 ? 0 : n5, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip2(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip2(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip2);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func2 = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func2 = isArray2(collection) ? arrayFilter : baseFilter;
          return func2(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func2 = isArray2(collection) ? arrayEach : baseEach;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func2 = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path3, args) {
          var index = -1, isFunc = typeof path3 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path3, value, args) : baseInvoke(value, path3, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func2 = isArray2(collection) ? arrayMap : baseMap;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func2 = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func2 = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func2 = isArray2(collection) ? arrayFilter : baseFilter;
          return func2(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func2 = isArray2(collection) ? arraySample : baseSample;
          return func2(collection);
        }
        function sampleSize(collection, n5, guard) {
          if (guard ? isIterateeCall(collection, n5, guard) : n5 === undefined2) {
            n5 = 1;
          } else {
            n5 = toInteger(n5);
          }
          var func2 = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func2(collection, n5);
        }
        function shuffle(collection) {
          var func2 = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func2(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func2 = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n5, func2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n5 = toInteger(n5);
          return function() {
            if (--n5 < 1) {
              return func2.apply(this, arguments);
            }
          };
        }
        function ary(func2, n5, guard) {
          n5 = guard ? undefined2 : n5;
          n5 = func2 && n5 == null ? func2.length : n5;
          return createWrap(func2, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n5);
        }
        function before(n5, func2) {
          var result2;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n5 = toInteger(n5);
          return function() {
            if (--n5 > 0) {
              result2 = func2.apply(this, arguments);
            }
            if (n5 <= 1) {
              func2 = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func2, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func2, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func2, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject3(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func2.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func2, args) {
          return baseDelay(func2, 1, args);
        });
        var delay = baseRest(function(func2, wait, args) {
          return baseDelay(func2, toNumber(wait) || 0, args);
        });
        function flip(func2) {
          return createWrap(func2, WRAP_FLIP_FLAG);
        }
        function memoize(func2, resolver) {
          if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func2.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once3(func2) {
          return before(2, func2);
        }
        var overArgs = castRest(function(func2, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func2, this, args);
          });
        });
        var partial2 = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partial2));
          return createWrap(func2, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func2, indexes) {
          return createWrap(func2, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func2, start);
        }
        function spread(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func2, this, otherArgs);
          });
        }
        function throttle(func2, wait, options) {
          var leading = true, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject3(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func2, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func2) {
          return ary(func2, 1);
        }
        function wrap(value, wrapper) {
          return partial2(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError2(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject3(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
        }
        function isObject3(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func2 = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func2(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN;
          }
          if (isObject3(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject3(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get5(object2, path3, defaultValue) {
          var result2 = object2 == null ? undefined2 : baseGet(object2, path3);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object2, path3) {
          return object2 != null && hasPath(object2, path3, baseHas);
        }
        function hasIn(object2, path3) {
          return object2 != null && hasPath(object2, path3, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, iteratee2(value, key, object3), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, key, iteratee2(value, key, object3));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path3) {
            path3 = castPath(path3, object2);
            isDeep || (isDeep = path3.length > 1);
            return path3;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy2(object2, predicate) {
          return pickBy2(object2, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy2(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path3) {
            return predicate(value, path3[0]);
          });
        }
        function result(object2, path3, defaultValue) {
          path3 = castPath(path3, object2);
          var index = -1, length = path3.length;
          if (!length) {
            length = 1;
            object2 = undefined2;
          }
          while (++index < length) {
            var value = object2 == null ? undefined2 : object2[toKey(path3[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object2 = isFunction2(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set2(object2, path3, value) {
          return object2 == null ? object2 : baseSet(object2, path3, value);
        }
        function setWith(object2, path3, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseSet(object2, path3, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object2, iteratee2, accumulator) {
          var isArr = isArray2(object2), isArrLike = isArr || isBuffer2(object2) || isTypedArray(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject3(object2)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee2(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path3) {
          return object2 == null ? true : baseUnset(object2, path3);
        }
        function update(object2, path3, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path3, castFunction(updater));
        }
        function updateWith(object2, path3, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseUpdate(object2, path3, castFunction(updater), customizer);
        }
        function values(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape2(string2) {
          string2 = toString(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
        }
        function padStart(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string2, n5, guard) {
          if (guard ? isIterateeCall(string2, n5, guard) : n5 === undefined2) {
            n5 = 1;
          } else {
            n5 = toInteger(n5);
          }
          return baseRepeat(toString(string2), n5);
        }
        function replace() {
          var args = arguments, string2 = toString(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined2;
          }
          string2 = toString(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError2(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject3(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string2.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string2) {
          string2 = toString(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern2, guard) {
          string2 = toString(string2);
          pattern2 = guard ? undefined2 : pattern2;
          if (pattern2 === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern2) || [];
        }
        var attempt = baseRest(function(func2, args) {
          try {
            return apply(func2, undefined2, args);
          } catch (e6) {
            return isError2(e6) ? e6 : new Error2(e6);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func2) {
          return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path3, srcValue) {
          return baseMatchesProperty(path3, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path3, args) {
          return function(object2) {
            return baseInvoke(object2, path3, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path3) {
            return baseInvoke(object2, path3, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object2);
          arrayEach(methodNames, function(methodName) {
            var func2 = source[methodName];
            object2[methodName] = func2;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func2, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func2.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n5) {
          n5 = toInteger(n5);
          return baseRest(function(args) {
            return baseNth(args, n5);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path3) {
          return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
        }
        function propertyOf(object2) {
          return function(path3) {
            return object2 == null ? undefined2 : baseGet(object2, path3);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n5, iteratee2) {
          n5 = toInteger(n5);
          if (n5 < 1 || n5 > MAX_SAFE_INTEGER2) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n5, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n5 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n5) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array2) {
          return baseMean(array2, identity);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min2(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit2;
        lodash.omitBy = omitBy2;
        lodash.once = once3;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial2;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy2;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip2;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep2;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get5;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean2;
        lodash.isBuffer = isBuffer2;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError2;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject3;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject2;
        lodash.isRegExp = isRegExp2;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol2;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max2;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min2;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size2;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func2, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func2;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n5) {
            n5 = n5 === undefined2 ? 1 : nativeMax(toInteger(n5), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n5, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n5, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n5) {
            return this.reverse()[methodName](n5).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path3, args) {
          if (typeof path3 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path3, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func2.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func2.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func2.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func2.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports10);
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports10, module) {
    module.exports = (init_events3(), __toCommonJS(events_exports)).EventEmitter;
  }
});

// node-modules-polyfills-empty:util
var require_util2 = __commonJS({
  "node-modules-polyfills-empty:util"(exports10, module) {
    module.exports = {};
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports10, module) {
    "use strict";
    function ownKeys3(object2, enumerableOnly) {
      var keys = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = null != arguments[i4] ? arguments[i4] : {};
        i4 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i4 = 0; i4 < props.length; i4++) {
        var descriptor = props[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = (init_buffer(), __toCommonJS(buffer_exports));
    var Buffer2 = _require.Buffer;
    var _require2 = require_util2();
    var inspect2 = _require2.inspect;
    var custom = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v4) {
          var entry = {
            data: v4,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v4) {
          var entry = {
            data: v4,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s2) {
          if (this.length === 0)
            return "";
          var p4 = this.head;
          var ret = "" + p4.data;
          while (p4 = p4.next)
            ret += s2 + p4.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n5) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n5 >>> 0);
          var p4 = this.head;
          var i4 = 0;
          while (p4) {
            copyBuffer(p4.data, ret, i4);
            i4 += p4.data.length;
            p4 = p4.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n5, hasStrings) {
          var ret;
          if (n5 < this.head.data.length) {
            ret = this.head.data.slice(0, n5);
            this.head.data = this.head.data.slice(n5);
          } else if (n5 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n5) : this._getBuffer(n5);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n5) {
          var p4 = this.head;
          var c4 = 1;
          var ret = p4.data;
          n5 -= ret.length;
          while (p4 = p4.next) {
            var str = p4.data;
            var nb = n5 > str.length ? str.length : n5;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n5);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === str.length) {
                ++c4;
                if (p4.next)
                  this.head = p4.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p4;
                p4.data = str.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n5) {
          var ret = Buffer2.allocUnsafe(n5);
          var p4 = this.head;
          var c4 = 1;
          p4.data.copy(ret);
          n5 -= p4.data.length;
          while (p4 = p4.next) {
            var buf = p4.data;
            var nb = n5 > buf.length ? buf.length : n5;
            buf.copy(ret, ret.length - n5, 0, nb);
            n5 -= nb;
            if (n5 === 0) {
              if (nb === buf.length) {
                ++c4;
                if (p4.next)
                  this.head = p4.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p4;
                p4.data = buf.slice(nb);
              }
              break;
            }
            ++c4;
          }
          this.length -= c4;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect2(this, _objectSpread3(_objectSpread3({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports10, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports10, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes2 = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes2[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i4) {
          return String(i4);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes2;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports10, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
var require_browser5 = __commonJS({
  "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports10, module) {
    module.exports = deprecate2;
    function deprecate2(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated2() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated2;
    }
    function config(name) {
      try {
        if (!globalThis.localStorage)
          return false;
      } catch (_2) {
        return false;
      }
      var val = globalThis.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports10, module) {
    "use strict";
    module.exports = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex4;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser5()
    };
    var Stream2 = require_stream_browser();
    var Buffer2 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex4 = Duplex4 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex4;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable2)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object2) {
        return object2 instanceof this;
      };
    }
    function Writable2(options) {
      Duplex4 = Duplex4 || require_stream_duplex();
      var isDuplex = this instanceof Duplex4;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l4 = state.bufferedRequestCount;
        var buffer2 = new Array(l4);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set2(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports10, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex4;
    var Readable2 = require_stream_readable();
    var Writable2 = require_stream_writable();
    require_inherits_browser()(Duplex4, Readable2);
    {
      keys = objectKeys(Writable2.prototype);
      for (v4 = 0; v4 < keys.length; v4++) {
        method = keys[v4];
        if (!Duplex4.prototype[method])
          Duplex4.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys;
    var method;
    var v4;
    function Duplex4(options) {
      if (!(this instanceof Duplex4))
        return new Duplex4(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex4.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex4.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex4.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex4.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set2(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream3 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports10, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos3(stream, opts, callback) {
      if (typeof opts === "function")
        return eos3(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once3(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos3;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports10, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty2(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished2 = require_end_of_stream3();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve3 = iter[kLastResolve];
      if (resolve3 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve3(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve3, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve3(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve3, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve3, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve3(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve3, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve3(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty2(_Object$create, kHandlePromise, {
        value: function value(resolve3, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve3(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve3;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve3 = iterator[kLastResolve];
        if (resolve3 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports10, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports10, module) {
    "use strict";
    module.exports = Readable2;
    var Duplex4;
    Readable2.ReadableState = ReadableState;
    var EE = (init_events3(), __toCommonJS(events_exports)).EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer2 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util2();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex4 = Duplex4 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex4;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex4 = Duplex4 || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex4;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set2(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p4 = this._readableState.buffer.head;
      var content = "";
      while (p4 !== null) {
        content += decoder.write(p4.data);
        p4 = p4.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n5) {
      if (n5 >= MAX_HWM) {
        n5 = MAX_HWM;
      } else {
        n5--;
        n5 |= n5 >>> 1;
        n5 |= n5 >>> 2;
        n5 |= n5 >>> 4;
        n5 |= n5 >>> 8;
        n5 |= n5 >>> 16;
        n5++;
      }
      return n5;
    }
    function howMuchToRead(n5, state) {
      if (n5 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n5 !== n5) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n5 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n5);
      if (n5 <= state.length)
        return n5;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n5) {
      debug("read", n5);
      n5 = parseInt(n5, 10);
      var state = this._readableState;
      var nOrig = n5;
      if (n5 !== 0)
        state.emittedReadable = false;
      if (n5 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n5 = howMuchToRead(n5, state);
      if (n5 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n5 < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n5 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n5 > 0)
        ret = fromList(n5, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n5 = 0;
      } else {
        state.length -= n5;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n5 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n5) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i4 = 0; i4 < len; i4++)
          dests[i4].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      for (var n5 = 0; n5 < kProxyEvents.length; n5++) {
        stream.on(kProxyEvents[n5], this.emit.bind(this, kProxyEvents[n5]));
      }
      this._read = function(n6) {
        debug("wrapped _read", n6);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.flowing;
      },
      set: function set2(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get5() {
        return this._readableState.length;
      }
    });
    function fromList(n5, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n5 || n5 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n5, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x2) {
      for (var i4 = 0, l4 = xs.length; i4 < l4; i4++) {
        if (xs[i4] === x2)
          return i4;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports10, module) {
    "use strict";
    module.exports = Transform2;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex4 = require_stream_duplex();
    require_inherits_browser()(Transform2, Duplex4);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex4.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex4.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n5) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex4.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports10, module) {
    "use strict";
    module.exports = PassThrough2;
    var Transform2 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports10, module) {
    "use strict";
    var eos3;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos3 === void 0)
        eos3 = require_end_of_stream3();
      eos3(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline2;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js"(exports10, module) {
    exports10 = module.exports = require_stream_readable();
    exports10.Stream = exports10;
    exports10.Readable = exports10;
    exports10.Writable = require_stream_writable();
    exports10.Duplex = require_stream_duplex();
    exports10.Transform = require_stream_transform();
    exports10.PassThrough = require_stream_passthrough();
    exports10.finished = require_end_of_stream3();
    exports10.pipeline = require_pipeline2();
  }
});

// node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js
var require_browser6 = __commonJS({
  "node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js"(exports10, module) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto2 = globalThis.crypto || globalThis.msCrypto;
    if (crypto2 && crypto2.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes(size2, cb) {
      if (size2 > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes = Buffer2.allocUnsafe(size2);
      if (size2 > 0) {
        if (size2 > MAX_BYTES) {
          for (var generated = 0; generated < size2; generated += MAX_BYTES) {
            crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto2.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/pad-string.js
var require_pad_string = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/pad-string.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
        return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer2 = Buffer.alloc(paddedStringLength);
      buffer2.write(input);
      while (padLength--) {
        buffer2.write("=", position++);
      }
      return buffer2.toString();
    }
    exports10.default = padString;
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/base64url.js
var require_base64url = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/dist/base64url.js"(exports10) {
    "use strict";
    Object.defineProperty(exports10, "__esModule", { value: true });
    var pad_string_1 = require_pad_string();
    function encode(input, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      if (Buffer.isBuffer(input)) {
        return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
    }
    function decode(base64url2, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(toBase64(base64url2), "base64").toString(encoding);
    }
    function toBase64(base64url2) {
      base64url2 = base64url2.toString();
      return pad_string_1.default(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBuffer(base64url2) {
      return Buffer.from(toBase64(base64url2), "base64");
    }
    var base64url = encode;
    base64url.encode = encode;
    base64url.decode = decode;
    base64url.toBase64 = toBase64;
    base64url.fromBase64 = fromBase64;
    base64url.toBuffer = toBuffer;
    exports10.default = base64url;
  }
});

// node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/index.js
var require_base64url2 = __commonJS({
  "node_modules/.pnpm/base64url@3.0.1/node_modules/base64url/index.js"(exports10, module) {
    module.exports = require_base64url().default;
    module.exports.default = module.exports;
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/keccak.js"(exports10, module) {
    var { Transform: Transform2 } = require_readable_browser();
    module.exports = (KeccakState) => class Keccak extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      }
      // remove result from memory
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      // because sometimes we need hash right now and little later
      _clone() {
        const clone2 = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone2._state);
        clone2._finalized = this._finalized;
        return clone2;
      }
    };
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/shake.js"(exports10, module) {
    var { Transform: Transform2 } = require_readable_browser();
    module.exports = (KeccakState) => class Shake extends Transform2 {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size2) {
        this.push(this.squeeze(size2));
      }
      update(data, encoding) {
        if (!Buffer.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        this._state.absorb(data);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone2 = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone2._state);
        clone2._finalized = this._finalized;
        return clone2;
      }
    };
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/api/index.js"(exports10, module) {
    var createKeccak = require_keccak2();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/keccak-state-unroll.js"(exports10) {
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports10.p1600 = function(s2) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s2[0] ^ lo;
        const t1shi0 = s2[1] ^ hi;
        const t1slo5 = s2[10] ^ lo;
        const t1shi5 = s2[11] ^ hi;
        const t1slo10 = s2[20] ^ lo;
        const t1shi10 = s2[21] ^ hi;
        const t1slo15 = s2[30] ^ lo;
        const t1shi15 = s2[31] ^ hi;
        const t1slo20 = s2[40] ^ lo;
        const t1shi20 = s2[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s2[2] ^ lo;
        const t1shi1 = s2[3] ^ hi;
        const t1slo6 = s2[12] ^ lo;
        const t1shi6 = s2[13] ^ hi;
        const t1slo11 = s2[22] ^ lo;
        const t1shi11 = s2[23] ^ hi;
        const t1slo16 = s2[32] ^ lo;
        const t1shi16 = s2[33] ^ hi;
        const t1slo21 = s2[42] ^ lo;
        const t1shi21 = s2[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s2[4] ^ lo;
        const t1shi2 = s2[5] ^ hi;
        const t1slo7 = s2[14] ^ lo;
        const t1shi7 = s2[15] ^ hi;
        const t1slo12 = s2[24] ^ lo;
        const t1shi12 = s2[25] ^ hi;
        const t1slo17 = s2[34] ^ lo;
        const t1shi17 = s2[35] ^ hi;
        const t1slo22 = s2[44] ^ lo;
        const t1shi22 = s2[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s2[6] ^ lo;
        const t1shi3 = s2[7] ^ hi;
        const t1slo8 = s2[16] ^ lo;
        const t1shi8 = s2[17] ^ hi;
        const t1slo13 = s2[26] ^ lo;
        const t1shi13 = s2[27] ^ hi;
        const t1slo18 = s2[36] ^ lo;
        const t1shi18 = s2[37] ^ hi;
        const t1slo23 = s2[46] ^ lo;
        const t1shi23 = s2[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s2[8] ^ lo;
        const t1shi4 = s2[9] ^ hi;
        const t1slo9 = s2[18] ^ lo;
        const t1shi9 = s2[19] ^ hi;
        const t1slo14 = s2[28] ^ lo;
        const t1shi14 = s2[29] ^ hi;
        const t1slo19 = s2[38] ^ lo;
        const t1shi19 = s2[39] ^ hi;
        const t1slo24 = s2[48] ^ lo;
        const t1shi24 = s2[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/lib/keccak.js"(exports10, module) {
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i4 = 0; i4 < 50; ++i4)
        this.state[i4] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (let i4 = 0; i4 < data.length; ++i4) {
        this.state[~~(this.count / 4)] ^= data[i4] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer.alloc(length);
      for (let i4 = 0; i4 < length; ++i4) {
        output[i4] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i4 = 0; i4 < 50; ++i4)
        dest.state[i4] = this.state[i4];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/.pnpm/keccak@3.0.4/node_modules/keccak/js.js"(exports10, module) {
    module.exports = require_api()(require_keccak3());
  }
});

// node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports10, module) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module.exports = isStream;
  }
});

// node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports10, module) {
    "use strict";
    module.exports = function equal2(a4, b4) {
      if (a4 === b4)
        return true;
      if (a4 && b4 && typeof a4 == "object" && typeof b4 == "object") {
        if (a4.constructor !== b4.constructor)
          return false;
        var length, i4, keys;
        if (Array.isArray(a4)) {
          length = a4.length;
          if (length != b4.length)
            return false;
          for (i4 = length; i4-- !== 0; )
            if (!equal2(a4[i4], b4[i4]))
              return false;
          return true;
        }
        if (a4.constructor === RegExp)
          return a4.source === b4.source && a4.flags === b4.flags;
        if (a4.valueOf !== Object.prototype.valueOf)
          return a4.valueOf() === b4.valueOf();
        if (a4.toString !== Object.prototype.toString)
          return a4.toString() === b4.toString();
        keys = Object.keys(a4);
        length = keys.length;
        if (length !== Object.keys(b4).length)
          return false;
        for (i4 = length; i4-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b4, keys[i4]))
            return false;
        for (i4 = length; i4-- !== 0; ) {
          var key = keys[i4];
          if (!equal2(a4[key], b4[key]))
            return false;
        }
        return true;
      }
      return a4 !== a4 && b4 !== b4;
    };
  }
});

// node_modules/.pnpm/@babel+runtime@7.23.8/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o5) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o6) {
    return typeof o6;
  } : function(o6) {
    return o6 && "function" == typeof Symbol && o6.constructor === Symbol && o6 !== Symbol.prototype ? "symbol" : typeof o6;
  }, _typeof(o5);
}

// node_modules/.pnpm/@babel+runtime@7.23.8/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t4, r6) {
  if ("object" != _typeof(t4) || !t4)
    return t4;
  var e6 = t4[Symbol.toPrimitive];
  if (void 0 !== e6) {
    var i4 = e6.call(t4, r6 || "default");
    if ("object" != _typeof(i4))
      return i4;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r6 ? String : Number)(t4);
}

// node_modules/.pnpm/@babel+runtime@7.23.8/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t4) {
  var i4 = toPrimitive(t4, "string");
  return "symbol" == _typeof(i4) ? i4 : String(i4);
}

// node_modules/.pnpm/@babel+runtime@7.23.8/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/.pnpm/@toruslabs+solana-embed@0.3.4_@babel+runtime@7.23.8_@sentry+types@7.92.0_bufferutil@4.0.9_enc_b7hvoxl7mypogoedcaiqvxlhja/node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js
init_index_browser_esm();

// node_modules/.pnpm/@toruslabs+openlogin-jrpc@4.7.2_@babel+runtime@7.23.8/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
var import_readable_stream = __toESM(require_browser3());
var import_fast_safe_stringify = __toESM(require_fast_safe_stringify());
var import_rpc_errors = __toESM(require_dist2());
var import_end_of_stream = __toESM(require_end_of_stream2());
var import_once = __toESM(require_once());
var import_pump = __toESM(require_pump());
var IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");

// node_modules/.pnpm/@toruslabs+base-controllers@2.9.0_@babel+runtime@7.23.8_@sentry+types@7.92.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js
var import_eth_rpc_errors = __toESM(require_dist3());
var import_json_rpc_random_id = __toESM(require_json_rpc_random_id());
var import_util3 = __toESM(require_dist5());

// node_modules/.pnpm/bignumber.js@9.1.2/node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v4, b4) {
    var alphabet, c4, caseChanged, e6, i4, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2))
      return new BigNumber2(v4, b4);
    if (b4 == null) {
      if (v4 && v4._isBigNumber === true) {
        x2.s = v4.s;
        if (!v4.c || v4.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v4.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v4.e;
          x2.c = v4.c.slice();
        }
        return;
      }
      if ((isNum = typeof v4 == "number") && v4 * 0 == 0) {
        x2.s = 1 / v4 < 0 ? (v4 = -v4, -1) : 1;
        if (v4 === ~~v4) {
          for (e6 = 0, i4 = v4; i4 >= 10; i4 /= 10, e6++)
            ;
          if (e6 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e6;
            x2.c = [v4];
          }
          return;
        }
        str = String(v4);
      } else {
        if (!isNumeric.test(str = String(v4)))
          return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e6 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i4 = str.search(/e/i)) > 0) {
        if (e6 < 0)
          e6 = i4;
        e6 += +str.slice(i4 + 1);
        str = str.substring(0, i4);
      } else if (e6 < 0) {
        e6 = str.length;
      }
    } else {
      intCheck(b4, 2, ALPHABET.length, "Base");
      if (b4 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v4);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v4);
      if (isNum = typeof v4 == "number") {
        if (v4 * 0 != 0)
          return parseNumeric(x2, str, isNum, b4);
        x2.s = 1 / v4 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v4);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b4);
      e6 = i4 = 0;
      for (len = str.length; i4 < len; i4++) {
        if (alphabet.indexOf(c4 = str.charAt(i4)) < 0) {
          if (c4 == ".") {
            if (i4 > e6) {
              e6 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i4 = -1;
              e6 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v4), isNum, b4);
        }
      }
      isNum = false;
      str = convertBase(str, b4, 10, x2.s);
      if ((e6 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e6 = str.length;
    }
    for (i4 = 0; str.charCodeAt(i4) === 48; i4++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i4, ++len)) {
      len -= i4;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v4 > MAX_SAFE_INTEGER || v4 !== mathfloor(v4))) {
        throw Error(tooManyDigits + x2.s * v4);
      }
      if ((e6 = e6 - i4 - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e6 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e6;
        x2.c = [];
        i4 = (e6 + 1) % LOG_BASE;
        if (e6 < 0)
          i4 += LOG_BASE;
        if (i4 < len) {
          if (i4)
            x2.c.push(+str.slice(0, i4));
          for (len -= LOG_BASE; i4 < len; ) {
            x2.c.push(+str.slice(i4, i4 += LOG_BASE));
          }
          i4 = LOG_BASE - (str = str.slice(i4)).length;
        } else {
          i4 -= len;
        }
        for (; i4--; str += "0")
          ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p4, v4;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p4 = "DECIMAL_PLACES")) {
          v4 = obj[p4];
          intCheck(v4, 0, MAX, p4);
          DECIMAL_PLACES = v4;
        }
        if (obj.hasOwnProperty(p4 = "ROUNDING_MODE")) {
          v4 = obj[p4];
          intCheck(v4, 0, 8, p4);
          ROUNDING_MODE = v4;
        }
        if (obj.hasOwnProperty(p4 = "EXPONENTIAL_AT")) {
          v4 = obj[p4];
          if (v4 && v4.pop) {
            intCheck(v4[0], -MAX, 0, p4);
            intCheck(v4[1], 0, MAX, p4);
            TO_EXP_NEG = v4[0];
            TO_EXP_POS = v4[1];
          } else {
            intCheck(v4, -MAX, MAX, p4);
            TO_EXP_NEG = -(TO_EXP_POS = v4 < 0 ? -v4 : v4);
          }
        }
        if (obj.hasOwnProperty(p4 = "RANGE")) {
          v4 = obj[p4];
          if (v4 && v4.pop) {
            intCheck(v4[0], -MAX, -1, p4);
            intCheck(v4[1], 1, MAX, p4);
            MIN_EXP = v4[0];
            MAX_EXP = v4[1];
          } else {
            intCheck(v4, -MAX, MAX, p4);
            if (v4) {
              MIN_EXP = -(MAX_EXP = v4 < 0 ? -v4 : v4);
            } else {
              throw Error(bignumberError + p4 + " cannot be zero: " + v4);
            }
          }
        }
        if (obj.hasOwnProperty(p4 = "CRYPTO")) {
          v4 = obj[p4];
          if (v4 === !!v4) {
            if (v4) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v4;
              } else {
                CRYPTO = !v4;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v4;
            }
          } else {
            throw Error(bignumberError + p4 + " not true or false: " + v4);
          }
        }
        if (obj.hasOwnProperty(p4 = "MODULO_MODE")) {
          v4 = obj[p4];
          intCheck(v4, 0, 9, p4);
          MODULO_MODE = v4;
        }
        if (obj.hasOwnProperty(p4 = "POW_PRECISION")) {
          v4 = obj[p4];
          intCheck(v4, 0, MAX, p4);
          POW_PRECISION = v4;
        }
        if (obj.hasOwnProperty(p4 = "FORMAT")) {
          v4 = obj[p4];
          if (typeof v4 == "object")
            FORMAT = v4;
          else
            throw Error(bignumberError + p4 + " not an object: " + v4);
        }
        if (obj.hasOwnProperty(p4 = "ALPHABET")) {
          v4 = obj[p4];
          if (typeof v4 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v4)) {
            alphabetHasNormalDecimalDigits = v4.slice(0, 10) == "0123456789";
            ALPHABET = v4;
          } else {
            throw Error(bignumberError + p4 + " invalid: " + v4);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v4) {
    if (!v4 || v4._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i4, n5, c4 = v4.c, e6 = v4.e, s2 = v4.s;
    out:
      if ({}.toString.call(c4) == "[object Array]") {
        if ((s2 === 1 || s2 === -1) && e6 >= -MAX && e6 <= MAX && e6 === mathfloor(e6)) {
          if (c4[0] === 0) {
            if (e6 === 0 && c4.length === 1)
              return true;
            break out;
          }
          i4 = (e6 + 1) % LOG_BASE;
          if (i4 < 1)
            i4 += LOG_BASE;
          if (String(c4[0]).length == i4) {
            for (i4 = 0; i4 < c4.length; i4++) {
              n5 = c4[i4];
              if (n5 < 0 || n5 >= BASE || n5 !== mathfloor(n5))
                break out;
            }
            if (n5 !== 0)
              return true;
          }
        }
      } else if (c4 === null && e6 === null && (s2 === null || s2 === 1 || s2 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v4);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a4, b4, e6, k2, v4, i4 = 0, c4 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a4 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i4 < k2; ) {
            v4 = a4[i4] * 131072 + (a4[i4 + 1] >>> 11);
            if (v4 >= 9e15) {
              b4 = crypto.getRandomValues(new Uint32Array(2));
              a4[i4] = b4[0];
              a4[i4 + 1] = b4[1];
            } else {
              c4.push(v4 % 1e14);
              i4 += 2;
            }
          }
          i4 = k2 / 2;
        } else if (crypto.randomBytes) {
          a4 = crypto.randomBytes(k2 *= 7);
          for (; i4 < k2; ) {
            v4 = (a4[i4] & 31) * 281474976710656 + a4[i4 + 1] * 1099511627776 + a4[i4 + 2] * 4294967296 + a4[i4 + 3] * 16777216 + (a4[i4 + 4] << 16) + (a4[i4 + 5] << 8) + a4[i4 + 6];
            if (v4 >= 9e15) {
              crypto.randomBytes(7).copy(a4, i4);
            } else {
              c4.push(v4 % 1e14);
              i4 += 7;
            }
          }
          i4 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i4 < k2; ) {
          v4 = random53bitInt();
          if (v4 < 9e15)
            c4[i4++] = v4 % 1e14;
        }
      }
      k2 = c4[--i4];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v4 = POWS_TEN[LOG_BASE - dp];
        c4[i4] = mathfloor(k2 / v4) * v4;
      }
      for (; c4[i4] === 0; c4.pop(), i4--)
        ;
      if (i4 < 0) {
        c4 = [e6 = 0];
      } else {
        for (e6 = -1; c4[0] === 0; c4.splice(0, 1), e6 -= LOG_BASE)
          ;
        for (i4 = 1, v4 = c4[0]; v4 >= 10; v4 /= 10, i4++)
          ;
        if (i4 < LOG_BASE)
          e6 -= LOG_BASE - i4;
      }
      rand.e = e6;
      rand.c = c4;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i4 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i4 < args.length; )
      sum = sum.plus(args[i4++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j2, arr = [0], arrL, i4 = 0, len = str.length;
      for (; i4 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i4++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null)
              arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d3, e6, k2, r6, x2, xc, y4, i4 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i4 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y4 = new BigNumber2(baseIn);
        x2 = y4.pow(str.length - i4);
        POW_PRECISION = k2;
        y4.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y4.e = y4.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e6 = k2 = xc.length;
      for (; xc[--k2] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i4 < 0) {
        --e6;
      } else {
        x2.c = xc;
        x2.e = e6;
        x2.s = sign;
        x2 = div(x2, y4, dp, rm, baseOut);
        xc = x2.c;
        r6 = x2.r;
        e6 = x2.e;
      }
      d3 = e6 + dp + 1;
      i4 = xc[d3];
      k2 = baseOut / 2;
      r6 = r6 || d3 < 0 || xc[d3 + 1] != null;
      r6 = rm < 4 ? (i4 != null || r6) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i4 > k2 || i4 == k2 && (rm == 4 || r6 || rm == 6 && xc[d3 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d3 < 1 || !xc[0]) {
        str = r6 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d3;
        if (r6) {
          for (--baseOut; ++xc[--d3] > baseOut; ) {
            xc[d3] = 0;
            if (!d3) {
              ++e6;
              xc = [1].concat(xc);
            }
          }
        }
        for (k2 = xc.length; !xc[--k2]; )
          ;
        for (i4 = 0, str = ""; i4 <= k2; str += alphabet.charAt(xc[i4++]))
          ;
        str = toFixedPoint(str, e6, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x2, k2, base) {
      var m4, temp, xlo, xhi, carry = 0, i4 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i4--; ) {
        xlo = x2[i4] % SQRT_BASE;
        xhi = x2[i4] / SQRT_BASE | 0;
        m4 = khi * xlo + xhi * klo;
        temp = klo * xlo + m4 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m4 / SQRT_BASE | 0) + khi * xhi;
        x2[i4] = temp % base;
      }
      if (carry)
        x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a4, b4, aL, bL) {
      var i4, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i4 = cmp = 0; i4 < aL; i4++) {
          if (a4[i4] != b4[i4]) {
            cmp = a4[i4] > b4[i4] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a4, b4, aL, base) {
      var i4 = 0;
      for (; aL--; ) {
        a4[aL] -= i4;
        i4 = a4[aL] < b4[aL] ? 1 : 0;
        a4[aL] = i4 * base + a4[aL] - b4[aL];
      }
      for (; !a4[0] && a4.length > 1; a4.splice(0, 1))
        ;
    }
    return function(x2, y4, dp, rm, base) {
      var cmp, e6, i4, more, n5, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y4.s ? 1 : -1, xc = x2.c, yc = y4.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y4.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
          )
        );
      }
      q2 = new BigNumber2(s2);
      qc = q2.c = [];
      e6 = x2.e - y4.e;
      s2 = dp + e6 + 1;
      if (!base) {
        base = BASE;
        e6 = bitFloor(x2.e / LOG_BASE) - bitFloor(y4.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i4 = 0; yc[i4] == (xc[i4] || 0); i4++)
        ;
      if (yc[i4] > (xc[i4] || 0))
        e6--;
      if (s2 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i4 = 0;
        s2 += 2;
        n5 = mathfloor(base / (yc[0] + 1));
        if (n5 > 1) {
          yc = multiply(yc, n5, base);
          xc = multiply(xc, n5, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n5 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n5 = mathfloor(rem0 / yc0);
            if (n5 > 1) {
              if (n5 >= base)
                n5 = base - 1;
              prod = multiply(yc, n5, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n5--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n5 == 0) {
                cmp = n5 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n5++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n5++;
            rem = [0];
          }
          qc[i4++] = n5;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i4 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i4++)
          ;
        round(q2, dp + (q2.e = i4 + e6 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q2.e = e6;
        q2.r = +more;
      }
      return q2;
    };
  }();
  function format4(n5, i4, rm, id) {
    var c0, e6, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n5.c)
      return n5.toString();
    c0 = n5.c[0];
    ne = n5.e;
    if (i4 == null) {
      str = coeffToString(n5.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n5 = round(new BigNumber2(n5), i4, rm);
      e6 = n5.e;
      str = coeffToString(n5.c);
      len = str.length;
      if (id == 1 || id == 2 && (i4 <= e6 || e6 <= TO_EXP_NEG)) {
        for (; len < i4; str += "0", len++)
          ;
        str = toExponential(str, e6);
      } else {
        i4 -= ne;
        str = toFixedPoint(str, e6, "0");
        if (e6 + 1 > len) {
          if (--i4 > 0)
            for (str += "."; i4--; str += "0")
              ;
        } else {
          i4 += e6 - len;
          if (i4 > 0) {
            if (e6 + 1 == len)
              str += ".";
            for (; i4--; str += "0")
              ;
          }
        }
      }
    }
    return n5.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n5) {
    var k2, y4, i4 = 1, x2 = new BigNumber2(args[0]);
    for (; i4 < args.length; i4++) {
      y4 = new BigNumber2(args[i4]);
      if (!y4.s || (k2 = compare(x2, y4)) === n5 || k2 === 0 && x2.s === n5) {
        x2 = y4;
      }
    }
    return x2;
  }
  function normalise(n5, c4, e6) {
    var i4 = 1, j2 = c4.length;
    for (; !c4[--j2]; c4.pop())
      ;
    for (j2 = c4[0]; j2 >= 10; j2 /= 10, i4++)
      ;
    if ((e6 = i4 + e6 * LOG_BASE - 1) > MAX_EXP) {
      n5.c = n5.e = null;
    } else if (e6 < MIN_EXP) {
      n5.c = [n5.e = 0];
    } else {
      n5.e = e6;
      n5.c = c4;
    }
    return n5;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b4) {
      var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m4, p1, p22) {
            base = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b4 || b4 == base ? p1 : m4;
          });
          if (b4) {
            base = b4;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2)
            return new BigNumber2(s2, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b4 ? " base " + b4 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round(x2, sd, rm, r6) {
    var d3, i4, j2, k2, n5, ni, rd, xc = x2.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d3 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d3++)
          ;
        i4 = sd - d3;
        if (i4 < 0) {
          i4 += LOG_BASE;
          j2 = sd;
          n5 = xc[ni = 0];
          rd = mathfloor(n5 / pows10[d3 - j2 - 1] % 10);
        } else {
          ni = mathceil((i4 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r6) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n5 = rd = 0;
              d3 = 1;
              i4 %= LOG_BASE;
              j2 = i4 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n5 = k2 = xc[ni];
            for (d3 = 1; k2 >= 10; k2 /= 10, d3++)
              ;
            i4 %= LOG_BASE;
            j2 = i4 - LOG_BASE + d3;
            rd = j2 < 0 ? 0 : mathfloor(n5 / pows10[d3 - j2 - 1] % 10);
          }
        }
        r6 = r6 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n5 : n5 % pows10[d3 - j2 - 1]);
        r6 = rm < 4 ? (rd || r6) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r6 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i4 > 0 ? j2 > 0 ? n5 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r6) {
            sd -= x2.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc[0] = x2.e = 0;
          }
          return x2;
        }
        if (i4 == 0) {
          xc.length = ni;
          k2 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k2 = pows10[LOG_BASE - i4];
          xc[ni] = j2 > 0 ? mathfloor(n5 / pows10[d3 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r6) {
          for (; ; ) {
            if (ni == 0) {
              for (i4 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i4++)
                ;
              j2 = xc[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                ;
              if (i4 != k2) {
                x2.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k2;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k2 = 1;
            }
          }
        }
        for (i4 = xc.length; xc[--i4] === 0; xc.pop())
          ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n5) {
    var str, e6 = n5.e;
    if (e6 === null)
      return n5.toString();
    str = coeffToString(n5.c);
    str = e6 <= TO_EXP_NEG || e6 >= TO_EXP_POS ? toExponential(str, e6) : toFixedPoint(str, e6, "0");
    return n5.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0)
      x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y4, b4) {
    return compare(this, new BigNumber2(y4, b4));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c4, n5, v4, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c4 = x2.c))
      return null;
    n5 = ((v4 = c4.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v4 = c4[v4])
      for (; v4 % 10 == 0; v4 /= 10, n5--)
        ;
    if (n5 < 0)
      n5 = 0;
    return n5;
  };
  P2.dividedBy = P2.div = function(y4, b4) {
    return div(this, new BigNumber2(y4, b4), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y4, b4) {
    return div(this, new BigNumber2(y4, b4), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n5, m4) {
    var half, isModExp, i4, k2, more, nIsBig, nIsNeg, nIsOdd, y4, x2 = this;
    n5 = new BigNumber2(n5);
    if (n5.c && !n5.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n5));
    }
    if (m4 != null)
      m4 = new BigNumber2(m4);
    nIsBig = n5.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n5.c || !n5.c[0]) {
      y4 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n5.s * (2 - isOdd(n5)) : +valueOf(n5)));
      return m4 ? y4.mod(m4) : y4;
    }
    nIsNeg = n5.s < 0;
    if (m4) {
      if (m4.c ? !m4.c[0] : !m4.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m4.isInteger();
      if (isModExp)
        x2 = x2.mod(m4);
    } else if (n5.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n5) ? -0 : 0;
      if (x2.e > -1)
        k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n5.s = 1;
      nIsOdd = isOdd(n5);
    } else {
      i4 = Math.abs(+valueOf(n5));
      nIsOdd = i4 % 2;
    }
    y4 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y4 = y4.times(x2);
        if (!y4.c)
          break;
        if (k2) {
          if (y4.c.length > k2)
            y4.c.length = k2;
        } else if (isModExp) {
          y4 = y4.mod(m4);
        }
      }
      if (i4) {
        i4 = mathfloor(i4 / 2);
        if (i4 === 0)
          break;
        nIsOdd = i4 % 2;
      } else {
        n5 = n5.times(half);
        round(n5, n5.e + 1, 1);
        if (n5.e > 14) {
          nIsOdd = isOdd(n5);
        } else {
          i4 = +valueOf(n5);
          if (i4 === 0)
            break;
          nIsOdd = i4 % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2)
          x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m4);
      }
    }
    if (isModExp)
      return y4;
    if (nIsNeg)
      y4 = ONE.div(y4);
    return m4 ? y4.mod(m4) : k2 ? round(y4, POW_PRECISION, ROUNDING_MODE, more) : y4;
  };
  P2.integerValue = function(rm) {
    var n5 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n5, n5.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y4, b4) {
    return compare(this, new BigNumber2(y4, b4)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y4, b4) {
    return compare(this, new BigNumber2(y4, b4)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y4, b4) {
    return (b4 = compare(this, new BigNumber2(y4, b4))) === 1 || b4 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y4, b4) {
    return compare(this, new BigNumber2(y4, b4)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y4, b4) {
    return (b4 = compare(this, new BigNumber2(y4, b4))) === -1 || b4 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y4, b4) {
    var i4, j2, t4, xLTy, x2 = this, a4 = x2.s;
    y4 = new BigNumber2(y4, b4);
    b4 = y4.s;
    if (!a4 || !b4)
      return new BigNumber2(NaN);
    if (a4 != b4) {
      y4.s = -b4;
      return x2.plus(y4);
    }
    var xe = x2.e / LOG_BASE, ye = y4.e / LOG_BASE, xc = x2.c, yc = y4.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y4.s = -b4, y4) : new BigNumber2(yc ? x2 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y4.s = -b4, y4) : new BigNumber2(xc[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a4 = xe - ye) {
      if (xLTy = a4 < 0) {
        a4 = -a4;
        t4 = xc;
      } else {
        ye = xe;
        t4 = yc;
      }
      t4.reverse();
      for (b4 = a4; b4--; t4.push(0))
        ;
      t4.reverse();
    } else {
      j2 = (xLTy = (a4 = xc.length) < (b4 = yc.length)) ? a4 : b4;
      for (a4 = b4 = 0; b4 < j2; b4++) {
        if (xc[b4] != yc[b4]) {
          xLTy = xc[b4] < yc[b4];
          break;
        }
      }
    }
    if (xLTy) {
      t4 = xc;
      xc = yc;
      yc = t4;
      y4.s = -y4.s;
    }
    b4 = (j2 = yc.length) - (i4 = xc.length);
    if (b4 > 0)
      for (; b4--; xc[i4++] = 0)
        ;
    b4 = BASE - 1;
    for (; j2 > a4; ) {
      if (xc[--j2] < yc[j2]) {
        for (i4 = j2; i4 && !xc[--i4]; xc[i4] = b4)
          ;
        --xc[i4];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y4.s = ROUNDING_MODE == 3 ? -1 : 1;
      y4.c = [y4.e = 0];
      return y4;
    }
    return normalise(y4, xc, ye);
  };
  P2.modulo = P2.mod = function(y4, b4) {
    var q2, s2, x2 = this;
    y4 = new BigNumber2(y4, b4);
    if (!x2.c || !y4.s || y4.c && !y4.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y4.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s2 = y4.s;
      y4.s = 1;
      q2 = div(x2, y4, 0, 3);
      y4.s = s2;
      q2.s *= s2;
    } else {
      q2 = div(x2, y4, 0, MODULO_MODE);
    }
    y4 = x2.minus(q2.times(y4));
    if (!y4.c[0] && MODULO_MODE == 1)
      y4.s = x2.s;
    return y4;
  };
  P2.multipliedBy = P2.times = function(y4, b4) {
    var c4, e6, i4, j2, k2, m4, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y4 = new BigNumber2(y4, b4)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x2.s || !y4.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y4.c = y4.e = y4.s = null;
      } else {
        y4.s *= x2.s;
        if (!xc || !yc) {
          y4.c = y4.e = null;
        } else {
          y4.c = [0];
          y4.e = 0;
        }
      }
      return y4;
    }
    e6 = bitFloor(x2.e / LOG_BASE) + bitFloor(y4.e / LOG_BASE);
    y4.s *= x2.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i4 = xcL;
      xcL = ycL;
      ycL = i4;
    }
    for (i4 = xcL + ycL, zc = []; i4--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i4 = ycL; --i4 >= 0; ) {
      c4 = 0;
      ylo = yc[i4] % sqrtBase;
      yhi = yc[i4] / sqrtBase | 0;
      for (k2 = xcL, j2 = i4 + k2; j2 > i4; ) {
        xlo = xc[--k2] % sqrtBase;
        xhi = xc[k2] / sqrtBase | 0;
        m4 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m4 % sqrtBase * sqrtBase + zc[j2] + c4;
        c4 = (xlo / base | 0) + (m4 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base;
      }
      zc[j2] = c4;
    }
    if (c4) {
      ++e6;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y4, zc, e6);
  };
  P2.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y4, b4) {
    var t4, x2 = this, a4 = x2.s;
    y4 = new BigNumber2(y4, b4);
    b4 = y4.s;
    if (!a4 || !b4)
      return new BigNumber2(NaN);
    if (a4 != b4) {
      y4.s = -b4;
      return x2.minus(y4);
    }
    var xe = x2.e / LOG_BASE, ye = y4.e / LOG_BASE, xc = x2.c, yc = y4.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a4 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y4 : new BigNumber2(xc[0] ? x2 : a4 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a4 = xe - ye) {
      if (a4 > 0) {
        ye = xe;
        t4 = yc;
      } else {
        a4 = -a4;
        t4 = xc;
      }
      t4.reverse();
      for (; a4--; t4.push(0))
        ;
      t4.reverse();
    }
    a4 = xc.length;
    b4 = yc.length;
    if (a4 - b4 < 0) {
      t4 = yc;
      yc = xc;
      xc = t4;
      b4 = a4;
    }
    for (a4 = 0; b4; ) {
      a4 = (xc[--b4] = xc[b4] + yc[b4] + a4) / BASE | 0;
      xc[b4] = BASE === xc[b4] ? 0 : xc[b4] % BASE;
    }
    if (a4) {
      xc = [a4].concat(xc);
      ++ye;
    }
    return normalise(y4, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c4, n5, v4, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), sd, rm);
    }
    if (!(c4 = x2.c))
      return null;
    v4 = c4.length - 1;
    n5 = v4 * LOG_BASE + 1;
    if (v4 = c4[v4]) {
      for (; v4 % 10 == 0; v4 /= 10, n5--)
        ;
      for (v4 = c4[0]; v4 >= 10; v4 /= 10, n5++)
        ;
    }
    if (sd && x2.e + 1 > n5)
      n5 = x2.e + 1;
    return n5;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m4, n5, r6, rep, t4, x2 = this, c4 = x2.c, s2 = x2.s, e6 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s2 !== 1 || !c4 || !c4[0]) {
      return new BigNumber2(!s2 || s2 < 0 && (!c4 || c4[0]) ? NaN : c4 ? x2 : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x2));
    if (s2 == 0 || s2 == 1 / 0) {
      n5 = coeffToString(c4);
      if ((n5.length + e6) % 2 == 0)
        n5 += "0";
      s2 = Math.sqrt(+n5);
      e6 = bitFloor((e6 + 1) / 2) - (e6 < 0 || e6 % 2);
      if (s2 == 1 / 0) {
        n5 = "5e" + e6;
      } else {
        n5 = s2.toExponential();
        n5 = n5.slice(0, n5.indexOf("e") + 1) + e6;
      }
      r6 = new BigNumber2(n5);
    } else {
      r6 = new BigNumber2(s2 + "");
    }
    if (r6.c[0]) {
      e6 = r6.e;
      s2 = e6 + dp;
      if (s2 < 3)
        s2 = 0;
      for (; ; ) {
        t4 = r6;
        r6 = half.times(t4.plus(div(x2, t4, dp, 1)));
        if (coeffToString(t4.c).slice(0, s2) === (n5 = coeffToString(r6.c)).slice(0, s2)) {
          if (r6.e < e6)
            --s2;
          n5 = n5.slice(s2 - 3, s2 + 1);
          if (n5 == "9999" || !rep && n5 == "4999") {
            if (!rep) {
              round(t4, t4.e + DECIMAL_PLACES + 2, 0);
              if (t4.times(t4).eq(x2)) {
                r6 = t4;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n5 || !+n5.slice(1) && n5.charAt(0) == "5") {
              round(r6, r6.e + DECIMAL_PLACES + 2, 1);
              m4 = !r6.times(r6).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r6, r6.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m4);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format4(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format4(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format5) {
    var str, x2 = this;
    if (format5 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format5 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format5 = dp;
        dp = rm = null;
      } else {
        format5 = FORMAT;
      }
    } else if (typeof format5 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format5);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i4, arr = str.split("."), g1 = +format5.groupSize, g22 = +format5.secondaryGroupSize, groupSeparator = format5.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22) {
        i4 = g1;
        g1 = g22;
        g22 = i4;
        len -= i4;
      }
      if (g1 > 0 && len > 0) {
        i4 = len % g1 || g1;
        intPart = intDigits.substr(0, i4);
        for (; i4 < len; i4 += g1)
          intPart += groupSeparator + intDigits.substr(i4, g1);
        if (g22 > 0)
          intPart += groupSeparator + intDigits.slice(i4);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format5.decimalSeparator || "") + ((g22 = +format5.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format5.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format5.prefix || "") + str + (format5.suffix || "");
  };
  P2.toFraction = function(md) {
    var d3, d0, d1, d22, e6, exp, n5, n0, n1, q2, r6, s2, x2 = this, xc = x2.c;
    if (md != null) {
      n5 = new BigNumber2(md);
      if (!n5.isInteger() && (n5.c || n5.s !== 1) || n5.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n5.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n5));
      }
    }
    if (!xc)
      return new BigNumber2(x2);
    d3 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s2 = coeffToString(xc);
    e6 = d3.e = s2.length - x2.e - 1;
    d3.c[0] = POWS_TEN[(exp = e6 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n5.comparedTo(d3) > 0 ? e6 > 0 ? d3 : n1 : n5;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n5 = new BigNumber2(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q2 = div(n5, d3, 0, 1);
      d22 = d0.plus(q2.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q2.times(d22 = n1));
      n0 = d22;
      d3 = n5.minus(q2.times(d22 = d3));
      n5 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e6 = e6 * 2;
    r6 = div(n1, d1, e6, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e6, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r6;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format4(this, sd, rm, 2);
  };
  P2.toString = function(b4) {
    var str, n5 = this, s2 = n5.s, e6 = n5.e;
    if (e6 === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b4 == null) {
        str = e6 <= TO_EXP_NEG || e6 >= TO_EXP_POS ? toExponential(coeffToString(n5.c), e6) : toFixedPoint(coeffToString(n5.c), e6, "0");
      } else if (b4 === 10 && alphabetHasNormalDecimalDigits) {
        n5 = round(new BigNumber2(n5), DECIMAL_PLACES + e6 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n5.c), n5.e, "0");
      } else {
        intCheck(b4, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n5.c), e6, "0"), 10, b4, s2, true);
      }
      if (s2 < 0 && n5.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n5) {
  var i4 = n5 | 0;
  return n5 > 0 || n5 === i4 ? i4 : i4 - 1;
}
function coeffToString(a4) {
  var s2, z2, i4 = 1, j2 = a4.length, r6 = a4[0] + "";
  for (; i4 < j2; ) {
    s2 = a4[i4++] + "";
    z2 = LOG_BASE - s2.length;
    for (; z2--; s2 = "0" + s2)
      ;
    r6 += s2;
  }
  for (j2 = r6.length; r6.charCodeAt(--j2) === 48; )
    ;
  return r6.slice(0, j2 + 1 || 1);
}
function compare(x2, y4) {
  var a4, b4, xc = x2.c, yc = y4.c, i4 = x2.s, j2 = y4.s, k2 = x2.e, l4 = y4.e;
  if (!i4 || !j2)
    return null;
  a4 = xc && !xc[0];
  b4 = yc && !yc[0];
  if (a4 || b4)
    return a4 ? b4 ? 0 : -j2 : i4;
  if (i4 != j2)
    return i4;
  a4 = i4 < 0;
  b4 = k2 == l4;
  if (!xc || !yc)
    return b4 ? 0 : !xc ^ a4 ? 1 : -1;
  if (!b4)
    return k2 > l4 ^ a4 ? 1 : -1;
  j2 = (k2 = xc.length) < (l4 = yc.length) ? k2 : l4;
  for (i4 = 0; i4 < j2; i4++)
    if (xc[i4] != yc[i4])
      return xc[i4] > yc[i4] ^ a4 ? 1 : -1;
  return k2 == l4 ? 0 : k2 > l4 ^ a4 ? 1 : -1;
}
function intCheck(n5, min2, max2, name) {
  if (n5 < min2 || n5 > max2 || n5 !== mathfloor(n5)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n5 == "number" ? n5 < min2 || n5 > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n5));
  }
}
function isOdd(n5) {
  var k2 = n5.c.length - 1;
  return bitFloor(n5.e / LOG_BASE) == k2 && n5.c[k2] % 2 != 0;
}
function toExponential(str, e6) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e6 < 0 ? "e" : "e+") + e6;
}
function toFixedPoint(str, e6, z2) {
  var len, zs;
  if (e6 < 0) {
    for (zs = z2 + "."; ++e6; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e6 > len) {
      for (zs = z2, e6 -= len; --e6; zs += z2)
        ;
      str += zs;
    } else if (e6 < len) {
      str = str.slice(0, e6) + "." + str.slice(e6);
    }
  }
  return str;
}
var BigNumber = clone();

// node_modules/.pnpm/@toruslabs+base-controllers@2.9.0_@babel+runtime@7.23.8_@sentry+types@7.92.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js
var import_loglevel2 = __toESM(require_loglevel());

// node_modules/.pnpm/@toruslabs+http-helpers@3.4.0_@babel+runtime@7.23.8_@sentry+types@7.92.0/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js
var import_lodash = __toESM(require_lodash());
var import_loglevel = __toESM(require_loglevel());
var log2 = import_loglevel.default.getLogger("http-helpers");
log2.setLevel(import_loglevel.levels.INFO);
var apiKey = "torus-default";
function setAPIKey(apiKey_) {
  apiKey = apiKey_;
}

// node_modules/.pnpm/@toruslabs+base-controllers@2.9.0_@babel+runtime@7.23.8_@sentry+types@7.92.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js
var import_bowser = __toESM(require_es5());
var import_lodash2 = __toESM(require_lodash2());
var createRandomId = (0, import_json_rpc_random_id.default)();
var COMMUNICATION_NOTIFICATIONS = {
  IFRAME_STATUS: "iframe_status",
  // Tell embed to create the window
  CREATE_WINDOW: "create_window",
  // Tell embed to close the window
  CLOSE_WINDOW: "close_window",
  USER_LOGGED_IN: "user_logged_in",
  USER_LOGGED_OUT: "user_logged_out"
};
var COMMUNICATION_JRPC_METHODS = {
  LOGOUT: "logout",
  WALLET_INSTANCE_ID: "wallet_instance_id",
  USER_INFO: "user_info",
  SET_PROVIDER: "set_provider",
  TOPUP: "topup",
  IFRAME_STATUS: "iframe_status",
  // embed has opened the window as requested
  OPENED_WINDOW: "opened_window",
  // user has closed the window from embed's side
  CLOSED_WINDOW: "closed_window",
  GET_PROVIDER_STATE: "get_provider_state",
  LOGIN_WITH_PRIVATE_KEY: "login_with_private_key"
};
var PROVIDER_JRPC_METHODS = {
  GET_PROVIDER_STATE: "wallet_get_provider_state"
};
var PROVIDER_NOTIFICATIONS = {
  ACCOUNTS_CHANGED: "wallet_accounts_changed",
  CHAIN_CHANGED: "wallet_chain_changed",
  UNLOCK_STATE_CHANGED: "wallet_unlock_state_changed"
};
var LOGIN_PROVIDER = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  EMAIL_PASSWORDLESS: "email_passwordless"
};
function createLoggerMiddleware(options) {
  return function loggerMiddleware(request4, response, next) {
    next((callback) => {
      if (response.error) {
        import_loglevel2.default.warn("Error in RPC response:\n", response);
      }
      if (request4.isTorusInternal)
        return;
      import_loglevel2.default.info(`RPC (${options.origin}):`, request4, "->", response);
      callback();
    });
  };
}
var ACCOUNT_CATEGORY = {
  NORMAL: "normal",
  THRESHOLD: "threshold",
  IMPORTED: "imported"
};
var DEFAULT_INTERVAL = 180 * 1e3;
var DEFAULT_PREFERENCES = {
  selectedCurrency: "USD",
  theme: "dark",
  locale: "en-US",
  accountType: ACCOUNT_CATEGORY.NORMAL,
  contacts: [],
  jwtToken: "",
  fetchedPastTx: [],
  pastTransactions: [],
  paymentTx: [],
  defaultPublicAddress: "",
  customTokens: [],
  customNfts: [],
  crashReport: true,
  userInfo: {
    aggregateVerifier: "",
    email: "",
    name: "",
    profileImage: "",
    typeOfLogin: LOGIN_PROVIDER.GOOGLE,
    verifier: "",
    verifierId: ""
  }
};
var TransactionStatus;
(function(TransactionStatus2) {
  TransactionStatus2["approved"] = "approved";
  TransactionStatus2["cancelled"] = "cancelled";
  TransactionStatus2["confirmed"] = "confirmed";
  TransactionStatus2["failed"] = "failed";
  TransactionStatus2["finalized"] = "finalized";
  TransactionStatus2["processed"] = "processed";
  TransactionStatus2["rejected"] = "rejected";
  TransactionStatus2["signed"] = "signed";
  TransactionStatus2["submitted"] = "submitted";
  TransactionStatus2["unapproved"] = "unapproved";
  TransactionStatus2["dropped"] = "dropped";
  TransactionStatus2["expired"] = "expired";
})(TransactionStatus || (TransactionStatus = {}));

// node_modules/.pnpm/@toruslabs+openlogin-jrpc@3.2.0_@babel+runtime@7.23.8/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
var import_readable_stream2 = __toESM(require_readable_browser());

// node_modules/.pnpm/@toruslabs+openlogin-utils@3.0.0_@babel+runtime@7.23.8/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_randombytes = __toESM(require_browser6());
var import_base64url = __toESM(require_base64url2());
var import_keccak = __toESM(require_js());
var randomId = () => (0, import_randombytes.default)(32).toString("hex");

// node_modules/.pnpm/@toruslabs+openlogin-jrpc@3.2.0_@babel+runtime@7.23.8/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js
init_events2();
var import_fast_safe_stringify2 = __toESM(require_fast_safe_stringify());
var import_eth_rpc_errors2 = __toESM(require_dist3());
var import_end_of_stream2 = __toESM(require_end_of_stream2());
var import_once2 = __toESM(require_once());
var import_pump2 = __toESM(require_pump());
function noop() {
  return void 0;
}
var SYN = "SYN";
var ACK = "ACK";
var BRK = "BRK";
var BasePostMessageStream = class extends import_readable_stream2.Duplex {
  constructor(_ref) {
    let {
      name,
      target,
      targetWindow = window,
      targetOrigin = "*"
    } = _ref;
    super({
      objectMode: true
    });
    _defineProperty(this, "_init", void 0);
    _defineProperty(this, "_haveSyn", void 0);
    _defineProperty(this, "_name", void 0);
    _defineProperty(this, "_target", void 0);
    _defineProperty(this, "_targetWindow", void 0);
    _defineProperty(this, "_targetOrigin", void 0);
    _defineProperty(this, "_onMessage", void 0);
    _defineProperty(this, "_synIntervalId", void 0);
    if (!name || !target) {
      throw new Error("Invalid input.");
    }
    this._init = false;
    this._haveSyn = false;
    this._name = name;
    this._target = target;
    this._targetWindow = targetWindow;
    this._targetOrigin = targetOrigin;
    this._onMessage = this.onMessage.bind(this);
    this._synIntervalId = null;
    window.addEventListener("message", this._onMessage, false);
    this._handShake();
  }
  _break() {
    this.cork();
    this._write(BRK, null, noop);
    this._haveSyn = false;
    this._init = false;
  }
  _handShake() {
    this._write(SYN, null, noop);
    this.cork();
  }
  _onData(data) {
    if (!this._init) {
      if (data === SYN) {
        this._haveSyn = true;
        this._write(ACK, null, noop);
      } else if (data === ACK) {
        this._init = true;
        if (!this._haveSyn) {
          this._write(ACK, null, noop);
        }
        this.uncork();
      }
    } else if (data === BRK) {
      this._break();
    } else {
      try {
        this.push(data);
      } catch (err) {
        this.emit("error", err);
      }
    }
  }
  _postMessage(data) {
    const originConstraint = this._targetOrigin;
    this._targetWindow.postMessage({
      target: this._target,
      data
    }, originConstraint);
  }
  onMessage(event) {
    const message = event.data;
    if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== "object" || message.target !== this._name || !message.data) {
      return;
    }
    this._onData(message.data);
  }
  _read() {
    return void 0;
  }
  _write(data, _2, cb) {
    this._postMessage(data);
    cb();
  }
  _destroy() {
    window.removeEventListener("message", this._onMessage, false);
  }
};
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone(arr) {
  const n5 = arr.length;
  const copy = new Array(n5);
  for (let i4 = 0; i4 < n5; i4 += 1) {
    copy[i4] = arr[i4];
  }
  return copy;
}
var SafeEventEmitter2 = class extends EventEmitter {
  emit(type2) {
    let doError = type2 === "error";
    const events = this._events;
    if (events !== void 0) {
      doError = doError && events.error === void 0;
    } else if (!doError) {
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (doError) {
      let er;
      if (args.length > 0) {
        [er] = args;
      }
      if (er instanceof Error) {
        throw er;
      }
      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
      err.context = er;
      throw err;
    }
    const handler = events[type2];
    if (handler === void 0) {
      return false;
    }
    if (typeof handler === "function") {
      safeApply(handler, this, args);
    } else {
      const len = handler.length;
      const listeners = arrayClone(handler);
      for (let i4 = 0; i4 < len; i4 += 1) {
        safeApply(listeners[i4], this, args);
      }
    }
    return true;
  }
};
var SerializableError = class extends Error {
  constructor(_ref) {
    let {
      code,
      message,
      data
    } = _ref;
    if (!Number.isInteger(code)) {
      throw new Error("code must be an integer");
    }
    if (!message || typeof message !== "string") {
      throw new Error("message must be string");
    }
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "data", void 0);
    this.code = code;
    if (data !== void 0) {
      this.data = data;
    }
  }
  toString() {
    return (0, import_fast_safe_stringify2.default)({
      code: this.code,
      message: this.message,
      data: this.data,
      stack: this.stack
    });
  }
};
var getRpcPromiseCallback = function(resolve3, reject) {
  let unwrapResult = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return (error, response) => {
    if (error || response.error) {
      reject(error || response.error);
    } else if (!unwrapResult || Array.isArray(response)) {
      resolve3(response);
    } else {
      resolve3(response.result);
    }
  };
};
function createStreamMiddleware() {
  const idMap = {};
  function readNoop() {
    return false;
  }
  const events = new SafeEventEmitter2();
  function processResponse(res) {
    const context = idMap[res.id];
    if (!context) {
      throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
    }
    delete idMap[res.id];
    Object.assign(context.res, res);
    setTimeout(context.end);
  }
  function processNotification(res) {
    events.emit("notification", res);
  }
  function processMessage(res, _encoding, cb) {
    let err;
    try {
      const isNotification = !res.id;
      if (isNotification) {
        processNotification(res);
      } else {
        processResponse(res);
      }
    } catch (_err) {
      err = _err;
    }
    cb(err);
  }
  const stream = new import_readable_stream2.Duplex({
    objectMode: true,
    read: readNoop,
    write: processMessage
  });
  const middleware = (req, res, next, end) => {
    stream.push(req);
    idMap[req.id] = {
      req,
      res,
      next,
      end
    };
  };
  return {
    events,
    middleware,
    stream
  };
}
function createIdRemapMiddleware() {
  return (req, res, next, _end) => {
    const originalId = req.id;
    const newId = randomId();
    req.id = newId;
    res.id = newId;
    next((done) => {
      req.id = originalId;
      res.id = originalId;
      done();
    });
  };
}
function ownKeys$1(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var JRPCEngine2 = class extends SafeEventEmitter2 {
  constructor() {
    super();
    _defineProperty(this, "_middleware", void 0);
    this._middleware = [];
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(req, res, middlewareStack) {
    const returnHandlers = [];
    let error = null;
    let isComplete = false;
    for (const middleware of middlewareStack) {
      [error, isComplete] = await JRPCEngine2._runMiddleware(req, res, middleware, returnHandlers);
      if (isComplete) {
        break;
      }
    }
    return [error, isComplete, returnHandlers.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(req, res, middleware, returnHandlers) {
    return new Promise((resolve3) => {
      const end = (err) => {
        const error = err || res.error;
        if (error) {
          res.error = (0, import_eth_rpc_errors2.serializeError)(error);
        }
        resolve3([error, true]);
      };
      const next = (returnHandler) => {
        if (res.error) {
          end(res.error);
        } else {
          if (returnHandler) {
            if (typeof returnHandler !== "function") {
              end(new SerializableError({
                code: -32603,
                message: "JRPCEngine: 'next' return handlers must be functions"
              }));
            }
            returnHandlers.push(returnHandler);
          }
          resolve3([null, false]);
        }
      };
      try {
        middleware(req, res, next, end);
      } catch (error) {
        end(error);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(handlers) {
    for (const handler of handlers) {
      await new Promise((resolve3, reject) => {
        handler((err) => err ? reject(err) : resolve3());
      });
    }
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(req, res, isComplete) {
    if (!("result" in res) && !("error" in res)) {
      throw new SerializableError({
        code: -32603,
        message: "Response has no error or result for request"
      });
    }
    if (!isComplete) {
      throw new SerializableError({
        code: -32603,
        message: "Nothing ended request"
      });
    }
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(middleware) {
    this._middleware.push(middleware);
  }
  handle(req, cb) {
    if (cb && typeof cb !== "function") {
      throw new Error('"callback" must be a function if provided.');
    }
    if (Array.isArray(req)) {
      if (cb) {
        return this._handleBatch(req, cb);
      }
      return this._handleBatch(req);
    }
    if (cb) {
      return this._handle(req, cb);
    }
    return this._promiseHandle(req);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (req, res, next, end) => {
      try {
        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine2._runAllMiddleware(req, res, this._middleware);
        if (isComplete) {
          await JRPCEngine2._runReturnHandlers(returnHandlers);
          return end(middlewareError);
        }
        return next(async (handlerCallback) => {
          try {
            await JRPCEngine2._runReturnHandlers(returnHandlers);
          } catch (error) {
            return handlerCallback(error);
          }
          return handlerCallback();
        });
      } catch (error) {
        return end(error);
      }
    };
  }
  async _handleBatch(reqs, cb) {
    try {
      const responses = await Promise.all(
        // 1. Begin executing each request in the order received
        reqs.map(this._promiseHandle.bind(this))
      );
      if (cb) {
        return cb(null, responses);
      }
      return responses;
    } catch (error) {
      if (cb) {
        return cb(error);
      }
      throw error;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(req) {
    return new Promise((resolve3) => {
      this._handle(req, (_err, res) => {
        resolve3(res);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(callerReq, cb) {
    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
      const error2 = new SerializableError({
        code: -32603,
        message: "request must be plain object"
      });
      return cb(error2, {
        id: void 0,
        jsonrpc: "2.0",
        error: error2
      });
    }
    if (typeof callerReq.method !== "string") {
      const error2 = new SerializableError({
        code: -32603,
        message: "method must be string"
      });
      return cb(error2, {
        id: callerReq.id,
        jsonrpc: "2.0",
        error: error2
      });
    }
    const req = _objectSpread$1({}, callerReq);
    const res = {
      id: req.id,
      jsonrpc: req.jsonrpc
    };
    let error = null;
    try {
      await this._processRequest(req, res);
    } catch (_error) {
      error = _error;
    }
    if (error) {
      delete res.result;
      if (!res.error) {
        res.error = (0, import_eth_rpc_errors2.serializeError)(error);
      }
    }
    return cb(error, res);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(req, res) {
    const [error, isComplete, returnHandlers] = await JRPCEngine2._runAllMiddleware(req, res, this._middleware);
    JRPCEngine2._checkForCompletion(req, res, isComplete);
    await JRPCEngine2._runReturnHandlers(returnHandlers);
    if (error) {
      throw error;
    }
  }
};
var Substream = class extends import_readable_stream2.Duplex {
  constructor(_ref) {
    let {
      parent,
      name
    } = _ref;
    super({
      objectMode: true
    });
    _defineProperty(this, "_parent", void 0);
    _defineProperty(this, "_name", void 0);
    this._parent = parent;
    this._name = name;
  }
  /**
   * Explicitly sets read operations to a no-op.
   */
  _read() {
    return void 0;
  }
  /**
   * Called when data should be written to this writable stream.
   *
   * @param chunk - Arbitrary object to write
   * @param encoding - Encoding to use when writing payload
   * @param callback - Called when writing is complete or an error occurs
   */
  _write(chunk, _encoding, callback) {
    this._parent.push({
      name: this._name,
      data: chunk
    });
    callback();
  }
};
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var IGNORE_SUBSTREAM2 = Symbol("IGNORE_SUBSTREAM");
var ObjectMultiplex = class extends import_readable_stream2.Duplex {
  constructor() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(_objectSpread(_objectSpread({}, opts), {}, {
      objectMode: true
    }));
    _defineProperty(this, "_substreams", void 0);
    _defineProperty(this, "getStream", void 0);
    this._substreams = {};
  }
  createStream(name) {
    if (!name) {
      throw new Error("ObjectMultiplex - name must not be empty");
    }
    if (this._substreams[name]) {
      throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
    }
    const substream = new Substream({
      parent: this,
      name
    });
    this._substreams[name] = substream;
    anyStreamEnd(this, (_error) => substream.destroy(_error || void 0));
    return substream;
  }
  // ignore streams (dont display orphaned data warning)
  ignoreStream(name) {
    if (!name) {
      throw new Error("ObjectMultiplex - name must not be empty");
    }
    if (this._substreams[name]) {
      throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
    }
    this._substreams[name] = IGNORE_SUBSTREAM2;
  }
  _read() {
    return void 0;
  }
  _write(chunk, _encoding, callback) {
    const {
      name,
      data
    } = chunk;
    if (!name) {
      window.console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
      return callback();
    }
    const substream = this._substreams[name];
    if (!substream) {
      window.console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
      return callback();
    }
    if (substream !== IGNORE_SUBSTREAM2) {
      substream.push(data);
    }
    return callback();
  }
};
function anyStreamEnd(stream, _cb) {
  const cb = (0, import_once2.default)(_cb);
  (0, import_end_of_stream2.default)(stream, {
    readable: false
  }, cb);
  (0, import_end_of_stream2.default)(stream, {
    writable: false
  }, cb);
}

// node_modules/.pnpm/@toruslabs+solana-embed@0.3.4_@babel+runtime@7.23.8_@sentry+types@7.92.0_bufferutil@4.0.9_enc_b7hvoxl7mypogoedcaiqvxlhja/node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js
var import_eth_rpc_errors3 = __toESM(require_dist3());
var import_is_stream = __toESM(require_is_stream());
var import_pump3 = __toESM(require_pump());
var import_loglevel3 = __toESM(require_loglevel());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var version = "0.3.4";
var messages = {
  errors: {
    disconnected: () => "Torus: Lost connection to Torus.",
    permanentlyDisconnected: () => "Torus: Disconnected from iframe. Page reload required.",
    unsupportedSync: (method) => `Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidOptions: (maxEventListeners) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
    invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`
  },
  info: {
    connected: (chainId) => `Torus: Connected to chain with ID "${chainId}".`
  },
  warnings: {}
};
var PAYMENT_PROVIDER = {
  MOONPAY: "moonpay",
  WYRE: "wyre",
  RAMPNETWORK: "rampnetwork",
  XANPOOL: "xanpool",
  MERCURYO: "mercuryo",
  TRANSAK: "transak"
};
var TORUS_BUILD_ENV = {
  PRODUCTION: "production",
  DEVELOPMENT: "development",
  TESTING: "testing"
};
var BUTTON_POSITION = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
};
var LOGIN_PROVIDER2 = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  LINE: "line",
  GITHUB: "github",
  KAKAO: "kakao",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  WECHAT: "wechat",
  EMAIL_PASSWORDLESS: "email_passwordless"
};
var translations = {
  en: {
    embed: {
      continue: "Continue",
      actionRequired: "Authorization required",
      pendingAction: "Click continue to proceed with your request in a popup",
      cookiesRequired: "Cookies Required",
      enableCookies: "Please enable cookies in your browser preferences to access Torus",
      clickHere: "More Info"
    }
  },
  de: {
    embed: {
      continue: "Fortsetzen",
      actionRequired: "Autorisierung erforderlich",
      pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
      cookiesRequired: "Cookies ben\xF6tigt",
      enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
      clickHere: "Mehr Info"
    }
  },
  ja: {
    embed: {
      continue: "\u7D99\u7D9A\u3059\u308B",
      actionRequired: "\u8A8D\u8A3C\u304C\u5FC5\u8981\u3067\u3059",
      pendingAction: "\u7D9A\u884C\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u3001\u30DD\u30C3\u30D7\u30A2\u30C3\u30D7\u3067\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u7D9A\u884C\u3057\u307E\u3059",
      cookiesRequired: "\u5FC5\u8981\u306A\u30AF\u30C3\u30AD\u30FC",
      enableCookies: "Torus\u306B\u30A2\u30AF\u30BB\u30B9\u3059\u308B\u306B\u306F\u3001\u30D6\u30E9\u30A6\u30B6\u306E\u8A2D\u5B9A\u3067Cookie\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      clickHere: "\u8A73\u3057\u304F\u306F"
    }
  },
  ko: {
    embed: {
      continue: "\uACC4\uC18D\uD558\uB2E4",
      actionRequired: "\uC2B9\uC778 \uD544\uC694",
      pendingAction: "\uD31D\uC5C5\uC5D0\uC11C \uC694\uCCAD\uC744 \uC9C4\uD589\uD558\uB824\uBA74 \uACC4\uC18D\uC744 \uD074\uB9AD\uD558\uC2ED\uC2DC\uC624.",
      cookiesRequired: "\uCFE0\uD0A4 \uD544\uC694",
      enableCookies: "\uBE0C\uB77C\uC6B0\uC800 \uD658\uACBD \uC124\uC815\uC5D0\uC11C \uCFE0\uD0A4\uB97C \uD65C\uC131\uD654\uD558\uC5EC Torus\uC5D0 \uC561\uC138\uC2A4\uD558\uC2ED\uC2DC\uC624.",
      clickHere: "\uB354 \uB9CE\uC740 \uC815\uBCF4"
    }
  },
  zh: {
    embed: {
      continue: "\u7EE7\u7EED",
      actionRequired: "\u9700\u8981\u6388\u6743",
      pendingAction: "\u5355\u51FB\u7EE7\u7EED\u4EE5\u5728\u5F39\u51FA\u7A97\u53E3\u4E2D\u7EE7\u7EED\u60A8\u7684\u8BF7\u6C42",
      cookiesRequired: "\u5FC5\u586BCookie",
      enableCookies: "\u8BF7\u5728\u60A8\u7684\u6D4F\u89C8\u5668\u9996\u9009\u9879\u4E2D\u542F\u7528cookie\u4EE5\u8BBF\u95EETorus\u3002",
      clickHere: "\u66F4\u591A\u4FE1\u606F"
    }
  }
};
var configuration = {
  supportedVerifierList: [LOGIN_PROVIDER2.GOOGLE, LOGIN_PROVIDER2.REDDIT, LOGIN_PROVIDER2.DISCORD],
  api: "https://api.tor.us",
  translations,
  prodTorusUrl: "",
  localStorageKeyPrefix: `torus-`
};
var log4 = import_loglevel3.default.getLogger("solana-embed");
function createErrorMiddleware() {
  return (req, res, next) => {
    if (typeof req.method !== "string" || !req.method) {
      res.error = import_eth_rpc_errors3.ethErrors.rpc.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: req
      });
    }
    next((done) => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      log4.error(`Torus - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Torus: Lost connection to "${remoteLabel}".`;
  if (error?.stack) {
    warningMsg += `
${error.stack}`;
  }
  log4.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
var getWindowId = () => Math.random().toString(36).slice(2);
var getTorusUrl = async (buildEnv) => {
  let torusUrl;
  let logLevel2;
  switch (buildEnv) {
    case "testing":
      torusUrl = "https://solana-testing.tor.us";
      logLevel2 = "debug";
      break;
    case "development":
      torusUrl = "http://localhost:8080";
      logLevel2 = "debug";
      break;
    default:
      torusUrl = `https://solana.tor.us`;
      logLevel2 = "error";
      break;
  }
  return {
    torusUrl,
    logLevel: logLevel2
  };
};
var getUserLanguage = () => {
  let userLanguage = window.navigator.language || "en-US";
  const userLanguages = userLanguage.split("-");
  userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : "en";
  return userLanguage;
};
var FEATURES_PROVIDER_CHANGE_WINDOW = {
  height: 660,
  width: 375
};
var FEATURES_DEFAULT_WALLET_WINDOW = {
  height: 740,
  width: 1315
};
var FEATURES_DEFAULT_POPUP_WINDOW = {
  height: 700,
  width: 1200
};
var FEATURES_CONFIRM_WINDOW = {
  height: 600,
  width: 400
};
function storageAvailable(type2) {
  let storage;
  try {
    storage = window[type2];
    const x2 = "__storage_test__";
    storage.setItem(x2, x2);
    storage.removeItem(x2);
    return true;
  } catch (e6) {
    return e6 && // everything except Firefox
    (e6.code === 22 || // Firefox
    e6.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e6.name === "QuotaExceededError" || // Firefox
    e6.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
function getPopupFeatures(_ref) {
  let {
    width: w2,
    height: h5
  } = _ref;
  const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1;
  const left = Math.abs((width - w2) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h5) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h5 / systemZoom},width=${w2 / systemZoom},top=${top},left=${left}`;
  return features;
}
var BaseProvider = class extends SafeEventEmitter2 {
  /**
   * Indicating that this provider is a Torus provider.
   */
  constructor(connectionStream, _ref) {
    let {
      maxEventListeners = 100,
      jsonRpcStreamName = "provider"
    } = _ref;
    super();
    _defineProperty(this, "isTorus", void 0);
    _defineProperty(this, "_rpcEngine", void 0);
    _defineProperty(this, "jsonRpcConnectionEvents", void 0);
    _defineProperty(this, "_state", void 0);
    if (!(0, import_is_stream.duplex)(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }
    this.isTorus = true;
    this.setMaxListeners(maxEventListeners);
    this._handleConnect = this._handleConnect.bind(this);
    this._handleDisconnect = this._handleDisconnect.bind(this);
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    this._rpcRequest = this._rpcRequest.bind(this);
    this._initializeState = this._initializeState.bind(this);
    this.request = this.request.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    const mux = new ObjectMultiplex();
    (0, import_pump3.default)(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, "Torus"));
    mux.ignoreStream("phishing");
    const jsonRpcConnection = createStreamMiddleware();
    (0, import_pump3.default)(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "Torus RpcProvider"));
    const rpcEngine = new JRPCEngine2();
    rpcEngine.push(createIdRemapMiddleware());
    rpcEngine.push(createErrorMiddleware());
    rpcEngine.push(createLoggerMiddleware({
      origin: location.origin
    }));
    rpcEngine.push(jsonRpcConnection.middleware);
    this._rpcEngine = rpcEngine;
    this.jsonRpcConnectionEvents = jsonRpcConnection.events;
  }
  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   */
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw import_eth_rpc_errors3.ethErrors.rpc.invalidRequest({
        message: messages.errors.invalidRequestArgs(),
        data: args
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw import_eth_rpc_errors3.ethErrors.rpc.invalidRequest({
        message: messages.errors.invalidRequestMethod(),
        data: args
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw import_eth_rpc_errors3.ethErrors.rpc.invalidRequest({
        message: messages.errors.invalidRequestParams(),
        data: args
      });
    }
    return new Promise((resolve3, reject) => {
      this._rpcRequest({
        method,
        params
      }, getRpcPromiseCallback(resolve3, reject));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   */
  send(payload, callback) {
    this._rpcRequest(payload, callback);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   */
  sendAsync(payload) {
    return new Promise((resolve3, reject) => {
      this._rpcRequest(payload, getRpcPromiseCallback(resolve3, reject));
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * emits TorusInpageProvider#disconnect
   */
  _handleStreamDisconnect(streamName, error) {
    logStreamDisconnectWarning(streamName, error, this);
    this._handleDisconnect(false, error ? error.message : void 0);
  }
};
var handleEvent = function(handle, eventName, handler) {
  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    handlerArgs[_key - 3] = arguments[_key];
  }
  const handlerWrapper = () => {
    handler(...handlerArgs);
    handle.removeEventListener(eventName, handlerWrapper);
  };
  handle.addEventListener(eventName, handlerWrapper);
};
async function documentReady() {
  return new Promise((resolve3) => {
    if (document.readyState !== "loading") {
      resolve3();
    } else {
      handleEvent(document, "DOMContentLoaded", resolve3);
    }
  });
}
var htmlToElement = (html) => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim();
  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
function isLegacyTransactionInstance(transaction) {
  return transaction.version === void 0;
}
var PopupHandler = class extends SafeEventEmitter2 {
  constructor(_ref) {
    let {
      url,
      target,
      features
    } = _ref;
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
    this.window = void 0;
    this.windowTimer = void 0;
    this.iClosedWindow = false;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        if (!this.iClosedWindow) {
          this.emit("close");
        }
        this.iClosedWindow = false;
        this.window = void 0;
      }
      if (this.window === void 0)
        clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    this.window = window.open(this.url.href, this.target, this.features);
    if (this.window?.focus)
      this.window.focus();
    return Promise.resolve();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window)
      this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
};
function ownKeys$2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var TorusCommunicationProvider = class extends BaseProvider {
  constructor(connectionStream, _ref) {
    let {
      maxEventListeners = 100,
      jsonRpcStreamName = "provider"
    } = _ref;
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "embedTranslations", void 0);
    _defineProperty(this, "torusUrl", void 0);
    _defineProperty(this, "dappStorageKey", void 0);
    _defineProperty(this, "windowRefs", void 0);
    _defineProperty(this, "tryWindowHandle", void 0);
    _defineProperty(this, "torusAlertContainer", void 0);
    _defineProperty(this, "torusIframe", void 0);
    this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState);
    this.torusUrl = "";
    this.dappStorageKey = "";
    const languageTranslations = configuration.translations[getUserLanguage()];
    this.embedTranslations = languageTranslations.embed;
    this.windowRefs = {};
    this.on("connect", () => {
      this._state.isConnected = true;
    });
    const notificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
        const {
          isFullScreen,
          rid
        } = params;
        this._displayIframe({
          isFull: isFullScreen,
          rid
        });
      } else if (method === COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {
        const {
          windowId,
          url
        } = params;
        this._createPopupBlockAlert(windowId, url);
      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
        this._handleCloseWindow(params);
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
        const {
          currentLoginProvider
        } = params;
        this._state.isLoggedIn = true;
        this._state.currentLoginProvider = currentLoginProvider;
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
        this._state.isLoggedIn = false;
        this._state.currentLoginProvider = null;
        this._displayIframe();
      }
    };
    this.jsonRpcConnectionEvents.on("notification", notificationHandler);
  }
  get isLoggedIn() {
    return this._state.isLoggedIn;
  }
  get isIFrameFullScreen() {
    return this._state.isIFrameFullScreen;
  }
  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected() {
    return this._state.isConnected;
  }
  async _initializeState(params) {
    try {
      const {
        torusUrl,
        dappStorageKey,
        torusAlertContainer,
        torusIframe
      } = params;
      this.torusUrl = torusUrl;
      this.dappStorageKey = dappStorageKey;
      this.torusAlertContainer = torusAlertContainer;
      this.torusIframe = torusIframe;
      this.torusIframe.addEventListener("load", () => {
        if (!this._state.isIFrameFullScreen)
          this._displayIframe();
      });
      const {
        currentLoginProvider,
        isLoggedIn
      } = await this.request({
        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      this._handleConnect(currentLoginProvider, isLoggedIn);
    } catch (error) {
      log4.error("Torus: Failed to get initial state. Please report this bug.", error);
    } finally {
      log4.info("initialized communication state");
      this._state.initialized = true;
      this.emit("_initialized");
    }
  }
  _handleWindow(windowId) {
    let {
      url,
      target,
      features
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);
    if (this.dappStorageKey) {
      if (finalUrl.hash)
        finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;
      else
        finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
    }
    const handledWindow = new PopupHandler({
      url: finalUrl,
      target,
      features
    });
    handledWindow.open();
    if (!handledWindow.window) {
      this._createPopupBlockAlert(windowId, finalUrl.href);
      return;
    }
    this.windowRefs[windowId] = handledWindow;
    this.request({
      method: COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,
      params: {
        windowId
      }
    });
    handledWindow.once("close", () => {
      delete this.windowRefs[windowId];
      this.request({
        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
        params: {
          windowId
        }
      });
    });
  }
  _displayIframe() {
    let {
      isFull = false,
      rid = ""
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const style = {};
    if (!isFull) {
      style.display = this._state.torusWidgetVisibility ? "block" : "none";
      style.height = "70px";
      style.width = "70px";
      switch (this._state.buttonPosition) {
        case BUTTON_POSITION.TOP_LEFT:
          style.top = "0px";
          style.left = "0px";
          style.right = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.TOP_RIGHT:
          style.top = "0px";
          style.right = "0px";
          style.left = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_RIGHT:
          style.bottom = "0px";
          style.right = "0px";
          style.top = "auto";
          style.left = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_LEFT:
        default:
          style.bottom = "0px";
          style.left = "0px";
          style.top = "auto";
          style.right = "auto";
          break;
      }
    } else {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      style.top = "0px";
      style.right = "0px";
      style.left = "0px";
      style.bottom = "0px";
    }
    Object.assign(this.torusIframe.style, style);
    this._state.isIFrameFullScreen = isFull;
    this.request({
      method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
      params: {
        isIFrameFullScreen: isFull,
        rid
      }
    });
  }
  hideTorusButton() {
    this._state.torusWidgetVisibility = false;
    this._displayIframe();
  }
  showTorusButton() {
    this._state.torusWidgetVisibility = true;
    this._displayIframe();
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  _rpcRequest(payload, callback) {
    const cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
    }
    this.tryWindowHandle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  _handleConnect(currentLoginProvider, isLoggedIn) {
    if (!this._state.isConnected) {
      this._state.isConnected = true;
      this.emit("connect", {
        currentLoginProvider,
        isLoggedIn
      });
      log4.debug(messages.info.connected(currentLoginProvider));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  _handleDisconnect(isRecoverable, errorMessage) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
      this._state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new import_eth_rpc_errors3.EthereumRpcError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log4.debug(error);
      } else {
        error = new import_eth_rpc_errors3.EthereumRpcError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log4.error(error);
        this._state.currentLoginProvider = null;
        this._state.isLoggedIn = false;
        this._state.torusWidgetVisibility = false;
        this._state.isIFrameFullScreen = false;
        this._state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  // Called if the iframe wants to close the window cause it is done processing the request
  _handleCloseWindow(params) {
    const {
      windowId
    } = params;
    if (this.windowRefs[windowId]) {
      this.windowRefs[windowId].close();
      delete this.windowRefs[windowId];
    }
  }
  async _createPopupBlockAlert(windowId, url) {
    const logoUrl = this.getLogoUrl();
    const torusAlert = htmlToElement(`<div id="torusAlert" class="torus-alert--v2"><div id="torusAlert__logo"><img src="${logoUrl}" /></div><div><h1 id="torusAlert__title">${this.embedTranslations.actionRequired}</h1><p id="torusAlert__desc">${this.embedTranslations.pendingAction}</p></div></div>`);
    const successAlert = htmlToElement(`<div><a id="torusAlert__btn">${this.embedTranslations.continue}</a></div>`);
    const btnContainer = htmlToElement('<div id="torusAlert__btn-container"></div>');
    btnContainer.appendChild(successAlert);
    torusAlert.appendChild(btnContainer);
    const bindOnLoad = () => {
      successAlert.addEventListener("click", () => {
        this._handleWindow(windowId, {
          url,
          target: "_blank",
          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
        });
        torusAlert.remove();
        if (this.torusAlertContainer.children.length === 0)
          this.torusAlertContainer.style.display = "none";
      });
    };
    const attachOnLoad = () => {
      this.torusAlertContainer.appendChild(torusAlert);
    };
    await documentReady();
    attachOnLoad();
    bindOnLoad();
    this.torusAlertContainer.style.display = "block";
  }
  getLogoUrl() {
    const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;
    return logoUrl;
  }
};
_defineProperty(TorusCommunicationProvider, "_defaultState", {
  buttonPosition: "bottom-left",
  currentLoginProvider: null,
  isIFrameFullScreen: false,
  hasEmittedConnection: false,
  torusWidgetVisibility: false,
  initialized: false,
  isLoggedIn: false,
  isPermanentlyDisconnected: false,
  isConnected: false
});
function ownKeys$12(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$12(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys$12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var TorusInPageProvider = class extends BaseProvider {
  /**
   * The chain ID of the currently connected Solana chain.
   * See [chainId.network]{@link https://chainid.network} for more information.
   */
  /**
   * The user's currently selected Solana address.
   * If null, Torus is either locked or the user has not permitted any
   * addresses to be viewed.
   */
  constructor(connectionStream, _ref) {
    let {
      maxEventListeners = 100,
      jsonRpcStreamName = "provider"
    } = _ref;
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "selectedAddress", void 0);
    _defineProperty(this, "tryWindowHandle", void 0);
    this._state = _objectSpread$12({}, TorusInPageProvider._defaultState);
    this.selectedAddress = null;
    this.chainId = null;
    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
    this._handleChainChanged = this._handleChainChanged.bind(this);
    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
    this.on("connect", () => {
      this._state.isConnected = true;
    });
    const jsonRpcNotificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {
        this._handleAccountsChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {
        this._handleUnlockStateChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {
        this._handleChainChanged(params);
      }
    };
    this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
  }
  /**
   * Returns whether the inpage provider is connected to Torus.
   */
  isConnected() {
    return this._state.isConnected;
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  async _initializeState() {
    try {
      const {
        accounts,
        chainId,
        isUnlocked
      } = await this.request({
        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      this.emit("connect", {
        chainId
      });
      this._handleChainChanged({
        chainId
      });
      this._handleUnlockStateChanged({
        accounts,
        isUnlocked
      });
      this._handleAccountsChanged(accounts);
    } catch (error) {
      log4.error("Torus: Failed to get initial state. Please report this bug.", error);
    } finally {
      log4.info("initialized provider state");
      this._state.initialized = true;
      this.emit("_initialized");
    }
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  _rpcRequest(payload, callback) {
    let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
      if (_payload.method === "solana_accounts" || _payload.method === "solana_requestAccounts") {
        cb = (err, res) => {
          this._handleAccountsChanged(res.result || [], _payload.method === "solana_accounts", isInternal);
          callback(err, res);
        };
      } else if (_payload.method === "wallet_getProviderState") {
        this._rpcEngine.handle(payload, cb);
        return;
      }
    }
    this.tryWindowHandle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */
  _handleConnect(chainId) {
    if (!this._state.isConnected) {
      this._state.isConnected = true;
      this.emit("connect", {
        chainId
      });
      log4.debug(messages.info.connected(chainId));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  _handleDisconnect(isRecoverable, errorMessage) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
      this._state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new import_eth_rpc_errors3.EthereumRpcError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log4.debug(error);
      } else {
        error = new import_eth_rpc_errors3.EthereumRpcError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log4.error(error);
        this.chainId = null;
        this._state.accounts = null;
        this.selectedAddress = null;
        this._state.isUnlocked = false;
        this._state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  /**
   * Called when accounts may have changed.
   */
  _handleAccountsChanged(accounts) {
    let isEthAccounts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let finalAccounts = accounts;
    if (!Array.isArray(finalAccounts)) {
      log4.error("Torus: Received non-array accounts parameter. Please report this bug.", finalAccounts);
      finalAccounts = [];
    }
    for (const account of accounts) {
      if (typeof account !== "string") {
        log4.error("Torus: Received non-string account. Please report this bug.", accounts);
        finalAccounts = [];
        break;
      }
    }
    if (!(0, import_fast_deep_equal.default)(this._state.accounts, finalAccounts)) {
      if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {
        log4.error('Torus: "solana_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
      }
      this._state.accounts = finalAccounts;
      this.emit("accountsChanged", finalAccounts);
    }
    if (this.selectedAddress !== finalAccounts[0]) {
      this.selectedAddress = finalAccounts[0] || null;
    }
  }
  /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */
  _handleChainChanged() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!chainId) {
      log4.error("Torus: Received invalid network parameters. Please report this bug.", {
        chainId
      });
      return;
    }
    if (chainId === "loading") {
      this._handleDisconnect(true);
    } else {
      this._handleConnect(chainId);
      if (chainId !== this.chainId) {
        this.chainId = chainId;
        if (this._state.initialized) {
          this.emit("chainChanged", this.chainId);
        }
      }
    }
  }
  /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */
  _handleUnlockStateChanged() {
    let {
      accounts,
      isUnlocked
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof isUnlocked !== "boolean") {
      log4.error("Torus: Received invalid isUnlocked parameter. Please report this bug.", {
        isUnlocked
      });
      return;
    }
    if (isUnlocked !== this._state.isUnlocked) {
      this._state.isUnlocked = isUnlocked;
      this._handleAccountsChanged(accounts || []);
    }
  }
};
_defineProperty(TorusInPageProvider, "_defaultState", {
  accounts: null,
  isConnected: false,
  isUnlocked: false,
  initialized: false,
  isPermanentlyDisconnected: false,
  hasEmittedConnection: false
});
function imgExists(url) {
  return new Promise((resolve3, reject) => {
    try {
      const img = document.createElement("img");
      img.onload = () => resolve3(true);
      img.onerror = () => resolve3(false);
      img.src = url;
    } catch (e6) {
      reject(e6);
    }
  });
}
var getSiteName = (window2) => {
  const {
    document: document2
  } = window2;
  const siteName = document2.querySelector('head > meta[property="og:site_name"]');
  if (siteName) {
    return siteName.content;
  }
  const metaTitle = document2.querySelector('head > meta[name="title"]');
  if (metaTitle) {
    return metaTitle.content;
  }
  if (document2.title && document2.title.length > 0) {
    return document2.title;
  }
  return window2.location.hostname;
};
async function getSiteIcon(window2) {
  try {
    const {
      document: document2
    } = window2;
    let icon = document2.querySelector('head > link[rel="shortcut icon"]');
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    icon = Array.from(document2.querySelectorAll('head > link[rel="icon"]')).find((_icon) => Boolean(_icon.href));
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    return "";
  } catch (error) {
    return "";
  }
}
var getSiteMetadata = async () => ({
  name: getSiteName(window),
  icon: await getSiteIcon(window)
});
function ownKeys2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var PROVIDER_UNSAFE_METHODS = ["send_transaction", "sign_transaction", "sign_all_transactions", "sign_message", "connect"];
var COMMUNICATION_UNSAFE_METHODS = [COMMUNICATION_JRPC_METHODS.SET_PROVIDER];
var isLocalStorageAvailable = storageAvailable("localStorage");
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined")
      return;
    const torusIframeHtml = document.createElement("link");
    const {
      torusUrl
    } = await getTorusUrl("production");
    torusIframeHtml.href = `${torusUrl}/frame`;
    torusIframeHtml.crossOrigin = "anonymous";
    torusIframeHtml.type = "text/html";
    torusIframeHtml.rel = "prefetch";
    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
      if (torusIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(torusIframeHtml);
      }
    }
  } catch (error) {
    log4.warn(error);
  }
})();
var Torus = class {
  constructor() {
    let {
      modalZIndex = 99999
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "torusAlert", void 0);
    _defineProperty(this, "modalZIndex", void 0);
    _defineProperty(this, "alertZIndex", void 0);
    _defineProperty(this, "requestedLoginProvider", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "communicationProvider", void 0);
    _defineProperty(this, "dappStorageKey", void 0);
    _defineProperty(this, "isTopupHidden", false);
    _defineProperty(this, "torusAlertContainer", void 0);
    _defineProperty(this, "torusUrl", void 0);
    _defineProperty(this, "torusIframe", void 0);
    _defineProperty(this, "styleLink", void 0);
    this.torusUrl = "";
    this.isInitialized = false;
    this.requestedLoginProvider = null;
    this.modalZIndex = modalZIndex;
    this.alertZIndex = modalZIndex + 1e3;
    this.dappStorageKey = "";
  }
  get isLoggedIn() {
    if (!this.communicationProvider)
      return false;
    return this.communicationProvider.isLoggedIn;
  }
  async init() {
    let {
      buildEnv = TORUS_BUILD_ENV.PRODUCTION,
      enableLogging = false,
      network,
      showTorusButton = false,
      useLocalStorage = false,
      buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,
      apiKey: apiKey2 = "torus-default",
      extraParams = {},
      whiteLabel
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.isInitialized)
      throw new Error("Already initialized");
    setAPIKey(apiKey2);
    const {
      torusUrl,
      logLevel: logLevel2
    } = await getTorusUrl(buildEnv);
    log4.enableAll();
    log4.info(torusUrl, "url loaded");
    log4.info(`Solana Embed Version :${version}`);
    this.torusUrl = torusUrl;
    log4.setDefaultLevel(logLevel2);
    if (enableLogging)
      log4.enableAll();
    else
      log4.disableAll();
    const dappStorageKey = this.handleDappStorageKey(useLocalStorage);
    const torusIframeUrl = new URL(torusUrl);
    if (torusIframeUrl.pathname.endsWith("/"))
      torusIframeUrl.pathname += "frame";
    else
      torusIframeUrl.pathname += "/frame";
    const hashParams = new URLSearchParams();
    if (dappStorageKey)
      hashParams.append("dappStorageKey", dappStorageKey);
    hashParams.append("origin", window.location.origin);
    torusIframeUrl.hash = hashParams.toString();
    this.torusIframe = htmlToElement(`<iframe
        id="torusIframe"
        class="torusIframe"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}"
      ></iframe>`);
    this.torusAlertContainer = htmlToElement(`<div id="torusAlertContainer" style="display:none; z-index: ${this.alertZIndex.toString()}"></div>`);
    this.styleLink = htmlToElement(`<link href="${torusUrl}/css/widget.css" rel="stylesheet" type="text/css">`);
    const handleSetup = async () => {
      return new Promise((resolve3, reject) => {
        try {
          window.document.head.appendChild(this.styleLink);
          window.document.body.appendChild(this.torusIframe);
          window.document.body.appendChild(this.torusAlertContainer);
          this.torusIframe.addEventListener("load", async () => {
            const dappMetadata = await getSiteMetadata();
            this.torusIframe.contentWindow.postMessage({
              buttonPosition,
              apiKey: apiKey2,
              network,
              dappMetadata,
              extraParams,
              whiteLabel
            }, torusIframeUrl.origin);
            await this._setupWeb3({
              torusUrl
            });
            if (showTorusButton)
              this.showTorusButton();
            if (whiteLabel?.topupHide)
              this.isTopupHidden = whiteLabel.topupHide;
            else
              this.hideTorusButton();
            this.isInitialized = true;
            window.torus = this;
            resolve3();
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    await documentReady();
    await handleSetup();
  }
  async login() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this.isInitialized)
      throw new Error("Call init() first");
    try {
      this.requestedLoginProvider = params.loginProvider || null;
      if (!this.requestedLoginProvider) {
        this.communicationProvider._displayIframe({
          isFull: true
        });
      }
      const res = await new Promise((resolve3, reject) => {
        this.provider._rpcRequest({
          method: "solana_requestAccounts",
          params: [this.requestedLoginProvider, params.login_hint]
        }, getRpcPromiseCallback(resolve3, reject));
      });
      if (Array.isArray(res) && res.length > 0) {
        return res;
      }
      throw new Error("Login failed");
    } catch (error) {
      log4.error("login failed", error);
      throw error;
    } finally {
      if (this.communicationProvider.isIFrameFullScreen)
        this.communicationProvider._displayIframe();
    }
  }
  async loginWithPrivateKey(loginParams) {
    if (!this.isInitialized)
      throw new Error("Call init() first");
    const {
      privateKey,
      userInfo
    } = loginParams;
    const {
      success
    } = await this.communicationProvider.request({
      method: "login_with_private_key",
      params: {
        privateKey,
        userInfo
      }
    });
    if (!success)
      throw new Error("Login Failed");
  }
  async logout() {
    if (!this.communicationProvider.isLoggedIn)
      throw new Error("Not logged in");
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.LOGOUT,
      params: []
    });
    this.requestedLoginProvider = null;
  }
  async cleanUp() {
    if (this.communicationProvider.isLoggedIn) {
      await this.logout();
    }
    this.clearInit();
  }
  clearInit() {
    function isElement(element) {
      return element instanceof Element || element instanceof Document;
    }
    if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
      this.styleLink.remove();
      this.styleLink = void 0;
    }
    if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
      this.torusIframe.remove();
      this.torusIframe = void 0;
    }
    if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {
      this.torusAlert = void 0;
      this.torusAlertContainer.remove();
      this.torusAlertContainer = void 0;
    }
    this.isInitialized = false;
  }
  hideTorusButton() {
    this.communicationProvider.hideTorusButton();
  }
  showTorusButton() {
    this.communicationProvider.showTorusButton();
  }
  async setProvider(params) {
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.SET_PROVIDER,
      params: _objectSpread2({}, params)
    });
  }
  async showWallet(path3) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const instanceId = await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,
      params: []
    });
    const finalPath = path3 ? `/${path3}` : "";
    const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);
    finalUrl.searchParams.append("instanceId", instanceId);
    Object.keys(params).forEach((x2) => {
      finalUrl.searchParams.append(x2, params[x2]);
    });
    if (this.dappStorageKey) {
      finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
    }
    const walletWindow = new PopupHandler({
      url: finalUrl,
      features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)
    });
    walletWindow.open();
  }
  async getUserInfo() {
    const userInfoResponse = await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.USER_INFO,
      params: []
    });
    return userInfoResponse;
  }
  async initiateTopup(provider, params) {
    if (!this.isInitialized)
      throw new Error("Torus is not initialized");
    const windowId = getWindowId();
    this.communicationProvider._handleWindow(windowId);
    const topupResponse = await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.TOPUP,
      params: {
        provider,
        params,
        windowId
      }
    });
    return topupResponse;
  }
  // Solana specific API
  async getAccounts() {
    const response = await this.provider.request({
      method: "getAccounts",
      params: []
    });
    return response;
  }
  async sendTransaction(transaction) {
    const isLegacyTransaction = isLegacyTransactionInstance(transaction);
    const message = isLegacyTransaction ? transaction.serialize({
      requireAllSignatures: false
    }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
    const response = await this.provider.request({
      method: "send_transaction",
      params: {
        message,
        isLegacyTransaction
      }
    });
    return response;
  }
  // support sendOptions
  async signAndSendTransaction(transaction, options) {
    const isLegacyTransaction = isLegacyTransactionInstance(transaction);
    const message = isLegacyTransaction ? transaction.serialize({
      requireAllSignatures: false
    }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
    const response = await this.provider.request({
      method: "send_transaction",
      params: {
        message,
        options,
        isLegacyTransaction
      }
    });
    return {
      signature: response
    };
  }
  async signTransaction(transaction) {
    const isLegacyTransaction = isLegacyTransactionInstance(transaction);
    const message = isLegacyTransaction ? transaction.serializeMessage().toString("hex") : Buffer.from(transaction.message.serialize()).toString("hex");
    const response = await this.provider.request({
      method: "sign_transaction",
      params: {
        message,
        messageOnly: true,
        isLegacyTransaction
      }
    });
    const parsed = JSON.parse(response);
    const signature = {
      publicKey: new PublicKey(parsed.publicKey),
      signature: Buffer.from(parsed.signature, "hex")
    };
    transaction.addSignature(signature.publicKey, signature.signature);
    return transaction;
  }
  async signAllTransactions(transactions) {
    let isLegacyTransaction;
    const encodedMessage = transactions.map((tx) => {
      isLegacyTransaction = isLegacyTransactionInstance(tx);
      return isLegacyTransaction ? tx.serializeMessage().toString("hex") : Buffer.from(tx.message.serialize()).toString("hex");
    });
    const responses = await this.provider.request({
      method: "sign_all_transactions",
      params: {
        message: encodedMessage,
        messageOnly: true,
        isLegacyTransaction
      }
    });
    const signatures = responses.map((item) => {
      const parsed = JSON.parse(item);
      return {
        publicKey: new PublicKey(parsed.publicKey),
        signature: Buffer.from(parsed.signature, "hex")
      };
    });
    transactions.forEach((tx, idx) => {
      tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);
      return tx;
    });
    return transactions;
  }
  async signMessage(data) {
    const response = await this.provider.request({
      method: "sign_message",
      params: {
        data
      }
    });
    return response;
  }
  async getGaslessPublicKey() {
    const response = await this.provider.request({
      method: "get_gasless_public_key",
      params: []
    });
    return response;
  }
  // async connect(): Promise<boolean> {
  //   const response = (await this.provider.request({
  //     method: "connect",
  //     params: {},
  //   })) as boolean;
  //   return response;
  // }
  handleDappStorageKey(useLocalStorage) {
    const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;
    let dappStorageKey = "";
    if (isLocalStorageAvailable && useLocalStorage) {
      const storedKey = window.localStorage.getItem(localStorageKey);
      if (storedKey)
        dappStorageKey = storedKey;
      else {
        const generatedKey = `torus-app-${getWindowId()}`;
        window.localStorage.setItem(localStorageKey, generatedKey);
        dappStorageKey = generatedKey;
      }
    }
    this.dappStorageKey = dappStorageKey;
    return dappStorageKey;
  }
  async _setupWeb3(providerParams) {
    log4.info("setupWeb3 running");
    const providerStream = new BasePostMessageStream({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: this.torusIframe.contentWindow
    });
    const communicationStream = new BasePostMessageStream({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: this.torusIframe.contentWindow
    });
    const inPageProvider = new TorusInPageProvider(providerStream, {});
    const communicationProvider = new TorusCommunicationProvider(communicationStream, {});
    inPageProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {
        if (!this.communicationProvider.isLoggedIn)
          throw new Error("User Not Logged In");
        const windowId = getWindowId();
        communicationProvider._handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
        });
        _payload.windowId = windowId;
      }
      inPageProvider._rpcEngine.handle(_payload, cb);
    };
    communicationProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {
        const windowId = getWindowId();
        communicationProvider._handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW)
          // todo: are these features generic for all
        });
        _payload.params.windowId = windowId;
      }
      communicationProvider._rpcEngine.handle(_payload, cb);
    };
    const detectAccountRequestPrototypeModifier = (m4) => {
      const originalMethod = inPageProvider[m4];
      const self2 = this;
      inPageProvider[m4] = function providerFunc(request4, cb) {
        const {
          method,
          params = []
        } = request4;
        if (method === "solana_requestAccounts") {
          if (!cb)
            return self2.login({
              loginProvider: params[0]
            });
          self2.login({
            loginProvider: params[0]
          }).then((res) => cb(null, res)).catch((err) => cb(err));
        }
        return originalMethod.apply(this, [request4, cb]);
      };
    };
    detectAccountRequestPrototypeModifier("request");
    detectAccountRequestPrototypeModifier("sendAsync");
    detectAccountRequestPrototypeModifier("send");
    const proxiedInPageProvider = new Proxy(inPageProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    const proxiedCommunicationProvider = new Proxy(communicationProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    this.provider = proxiedInPageProvider;
    this.communicationProvider = proxiedCommunicationProvider;
    await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread2(_objectSpread2({}, providerParams), {}, {
      dappStorageKey: this.dappStorageKey,
      torusAlertContainer: this.torusAlertContainer,
      torusIframe: this.torusIframe
    }))]);
    log4.debug("Torus - injected provider");
  }
};
export {
  BUTTON_POSITION,
  LOGIN_PROVIDER2 as LOGIN_PROVIDER,
  PAYMENT_PROVIDER,
  TORUS_BUILD_ENV,
  TorusInPageProvider,
  Torus as default
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=/build/_shared/solanaEmbed.esm-3LHSNXMG.js.map
