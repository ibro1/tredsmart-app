import { existsSync } from 'node:fs';
import mapWorkspaces from '@npmcli/map-workspaces';
import { createPkgGraph } from '@pnpm/workspace.pkgs-graph';
import micromatch from 'micromatch';
import { ConfigurationValidator } from './ConfigurationValidator.js';
import { ROOT_WORKSPACE_NAME, DEFAULT_EXTENSIONS, KNIP_CONFIG_LOCATIONS } from './constants.js';
import { defaultRules } from './issues/initializers.js';
import * as plugins from './plugins/index.js';
import { arrayify } from './util/array.js';
import parsedArgValues from './util/cli-arguments.js';
import { partitionCompilers } from './util/compilers.js';
import { ConfigurationError, LoaderError } from './util/errors.js';
import { findFile, loadJSON } from './util/fs.js';
import { getIncludedIssueTypes } from './util/get-included-issue-types.js';
import { _dirGlob } from './util/glob.js';
import { _load } from './util/loader.js';
import { getKeysByValue } from './util/object.js';
import { join, relative, toPosix } from './util/path.js';
import { normalizePluginConfig, toCamelCase } from './util/plugin.js';
import { _require } from './util/require.js';
import { unwrapFunction } from './util/unwrapFunction.js';
import { byPathDepth } from './util/workspace.js';
const { config: rawConfigArg, workspace: rawWorkspaceArg, include = [], exclude = [], dependencies = false, exports = false, } = parsedArgValues;
const workspaceArg = rawWorkspaceArg ? toPosix(rawWorkspaceArg).replace(/^\.\//, '').replace(/\/$/, '') : undefined;
const getDefaultWorkspaceConfig = (extensions) => {
    const exts = [...DEFAULT_EXTENSIONS, ...(extensions ?? [])].map(ext => ext.slice(1)).join(',');
    return {
        entry: [`{index,cli,main}.{${exts}}!`, `src/{index,cli,main}.{${exts}}!`],
        project: [`**/*.{${exts}}!`],
        paths: {},
        ignore: [],
        ignoreBinaries: [],
        ignoreDependencies: [],
        isIncludeEntryExports: false,
    };
};
const defaultConfig = {
    rules: defaultRules,
    include: [],
    exclude: [],
    ignore: [],
    ignoreBinaries: [],
    ignoreDependencies: [],
    ignoreExportsUsedInFile: false,
    ignoreWorkspaces: [],
    isIncludeEntryExports: false,
    syncCompilers: new Map(),
    asyncCompilers: new Map(),
    defaultWorkspaceConfig: getDefaultWorkspaceConfig(),
    rootPluginConfigs: {},
};
const PLUGIN_NAMES = Object.keys(plugins);
export class ConfigurationChief {
    cwd;
    isProduction = false;
    isStrict = false;
    isIncludeEntryExports = false;
    config;
    manifestPath;
    manifest;
    ignoredWorkspacePatterns = [];
    manifestWorkspaces = new Map();
    additionalWorkspaceNames = new Set();
    availableWorkspaceNames = [];
    availableWorkspacePkgNames = new Set();
    availableWorkspaceDirs = [];
    availableWorkspaceManifests = [];
    workspacesGraph;
    enabledWorkspaces = [];
    resolvedConfigFilePath;
    rawConfig;
    constructor({ cwd, isProduction, isStrict, isIncludeEntryExports }) {
        this.cwd = cwd;
        this.isProduction = isProduction;
        this.isStrict = isStrict;
        this.isIncludeEntryExports = isIncludeEntryExports;
        this.config = defaultConfig;
    }
    async init() {
        const manifestPath = findFile(this.cwd, 'package.json');
        const manifest = manifestPath && (await loadJSON(manifestPath));
        if (!manifestPath || !manifest) {
            throw new ConfigurationError('Unable to find package.json');
        }
        this.manifestPath = manifestPath;
        this.manifest = manifest;
        const pnpmWorkspacesPath = findFile(this.cwd, 'pnpm-workspace.yaml');
        const pnpmWorkspaces = pnpmWorkspacesPath && (await _load(pnpmWorkspacesPath));
        if (this.manifest && !this.manifest.workspaces && pnpmWorkspaces) {
            this.manifest.workspaces = pnpmWorkspaces;
        }
        for (const configPath of rawConfigArg ? [rawConfigArg] : KNIP_CONFIG_LOCATIONS) {
            this.resolvedConfigFilePath = findFile(this.cwd, configPath);
            if (this.resolvedConfigFilePath)
                break;
        }
        if (rawConfigArg && !this.resolvedConfigFilePath && !manifest.knip) {
            throw new ConfigurationError(`Unable to find ${rawConfigArg} or package.json#knip`);
        }
        this.rawConfig = this.resolvedConfigFilePath
            ? await this.loadResolvedConfigurationFile(this.resolvedConfigFilePath)
            : manifest.knip;
        const parsedConfig = this.rawConfig ? ConfigurationValidator.parse(partitionCompilers(this.rawConfig)) : {};
        this.config = this.normalize(parsedConfig);
        await this.setWorkspaces();
    }
    async loadResolvedConfigurationFile(configPath) {
        const loadedValue = await _load(configPath);
        try {
            return await unwrapFunction(loadedValue);
        }
        catch (e) {
            throw new ConfigurationError(`Error running the function from ${configPath}`);
        }
    }
    getCompilers() {
        return [this.config.syncCompilers, this.config.asyncCompilers];
    }
    getRules() {
        return this.config.rules;
    }
    getFilters() {
        if (this.workspacesGraph?.graph && workspaceArg)
            return { dir: join(this.cwd, workspaceArg) };
        return {};
    }
    normalize(rawConfig) {
        const rules = { ...defaultRules, ...rawConfig.rules };
        const include = rawConfig.include ?? defaultConfig.include;
        const exclude = rawConfig.exclude ?? defaultConfig.exclude;
        const ignore = arrayify(rawConfig.ignore ?? defaultConfig.ignore);
        const ignoreBinaries = rawConfig.ignoreBinaries ?? [];
        const ignoreExportsUsedInFile = rawConfig.ignoreExportsUsedInFile ?? false;
        const ignoreDependencies = rawConfig.ignoreDependencies ?? [];
        const ignoreWorkspaces = rawConfig.ignoreWorkspaces ?? defaultConfig.ignoreWorkspaces;
        const isIncludeEntryExports = rawConfig.includeEntryExports ?? this.isIncludeEntryExports;
        const { syncCompilers, asyncCompilers } = rawConfig;
        const extensions = [...Object.keys(syncCompilers ?? {}), ...Object.keys(asyncCompilers ?? {})];
        const defaultWorkspaceConfig = getDefaultWorkspaceConfig(extensions);
        const rootPluginConfigs = {};
        for (const [name, pluginConfig] of Object.entries(rawConfig)) {
            const pluginName = toCamelCase(name);
            if (PLUGIN_NAMES.includes(pluginName)) {
                rootPluginConfigs[pluginName] = normalizePluginConfig(pluginConfig);
            }
        }
        return {
            rules,
            include,
            exclude,
            ignore,
            ignoreBinaries,
            ignoreDependencies,
            ignoreExportsUsedInFile,
            ignoreWorkspaces,
            isIncludeEntryExports,
            syncCompilers: new Map(Object.entries(syncCompilers ?? {})),
            asyncCompilers: new Map(Object.entries(asyncCompilers ?? {})),
            rootPluginConfigs,
            defaultWorkspaceConfig,
        };
    }
    async setWorkspaces() {
        this.ignoredWorkspacePatterns = this.getIgnoredWorkspacePatterns();
        this.manifestWorkspaces = await this.getManifestWorkspaces();
        this.additionalWorkspaceNames = await this.getAdditionalWorkspaceNames();
        this.availableWorkspaceNames = this.getAvailableWorkspaceNames();
        this.availableWorkspaceDirs = this.availableWorkspaceNames
            .sort(byPathDepth)
            .reverse()
            .map(dir => join(this.cwd, dir));
        this.availableWorkspaceManifests = this.getAvailableWorkspaceManifests(this.availableWorkspaceDirs);
        this.availableWorkspacePkgNames = this.getAvailableWorkspacePkgNames(this.availableWorkspaceManifests);
        this.workspacesGraph = createPkgGraph(this.availableWorkspaceManifests);
        this.enabledWorkspaces = this.getEnabledWorkspaces();
    }
    getListedWorkspaces() {
        return this.manifest?.workspaces
            ? Array.isArray(this.manifest.workspaces)
                ? this.manifest.workspaces
                : this.manifest.workspaces.packages ?? []
            : [];
    }
    getIgnoredWorkspacePatterns() {
        const ignoredWorkspaces = this.getListedWorkspaces()
            .filter(name => name.startsWith('!'))
            .map(name => name.replace(/^!/, ''));
        return [...ignoredWorkspaces, ...this.config.ignoreWorkspaces];
    }
    async getManifestWorkspaces() {
        const workspaces = await mapWorkspaces({
            pkg: this.manifest ?? {},
            cwd: this.cwd,
        });
        const manifestWorkspaces = new Map();
        for (const [pkgName, dir] of workspaces.entries()) {
            manifestWorkspaces.set(relative(this.cwd, dir) || ROOT_WORKSPACE_NAME, pkgName);
        }
        return manifestWorkspaces;
    }
    getConfiguredWorkspaceKeys() {
        const initialWorkspaces = this.rawConfig?.workspaces
            ? Object.keys(this.rawConfig.workspaces)
            : [ROOT_WORKSPACE_NAME];
        const ignoreWorkspaces = this.rawConfig?.ignoreWorkspaces ?? defaultConfig.ignoreWorkspaces;
        return initialWorkspaces.filter(workspaceName => !ignoreWorkspaces.includes(workspaceName));
    }
    async getAdditionalWorkspaceNames() {
        const workspaceKeys = this.getConfiguredWorkspaceKeys();
        const patterns = workspaceKeys.filter(key => key.includes('*'));
        const dirs = workspaceKeys.filter(key => !key.includes('*'));
        const globbedDirs = await _dirGlob({ patterns, cwd: this.cwd });
        return new Set([...dirs, ...globbedDirs].filter(name => name !== ROOT_WORKSPACE_NAME &&
            !this.manifestWorkspaces.has(name) &&
            !micromatch.isMatch(name, this.ignoredWorkspacePatterns)));
    }
    getAvailableWorkspaceNames() {
        return [ROOT_WORKSPACE_NAME, ...this.manifestWorkspaces.keys(), ...this.additionalWorkspaceNames].filter(name => !micromatch.isMatch(name, this.ignoredWorkspacePatterns));
    }
    getAvailableWorkspaceManifests(availableWorkspaceDirs) {
        return availableWorkspaceDirs.map(dir => {
            const manifest = _require(join(dir, 'package.json'));
            if (!manifest)
                throw new LoaderError(`Unable to load package.json for ${dir}`);
            return { dir, manifest };
        });
    }
    getAvailableWorkspacePkgNames(availableWorkspaceManifests) {
        const pkgNames = new Set();
        for (const { dir, manifest } of availableWorkspaceManifests) {
            if (!manifest.name)
                throw new ConfigurationError(`Missing package name in ${join(dir, 'package.json')}`);
            if (pkgNames.has(manifest.name))
                throw new ConfigurationError(`Duplicate package name: ${manifest.name}`);
            pkgNames.add(manifest.name);
        }
        return pkgNames;
    }
    getEnabledWorkspaces() {
        if (workspaceArg && !existsSync(workspaceArg)) {
            throw new ConfigurationError(`Directory does not exist: ${workspaceArg}`);
        }
        const getAncestors = (name) => (ancestors, ancestorName) => {
            if (name === ancestorName)
                return ancestors;
            if (ancestorName === ROOT_WORKSPACE_NAME || name.startsWith(ancestorName + '/'))
                ancestors.push(ancestorName);
            return ancestors;
        };
        const workspaceNames = workspaceArg
            ? [...this.availableWorkspaceNames.reduce(getAncestors(workspaceArg), []), workspaceArg]
            : this.availableWorkspaceNames;
        const graph = this.workspacesGraph?.graph;
        const ws = new Set();
        if (workspaceArg && this.isStrict) {
            ws.add(workspaceArg);
        }
        else if (graph && workspaceArg) {
            const seen = new Set();
            const initialWorkspaces = new Set(workspaceNames.map(name => join(this.cwd, name)));
            const workspaceDirsWithDependants = new Set(initialWorkspaces);
            const addDependents = (dir) => {
                seen.add(dir);
                const deps = graph[dir]?.dependencies ?? [];
                if (deps.length > 0 && Array.from(initialWorkspaces).some(dir => deps.includes(dir))) {
                    workspaceDirsWithDependants.add(dir);
                }
                deps.filter(dir => !seen.has(dir)).forEach(addDependents);
            };
            this.availableWorkspaceNames.map(name => join(this.cwd, name)).forEach(addDependents);
            workspaceDirsWithDependants.forEach(dir => ws.add(relative(this.cwd, dir) || ROOT_WORKSPACE_NAME));
        }
        else {
            workspaceNames.forEach(name => ws.add(name));
        }
        return Array.from(ws)
            .sort(byPathDepth)
            .map((name) => {
            const dir = join(this.cwd, name);
            const pkgName = this.availableWorkspaceManifests.find(p => p.dir === dir)?.manifest.name ?? `NOT_FOUND_${name}`;
            return {
                name,
                pkgName,
                dir,
                config: this.getConfigForWorkspace(name),
                ancestors: this.availableWorkspaceNames.reduce(getAncestors(name), []),
                manifestPath: join(dir, 'package.json'),
                manifest: this.availableWorkspaceManifests?.find(item => item.dir === dir)?.manifest ?? {},
            };
        });
    }
    getWorkspaces() {
        return this.enabledWorkspaces;
    }
    getDescendentWorkspaces(name) {
        return this.availableWorkspaceNames
            .filter(workspaceName => workspaceName !== name)
            .filter(workspaceName => name === ROOT_WORKSPACE_NAME || workspaceName.startsWith(name + '/'));
    }
    getIgnoredWorkspacesFor(name) {
        return this.ignoredWorkspacePatterns
            .filter(workspaceName => workspaceName !== name)
            .filter(workspaceName => name === ROOT_WORKSPACE_NAME || workspaceName.startsWith(name));
    }
    getNegatedWorkspacePatterns(name) {
        const descendentWorkspaces = this.getDescendentWorkspaces(name);
        const matchName = new RegExp(`^${name}/`);
        const ignoredWorkspaces = this.getIgnoredWorkspacesFor(name);
        return [...ignoredWorkspaces, ...descendentWorkspaces]
            .map(workspaceName => workspaceName.replace(matchName, ''))
            .map(workspaceName => `!${workspaceName}`);
    }
    getConfigKeyForWorkspace(workspaceName) {
        return this.getConfiguredWorkspaceKeys()
            .sort(byPathDepth)
            .reverse()
            .find(pattern => micromatch.isMatch(workspaceName, pattern));
    }
    getConfigForWorkspace(workspaceName) {
        const key = this.getConfigKeyForWorkspace(workspaceName);
        const defaultConfig = this.config.defaultWorkspaceConfig;
        const workspaces = this.rawConfig?.workspaces ?? {};
        const workspaceConfig = (key
            ? key === ROOT_WORKSPACE_NAME && !(ROOT_WORKSPACE_NAME in workspaces)
                ? this.rawConfig
                : workspaces[key]
            : {}) ?? {};
        const entry = workspaceConfig.entry ? arrayify(workspaceConfig.entry) : defaultConfig.entry;
        const project = workspaceConfig.project ? arrayify(workspaceConfig.project) : defaultConfig.project;
        const paths = workspaceConfig.paths ?? defaultConfig.paths;
        const ignore = arrayify(workspaceConfig.ignore);
        const ignoreBinaries = arrayify(workspaceConfig.ignoreBinaries);
        const ignoreDependencies = arrayify(workspaceConfig.ignoreDependencies);
        const isIncludeEntryExports = workspaceConfig.includeEntryExports ?? this.config.isIncludeEntryExports;
        const plugins = {};
        for (const [name, pluginConfig] of Object.entries(this.config.rootPluginConfigs)) {
            const pluginName = toCamelCase(name);
            if (typeof pluginConfig !== 'undefined')
                plugins[pluginName] = pluginConfig;
        }
        for (const [name, pluginConfig] of Object.entries(workspaceConfig)) {
            const pluginName = toCamelCase(name);
            if (PLUGIN_NAMES.includes(pluginName)) {
                plugins[pluginName] = normalizePluginConfig(pluginConfig);
            }
        }
        return { entry, project, paths, ignore, ignoreBinaries, ignoreDependencies, isIncludeEntryExports, ...plugins };
    }
    getIssueTypesToReport() {
        const cliArgs = { include, exclude, dependencies, exports };
        const excludesFromRules = getKeysByValue(this.config.rules, 'off');
        const config = {
            include: this.config.include ?? [],
            exclude: [...excludesFromRules, ...this.config.exclude],
            isProduction: this.isProduction,
        };
        return getIncludedIssueTypes(cliArgs, config);
    }
    findWorkspaceByFilePath(filePath) {
        const workspaceDir = this.availableWorkspaceDirs.find(workspaceDir => filePath.startsWith(workspaceDir + '/'));
        return this.enabledWorkspaces.find(workspace => workspace.dir === workspaceDir);
    }
    getUnusedIgnoredWorkspaces() {
        const ignoredWorkspaceNames = this.config.ignoreWorkspaces;
        const workspaceNames = [...this.manifestWorkspaces.keys(), ...this.additionalWorkspaceNames];
        return ignoredWorkspaceNames.filter(ignoredWorkspaceName => !workspaceNames.some(name => micromatch.isMatch(name, ignoredWorkspaceName)));
    }
}
