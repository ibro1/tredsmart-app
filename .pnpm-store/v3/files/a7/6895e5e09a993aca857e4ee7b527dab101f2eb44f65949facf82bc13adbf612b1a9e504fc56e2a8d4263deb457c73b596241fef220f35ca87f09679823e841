import ts from 'typescript';
import { DEFAULT_EXTENSIONS } from './constants.js';
import { IGNORED_FILE_EXTENSIONS } from './constants.js';
import { getJSDocTags, getLineAndCharacterOfPosition, isInModuleBlock } from './typescript/ast-helpers.js';
import { createHosts } from './typescript/createHosts.js';
import { getImportsAndExports } from './typescript/getImportsAndExports.js';
import { createCustomModuleResolver } from './typescript/resolveModuleNames.js';
import { SourceFileManager } from './typescript/SourceFileManager.js';
import { isMaybePackageName, sanitizeSpecifier } from './util/modules.js';
import { dirname, extname, isInNodeModules, join } from './util/path.js';
import { timerify } from './util/Performance.js';
const baseCompilerOptions = {
    allowJs: true,
    allowSyntheticDefaultImports: true,
    declaration: false,
    declarationMap: false,
    esModuleInterop: true,
    inlineSourceMap: false,
    inlineSources: false,
    jsx: ts.JsxEmit.Preserve,
    jsxImportSource: undefined,
    lib: [],
    noEmit: true,
    skipDefaultLibCheck: true,
    skipLibCheck: true,
    sourceMap: false,
};
const tsCreateProgram = timerify(ts.createProgram);
export class ProjectPrincipal {
    entryPaths = new Set();
    projectPaths = new Set();
    skipExportsAnalysis = new Set();
    isGitIgnored;
    cwd;
    compilerOptions;
    extensions;
    syncCompilers;
    asyncCompilers;
    backend;
    constructor({ compilerOptions, cwd, compilers, isGitIgnored }) {
        this.cwd = cwd;
        this.isGitIgnored = isGitIgnored;
        this.compilerOptions = {
            ...compilerOptions,
            ...baseCompilerOptions,
            allowNonTsExtensions: [...compilers].flat().length > 0,
        };
        const [syncCompilers, asyncCompilers] = compilers;
        this.extensions = new Set([...DEFAULT_EXTENSIONS, ...syncCompilers.keys(), ...asyncCompilers.keys()]);
        this.syncCompilers = syncCompilers;
        this.asyncCompilers = asyncCompilers;
        const { fileManager, compilerHost, languageServiceHost, resolveModuleNames } = createHosts({
            cwd: this.cwd,
            compilerOptions: this.compilerOptions,
            entryPaths: this.entryPaths,
            compilers: [this.syncCompilers, this.asyncCompilers],
        });
        const languageService = ts.createLanguageService(languageServiceHost, ts.createDocumentRegistry());
        const lsFindReferences = timerify(languageService?.findReferences);
        this.backend = {
            fileManager,
            compilerHost,
            resolveModuleNames,
            lsFindReferences,
        };
    }
    createProgram() {
        this.backend.program = tsCreateProgram(Array.from(this.entryPaths), this.compilerOptions, this.backend.compilerHost, this.backend.program);
        const typeChecker = timerify(this.backend.program.getTypeChecker);
        typeChecker();
    }
    hasAcceptedExtension(filePath) {
        return this.extensions.has(extname(filePath));
    }
    addEntryPath(filePath, options) {
        if (!isInNodeModules(filePath) && this.hasAcceptedExtension(filePath)) {
            this.entryPaths.add(filePath);
            this.projectPaths.add(filePath);
            if (options?.skipExportsAnalysis)
                this.skipExportsAnalysis.add(filePath);
        }
    }
    addEntryPaths(filePaths, options) {
        filePaths.forEach(filePath => this.addEntryPath(filePath, options));
    }
    addProjectPath(filePath) {
        if (!isInNodeModules(filePath) && this.hasAcceptedExtension(filePath)) {
            this.projectPaths.add(filePath);
        }
    }
    async runAsyncCompilers() {
        const add = timerify(this.backend.fileManager.compileAndAddSourceFile.bind(this.backend.fileManager));
        const extensions = Array.from(this.asyncCompilers.keys());
        const files = Array.from(this.projectPaths).filter(filePath => extensions.includes(extname(filePath)));
        for (const filePath of files) {
            await add(filePath);
        }
    }
    getUsedResolvedFiles() {
        this.createProgram();
        const sourceFiles = this.getProgramSourceFiles();
        return Array.from(this.projectPaths).filter(filePath => sourceFiles.has(filePath));
    }
    getProgramSourceFiles() {
        const programSourceFiles = this.backend.program?.getSourceFiles().map(sourceFile => sourceFile.fileName);
        return new Set(programSourceFiles);
    }
    getUnreferencedFiles() {
        const sourceFiles = this.getProgramSourceFiles();
        return Array.from(this.projectPaths).filter(filePath => !sourceFiles.has(filePath));
    }
    analyzeSourceFile(filePath, { skipTypeOnly }) {
        const sourceFile = this.backend.fileManager.getSourceFile(filePath);
        if (!sourceFile)
            throw new Error(`Unable to find ${filePath}`);
        const skipExports = this.skipExportsAnalysis.has(filePath);
        const getResolvedModule = specifier => this.backend.program?.getResolvedModule
            ? this.backend.program.getResolvedModule(sourceFile, specifier, undefined)
            : sourceFile.resolvedModules?.get(specifier, undefined);
        const { imports, exports, scripts } = getImportsAndExports(sourceFile, getResolvedModule, {
            skipTypeOnly,
            skipExports,
        });
        const { internal, unresolved, external } = imports;
        const unresolvedImports = new Set();
        unresolved.forEach(unresolvedImport => {
            const { specifier } = unresolvedImport;
            if (specifier.startsWith('http')) {
                return;
            }
            const resolvedModule = this.resolveModule(specifier, filePath);
            if (resolvedModule) {
                if (resolvedModule.isExternalLibraryImport) {
                    const sanitizedSpecifier = sanitizeSpecifier(specifier);
                    external.add(sanitizedSpecifier);
                }
                else {
                    const isIgnored = this.isGitIgnored(resolvedModule.resolvedFileName);
                    if (!isIgnored)
                        this.addEntryPath(resolvedModule.resolvedFileName, { skipExportsAnalysis: true });
                }
            }
            else {
                const sanitizedSpecifier = sanitizeSpecifier(specifier);
                if (isMaybePackageName(sanitizedSpecifier)) {
                    external.add(sanitizedSpecifier);
                }
                else {
                    const isIgnored = this.isGitIgnored(join(dirname(filePath), sanitizedSpecifier));
                    if (!isIgnored) {
                        const ext = extname(sanitizedSpecifier);
                        const hasIgnoredExtension = IGNORED_FILE_EXTENSIONS.includes(ext);
                        if (!ext || (ext !== '.json' && !hasIgnoredExtension)) {
                            unresolvedImports.add(unresolvedImport);
                        }
                    }
                }
            }
        });
        return {
            imports: {
                internal,
                unresolved: unresolvedImports,
                external,
            },
            exports,
            scripts,
        };
    }
    resolveModule(specifier, filePath = specifier) {
        return this.backend.resolveModuleNames([specifier], filePath)[0];
    }
    getHasReferences(filePath, exportedItem) {
        const hasReferences = { external: false, internal: false };
        const pos = exportedItem.posDecl ?? exportedItem.pos;
        const symbolReferences = this.findReferences(filePath, pos).flatMap(f => f.references);
        for (const reference of symbolReferences) {
            if (reference.fileName === filePath) {
                if (!reference.isDefinition) {
                    hasReferences.internal = true;
                }
            }
            else {
                hasReferences.external = true;
            }
        }
        if (!hasReferences.external && hasReferences.internal) {
            hasReferences.external = isInModuleBlock(exportedItem.node);
        }
        return hasReferences;
    }
    findUnusedMembers(filePath, members) {
        return members.filter(member => {
            if (getJSDocTags(member.node).has('@public'))
                return false;
            const referencedSymbols = this.findReferences(filePath, member.pos);
            const files = referencedSymbols
                .flatMap(refs => refs.references)
                .filter(ref => !ref.isDefinition)
                .map(ref => ref.fileName);
            const internalRefs = files.filter(f => f === filePath);
            const externalRefs = files.filter(f => f !== filePath);
            return externalRefs.length === 0 && internalRefs.length === 0;
        });
    }
    findReferences(filePath, pos) {
        try {
            return this.backend.lsFindReferences(filePath, pos) ?? [];
        }
        catch {
            return [];
        }
    }
    getPos(node, pos) {
        return getLineAndCharacterOfPosition(node, pos);
    }
}
