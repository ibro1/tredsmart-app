"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNpmResolver = exports.RegistryResponseError = exports.workspacePrefToNpm = exports.parsePref = exports.NoMatchingVersionError = void 0;
const path_1 = __importDefault(require("path"));
const error_1 = require("@pnpm/error");
const resolve_workspace_range_1 = require("@pnpm/resolve-workspace-range");
const lru_cache_1 = require("lru-cache");
const normalize_path_1 = __importDefault(require("normalize-path"));
const p_memoize_1 = __importDefault(require("p-memoize"));
const clone_1 = __importDefault(require("ramda/src/clone"));
const semver_1 = __importDefault(require("semver"));
const ssri_1 = __importDefault(require("ssri"));
const pickPackage_1 = require("./pickPackage");
const parsePref_1 = require("./parsePref");
Object.defineProperty(exports, "parsePref", { enumerable: true, get: function () { return parsePref_1.parsePref; } });
const fetch_1 = require("./fetch");
Object.defineProperty(exports, "RegistryResponseError", { enumerable: true, get: function () { return fetch_1.RegistryResponseError; } });
const createNpmPkgId_1 = require("./createNpmPkgId");
const workspacePrefToNpm_1 = require("./workspacePrefToNpm");
Object.defineProperty(exports, "workspacePrefToNpm", { enumerable: true, get: function () { return workspacePrefToNpm_1.workspacePrefToNpm; } });
class NoMatchingVersionError extends error_1.PnpmError {
    constructor(opts) {
        const dep = opts.wantedDependency.alias
            ? `${opts.wantedDependency.alias}@${opts.wantedDependency.pref ?? ''}`
            : opts.wantedDependency.pref;
        super('NO_MATCHING_VERSION', `No matching version found for ${dep}`);
        this.packageMeta = opts.packageMeta;
    }
}
exports.NoMatchingVersionError = NoMatchingVersionError;
// This file contains meta information
// about all the packages published by the same name, not just the manifest
// of one package/version
const META_DIR = 'metadata';
const FULL_META_DIR = 'metadata-full';
const FULL_FILTERED_META_DIR = 'metadata-v1.1';
function createNpmResolver(fetchFromRegistry, getAuthHeader, opts) {
    if (typeof opts.cacheDir !== 'string') {
        throw new TypeError('`opts.cacheDir` is required and needs to be a string');
    }
    const fetchOpts = {
        retry: opts.retry ?? {},
        timeout: opts.timeout ?? 60000,
    };
    const fetch = (0, p_memoize_1.default)(fetch_1.fromRegistry.bind(null, fetchFromRegistry, fetchOpts), {
        cacheKey: (...args) => JSON.stringify(args),
        maxAge: 1000 * 20, // 20 seconds
    });
    const metaCache = new lru_cache_1.LRUCache({
        max: 10000,
        ttl: 120 * 1000, // 2 minutes
    });
    return resolveNpm.bind(null, {
        getAuthHeaderValueByURI: getAuthHeader,
        pickPackage: pickPackage_1.pickPackage.bind(null, {
            fetch,
            filterMetadata: opts.filterMetadata,
            metaCache,
            metaDir: opts.fullMetadata ? (opts.filterMetadata ? FULL_FILTERED_META_DIR : FULL_META_DIR) : META_DIR,
            offline: opts.offline,
            preferOffline: opts.preferOffline,
            cacheDir: opts.cacheDir,
        }),
    });
}
exports.createNpmResolver = createNpmResolver;
async function resolveNpm(ctx, wantedDependency, opts) {
    const defaultTag = opts.defaultTag ?? 'latest';
    if (wantedDependency.pref?.startsWith('workspace:')) {
        if (wantedDependency.pref.startsWith('workspace:.'))
            return null;
        const resolvedFromWorkspace = tryResolveFromWorkspace(wantedDependency, {
            defaultTag,
            lockfileDir: opts.lockfileDir,
            projectDir: opts.projectDir,
            registry: opts.registry,
            workspacePackages: opts.workspacePackages,
        });
        if (resolvedFromWorkspace != null) {
            return resolvedFromWorkspace;
        }
    }
    const workspacePackages = opts.alwaysTryWorkspacePackages !== false ? opts.workspacePackages : undefined;
    const spec = wantedDependency.pref
        ? (0, parsePref_1.parsePref)(wantedDependency.pref, wantedDependency.alias, defaultTag, opts.registry)
        : defaultTagForAlias(wantedDependency.alias, defaultTag);
    if (spec == null)
        return null;
    const authHeaderValue = ctx.getAuthHeaderValueByURI(opts.registry);
    let pickResult;
    try {
        pickResult = await ctx.pickPackage(spec, {
            pickLowestVersion: opts.pickLowestVersion,
            publishedBy: opts.publishedBy,
            authHeaderValue,
            dryRun: opts.dryRun === true,
            preferredVersionSelectors: opts.preferredVersions?.[spec.name],
            registry: opts.registry,
        });
    }
    catch (err) { // eslint-disable-line
        if ((workspacePackages != null) && opts.projectDir) {
            try {
                return tryResolveFromWorkspacePackages(workspacePackages, spec, {
                    wantedDependency,
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                });
            }
            catch {
                // ignore
            }
        }
        throw err;
    }
    const pickedPackage = pickResult.pickedPackage;
    const meta = pickResult.meta;
    if (pickedPackage == null) {
        if ((workspacePackages != null) && opts.projectDir) {
            try {
                return tryResolveFromWorkspacePackages(workspacePackages, spec, {
                    wantedDependency,
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                });
            }
            catch {
                // ignore
            }
        }
        throw new NoMatchingVersionError({ wantedDependency, packageMeta: meta });
    }
    if (((workspacePackages?.[pickedPackage.name]) != null) && opts.projectDir) {
        if (workspacePackages[pickedPackage.name][pickedPackage.version]) {
            return {
                ...resolveFromLocalPackage(workspacePackages[pickedPackage.name][pickedPackage.version], spec.normalizedPref, {
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                }),
                latest: meta['dist-tags'].latest,
            };
        }
        const localVersion = pickMatchingLocalVersionOrNull(workspacePackages[pickedPackage.name], spec);
        if (localVersion && (semver_1.default.gt(localVersion, pickedPackage.version) || opts.preferWorkspacePackages)) {
            return {
                ...resolveFromLocalPackage(workspacePackages[pickedPackage.name][localVersion], spec.normalizedPref, {
                    projectDir: opts.projectDir,
                    lockfileDir: opts.lockfileDir,
                    hardLinkLocalPackages: wantedDependency.injected,
                }),
                latest: meta['dist-tags'].latest,
            };
        }
    }
    const id = (0, createNpmPkgId_1.createPkgId)(opts.registry, pickedPackage.name, pickedPackage.version);
    const resolution = {
        integrity: getIntegrity(pickedPackage.dist),
        tarball: pickedPackage.dist.tarball,
    };
    return {
        id,
        latest: meta['dist-tags'].latest,
        manifest: pickedPackage,
        normalizedPref: spec.normalizedPref,
        resolution,
        resolvedVia: 'npm-registry',
        publishedAt: meta.time?.[pickedPackage.version],
    };
}
function tryResolveFromWorkspace(wantedDependency, opts) {
    if (!wantedDependency.pref?.startsWith('workspace:')) {
        return null;
    }
    const pref = (0, workspacePrefToNpm_1.workspacePrefToNpm)(wantedDependency.pref);
    const spec = (0, parsePref_1.parsePref)(pref, wantedDependency.alias, opts.defaultTag, opts.registry);
    if (spec == null)
        throw new Error(`Invalid workspace: spec (${wantedDependency.pref})`);
    if (opts.workspacePackages == null) {
        throw new Error('Cannot resolve package from workspace because opts.workspacePackages is not defined');
    }
    if (!opts.projectDir) {
        throw new Error('Cannot resolve package from workspace because opts.projectDir is not defined');
    }
    return tryResolveFromWorkspacePackages(opts.workspacePackages, spec, {
        wantedDependency,
        projectDir: opts.projectDir,
        hardLinkLocalPackages: wantedDependency.injected,
        lockfileDir: opts.lockfileDir,
    });
}
function tryResolveFromWorkspacePackages(workspacePackages, spec, opts) {
    if (!workspacePackages[spec.name]) {
        throw new error_1.PnpmError('WORKSPACE_PKG_NOT_FOUND', `In ${path_1.default.relative(process.cwd(), opts.projectDir)}: "${spec.name}@${opts.wantedDependency.pref ?? ''}" is in the dependencies but no package named "${spec.name}" is present in the workspace`, {
            hint: 'Packages found in the workspace: ' + Object.keys(workspacePackages).join(', '),
        });
    }
    const localVersion = pickMatchingLocalVersionOrNull(workspacePackages[spec.name], spec);
    if (!localVersion) {
        throw new error_1.PnpmError('NO_MATCHING_VERSION_INSIDE_WORKSPACE', `In ${path_1.default.relative(process.cwd(), opts.projectDir)}: No matching version found for ${opts.wantedDependency.alias ?? ''}@${opts.wantedDependency.pref ?? ''} inside the workspace`);
    }
    return resolveFromLocalPackage(workspacePackages[spec.name][localVersion], spec.normalizedPref, opts);
}
function pickMatchingLocalVersionOrNull(versions, spec) {
    const localVersions = Object.keys(versions);
    switch (spec.type) {
        case 'tag':
            return semver_1.default.maxSatisfying(localVersions, '*', {
                includePrerelease: true,
            });
        case 'version':
            return versions[spec.fetchSpec] ? spec.fetchSpec : null;
        case 'range':
            return (0, resolve_workspace_range_1.resolveWorkspaceRange)(spec.fetchSpec, localVersions);
        default:
            return null;
    }
}
function resolveFromLocalPackage(localPackage, normalizedPref, opts) {
    let id;
    let directory;
    const localPackageDir = resolveLocalPackageDir(localPackage);
    if (opts.hardLinkLocalPackages) {
        directory = (0, normalize_path_1.default)(path_1.default.relative(opts.lockfileDir, localPackageDir));
        id = `file:${directory}`;
    }
    else {
        directory = localPackageDir;
        id = `link:${(0, normalize_path_1.default)(path_1.default.relative(opts.projectDir, localPackageDir))}`;
    }
    return {
        id,
        manifest: (0, clone_1.default)(localPackage.manifest),
        normalizedPref,
        resolution: {
            directory,
            type: 'directory',
        },
        resolvedVia: 'local-filesystem',
    };
}
function resolveLocalPackageDir(localPackage) {
    if (localPackage.manifest.publishConfig?.directory == null ||
        localPackage.manifest.publishConfig?.linkDirectory === false)
        return localPackage.dir;
    return path_1.default.join(localPackage.dir, localPackage.manifest.publishConfig.directory);
}
function defaultTagForAlias(alias, defaultTag) {
    return {
        fetchSpec: defaultTag,
        name: alias,
        type: 'tag',
    };
}
function getIntegrity(dist) {
    if (dist.integrity) {
        return dist.integrity;
    }
    if (!dist.shasum) {
        return undefined;
    }
    const integrity = ssri_1.default.fromHex(dist.shasum, 'sha1');
    if (!integrity) {
        throw new error_1.PnpmError('INVALID_TARBALL_INTEGRITY', `Tarball "${dist.tarball}" has invalid shasum specified in its metadata: ${dist.shasum}`);
    }
    return integrity.toString();
}
//# sourceMappingURL=index.js.map