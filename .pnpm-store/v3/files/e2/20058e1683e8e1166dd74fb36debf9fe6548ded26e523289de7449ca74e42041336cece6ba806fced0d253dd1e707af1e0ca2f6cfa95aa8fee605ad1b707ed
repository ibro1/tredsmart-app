var {
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const core = require('@sentry/core');
const node = require('@sentry/node');
const utils = require('@sentry/utils');
const process = require('process');
const debugBuild = require('../debug-build.js');
const instrumentServer = require('../instrumentServer.js');

let pkg;

function wrapExpressRequestHandler(
  origRequestHandler,
  build,
) {
  const routes = instrumentServer.createRoutes(build.routes);

  return async function (

    req,
    res,
    next,
  ) {
    if (!pkg) {
      try {
        pkg = await Promise.resolve().then(() => require('react-router-dom'));
      } catch (e) {
        pkg = await Promise.resolve().then(() => require(`${process.cwd()}/node_modules/react-router-dom`));
      } finally {
        if (!pkg) {
          debugBuild.DEBUG_BUILD && utils.logger.error('Could not find `react-router-dom` package.');
        }
      }
    }

    await core.runWithAsyncContext(async () => {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      res.end = wrapEndMethod(res.end);

      const request = utils.extractRequestData(req);
      const hub = core.getCurrentHub();
      const options = _optionalChain([core.getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3()]);
      const scope = core.getCurrentScope();

      scope.setSDKProcessingMetadata({ request });

      if (!options || !core.hasTracingEnabled(options) || !request.url || !request.method) {
        return origRequestHandler.call(this, req, res, next);
      }

      const url = new URL(request.url);

      const [name, source] = instrumentServer.getTransactionName(routes, url, pkg);
      const transaction = instrumentServer.startRequestHandlerTransaction(hub, name, source, {
        headers: {
          'sentry-trace': (req.headers && utils.isString(req.headers['sentry-trace']) && req.headers['sentry-trace']) || '',
          baggage: (req.headers && utils.isString(req.headers.baggage) && req.headers.baggage) || '',
        },
        method: request.method,
      });
      // save a link to the transaction on the response, so that even if there's an error (landing us outside of
      // the domain), we can still finish it (albeit possibly missing some scope data)
      (res ).__sentryTransaction = transaction;
      return origRequestHandler.call(this, req, res, next);
    });
  };
}

function wrapGetLoadContext(origGetLoadContext) {
  return function ( req, res) {
    const loadContext = (origGetLoadContext.call(this, req, res) || {}) ;

    loadContext['__sentry_express_wrapped__'] = true;

    return loadContext;
  };
}

/**
 * Instruments `createRequestHandler` from `@remix-run/express`
 */
function wrapExpressCreateRequestHandler(
  origCreateRequestHandler,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return function ( options) {
    if (!('getLoadContext' in options)) {
      options['getLoadContext'] = () => ({});
    }

    utils.fill(options, 'getLoadContext', wrapGetLoadContext);

    const newBuild = instrumentServer.instrumentBuild(options.build, true);
    const requestHandler = origCreateRequestHandler.call(this, {
      ...options,
      build: newBuild,
    });

    return wrapExpressRequestHandler(requestHandler, newBuild);
  };
}

/**
 * Wrap `res.end()` so that it closes the transaction and flushes events before letting the request finish.
 *
 * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping
 * things in the right order, in this case it's safe, because the native `.end()` actually *is* async, and its run
 * actually *is* awaited, just manually so (which reflects the fact that the core of the request/response code in Node
 * by far predates the introduction of `async`/`await`). When `.end()` is done, it emits the `prefinish` event, and
 * only once that fires does request processing continue. See
 * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.
 *
 * @param origEnd The original `res.end()` method
 * @returns The wrapped version
 */
function wrapEndMethod(origEnd) {
  return async function newEnd( ...args) {
    await finishSentryProcessing(this);

    return origEnd.call(this, ...args);
  };
}

/**
 * Close the open transaction (if any) and flush events to Sentry.
 *
 * @param res The outgoing response for this request, on which the transaction is stored
 */
async function finishSentryProcessing(res) {
  const { __sentryTransaction: transaction } = res;

  if (transaction) {
    transaction.setHttpStatus(res.statusCode);

    // Push `transaction.finish` to the next event loop so open spans have a better chance of finishing before the
    // transaction closes, and make sure to wait until that's done before flushing events
    await new Promise(resolve => {
      setImmediate(() => {
        transaction.end();
        resolve();
      });
    });
  }

  // Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda
  // ends. If there was an error, rethrow it so that the normal exception-handling mechanisms can apply.
  try {
    debugBuild.DEBUG_BUILD && utils.logger.log('Flushing events...');
    await node.flush(2000);
    debugBuild.DEBUG_BUILD && utils.logger.log('Done flushing events');
  } catch (e) {
    debugBuild.DEBUG_BUILD && utils.logger.log('Error while flushing events:\n', e);
  }
}

exports.wrapExpressCreateRequestHandler = wrapExpressCreateRequestHandler;
//# sourceMappingURL=express.js.map
